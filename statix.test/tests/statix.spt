module statix

language StatixTest

/* TODO:
 *
 * - Regular constraints 0, 1, 2+ args args
 * - Inline functional constraints for 0, 1, 2+ outputs
 * - Predicate syntax for functional constraints
 * - Use of wildcards in head (regular, and functional in & out), guard, body
 * - Use of as-patterns in head (regular, and functional in & out), guard, body
 *
 * - New scope creation
 * - Adding scope edges (successful, and delayed)
 * - Adding relation data (successful, and delayed)
 * - Queries (successful, and delayed)
 * - Queries depending on defaults
 * - Resolution queries on declarations
 * - Explicitly refering to resolution policy in a query
 * - Resolution queries on `occurrence -> ...` relations
 * - Variable scoping in lambda's (local variables, context variables, wildcards)
 * - Lambda's in lambda's (shadowing of names, correct behavior)
 *
 */

//---------------------------------------------------------------------

test true succeeds [[
  resolve true
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test false fails [[
  resolve false
]] analysis succeeds
   run evaluate-test to FAILS()

//---------------------------------------------------------------------

test list pattern succeeds [[
  resolve c(["x", "y"])
  rules
    c : list(string)
    c([]).
    c([x|xs]) :- c(xs).
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test list inequality succeeds [[
  resolve c([3, 6])
  rules
    c : list(int)
    c(xs) | xs != [].
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

//---------------------------------------------------------------------

test free variable not unified by guard [[
  resolve {x} c(x)
  rules
    c : int
    c(x) | x == 0.
]] analysis succeeds
   run evaluate-test to FAILS()

test free variable not considered inequal by guard [[
  resolve {x} c(x)
  rules
    c : int
    c(x) | x != 0.
]] analysis succeeds
   run evaluate-test to FAILS()

test equal terms in same-level non-linear pattern succeeds [[
  resolve c([], [])
  rules
    c : list(string) * list(string)
    c(xs, xs).
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test unified terms in same-level non-linear pattern succeeds [[
  resolve {i j} c([i], [j]), i == j
  rules
    c : list(string) * list(string)
    c(xs, xs).
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test equal terms in different-level non-linear pattern succeeds [[
  resolve c(1, [1|_])
  rules
    c : int * list(int)
    c(i, [i|_]).
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test different terms in different-level non-linear pattern fails [[
  resolve c(1, [2|_])
  rules
    c : int * list(int)
    c(i, [i|_]).
]] analysis succeeds
   run evaluate-test to FAILS()

// --------------------------------------------------------------------

test output variable not treated as guard [[
  resolve {x} f(1, x)
  rules
    f : int -> int
    f(x) = x.
]] analysis succeeds
   run evaluate-test to SUCCEEDS()

test return var for tuple output succeeds [[
  resolve c(1) == (1, 1)
  rules
    c : int -> int * int
    c(i) = r :- r == (i, i).
]] analysis succeeds
   run evaluate-test to SUCCEEDS()
