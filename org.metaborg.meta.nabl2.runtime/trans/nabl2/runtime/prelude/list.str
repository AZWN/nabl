module nabl2/runtime/prelude/list

strategies
  
  // n-ary zip 
  zipN: t -> [<ListToTuple> hd* | <ListToTuple;zipN> tl*]
    where ls* := <TupleToList> t;
          hd* := <map(Hd)> ls*;
          tl* := <map(Tl)> ls*

  zipN: t -> []
    where <TupleToList;map(?[])> t


  // merge two sorted lists, merge is stable, i.e. for equal elements,
  // the elements in the left list come before the elements in the right
  // list
  merge-sorted(lt): ([x|x*], [y|y*]) -> z*
    with if <lt> (x,y) then
           ![x|<merge-sorted(lt)> (x*,[y|y*])]
         else
           ![y|<merge-sorted(lt)> ([x|x*],y*)]
         end => z*
 
  merge-sorted(lt): (x*, []) -> x*

  merge-sorted(lt): ([], y*) -> y*
 