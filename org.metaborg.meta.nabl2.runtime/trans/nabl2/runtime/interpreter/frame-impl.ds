module nabl2/runtime/interpreter/frame

imports
  nabl2/runtime/interpreter/frame-api
  nabl2/runtime/interpreter/scopegraph-api
  nabl2/runtime/interpreter/scopegraph-impl

signature

  constructors
    FID : Int -> FrameId {implicit}
    F : Scope * Map(Label, Map(Scope, FrameId)) * Map(Occurrence, Val) -> Frame 
    Heap : Map(FrameId, Frame) -> H {implicit}

//////////////////////////////
// VANILLA FRAMES AND HEAPS //
//////////////////////////////

rules

  // Operations on frames

  initFrame(s, ks, slots) :: H Heap(x) --> ff:FrameId :: H { ff |--> F(s, ks, slots), x }
  where
    fresh => ff.
    
  // Dynamic address lookup  
  // FIXME the scope in a step is the scope stepping from, does this function
  //       use it that way?

  lookup(f, _, D(_, d)) --> Addr(f, d).

  lookup(f1, h, E(s, l, p)) --> Addr(f3, d)
  where
    linksOf(h, f1) --> ks;
    ks[l][s] => f2;
    lookup(f2, h, p) --> Addr(f3, d).
    
  // Fetching and mutating slot values
    
  get(f, h, d) --> v
  where
    slotsOf(h, f) --> slots;
    slots[d] => v.

  set(f, Heap(x), d, v) --> Heap({f |--> F(s, ks, {d |--> v, slots}), x})
  where
    x[f] => F(s, ks, slots).
    
rules
  
  linksOf(Heap(x), f) --> ks
  where
    x[f] => F(_, ks, _).
    
  slotsOf(Heap(x), f) --> slots
  where
    x[f] => F(_, _, slots).

//////////////////////////////
// DEFAULT FRAMES AND HEAPS //
//////////////////////////////

signature
  
  constructors
    DefaultSlots : List(Occurrence) --> Map(Occurrence, Val)

rules

  initDefault(s, ks) :: H Heap(x) --> ff:FrameId :: H { ff |--> F(s, ks, slots), x }
  where
    fresh => ff;
    declsOfScope(s) => ds;
    DefaultSlots(ds) --> slots.
  
  DefaultSlots([]) --> {}.
  
  DefaultSlots([d|ds]) --> { d |--> v, slots }
  where
    typeOfDecl(d) => t;
    t -defaultv-> v;
    DefaultSlots(ds) --> slots.
