module nabl2/runtime/analysis/main

imports

  runtime/analysis/core
  runtime/editor/-
  runtime/index/-

  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

  signatures/nabl2/runtime/analysis/-

signature
  sorts AnalysisAction constructors
    Init : AnalysisAction
    IndexAST : AnalysisAction
    PreprocessAST : AnalysisAction
    GenerateConstraint : AnalysisAction
    NormalizeConstraint : AnalysisAction
    SolveConstraint : AnalysisAction
    PostprocessAST : AnalysisAction

rules // analysis

  analyze(pre,post): Init() -> (params,C)
    with (params,C) := <generate-constraint-init>

  analyze(pre,post): (IndexAST(),ast) -> ast'
    with <debug> ">>> Indexing AST <<<"
    with report-time(
      ast' := <index-ast> ast
    )

  analyze(pre,post): (PreprocessAST(),ast) -> ast'
    with <debug> ">>> Preprocessing AST <<<"
    with report-time(
      ast' := <pre> ast
    )
  
  analyze(pre,post): (GenerateConstraint(),ast,params) -> C
    with <debug> ">>> Generating constraints <<<"
    with report-time(
      C := <generate-constraint-file(|params);normalize-constraint> ast
    )
 
  analyze(pre,post): (NormalizeConstraint(),C) -> C'
    with <debug> ">>> Normalzing constraints <<<"
    with report-time(
      C' := <normalize-constraint> C
    )

  analyze(pre,post): (SolveConstraint(),C) -> S
    with <debug> ">>> Solving constraints <<<"
    with report-time(
      sol-i := <initial-solution>;
      C' := <normalize-constraint> C;
      [(sol-wm1,C1*)] := <solve-constraints-phase1> (sol-i,[C']);
      g := <fromWM;sol-g> sol-wm1;
      fr* := <resolve-all> g;
      (r1*,rn*) := <partition({\ (r,[dp]) -> (r,dp) \})> fr*;
      sol-wm2 := <fmap(sol-add-r(|r1*))> sol-wm1;
      lo* := <join(label-lt)> (<labels>,<labels>);
      sol-wm3* := <solve-constraints-phase2;map(postprocess-errors(|rn*))> (sol-wm2,C1*);
      analysis1* := [
        Constraint(C),
        InitialScopeGraph(g),
        InitialResolution(fr*),
        ResolutionParams(<labels>,<labels-wf>,lo*)
      ]
    )
    with <debug> ">>> Processing solutions <<<"
    with report-time(
      sol-wm* := <qsort((wm-errors;length,wm-errors;length);lt)> sol-wm3*;
      sol* := <map( ![ ScopeGraph(<fromWM;sol-g>)
                     , Typing(<fromWM;sol-p>)
                     , Substitution(<fromWM;sol-s>)
                     , Resolution(<fromWM;sol-r>)
                     , SubtypeRelation(<fromWM;sol-x>)
                     , Errors(<wm-errors>)
                     , Warnings(<wm-warnings>)
                     , Notes(<wm-notes>)
                     ] )> sol-wm*;
      analysis2* := <Hd> sol*;
      (good,bad) := <partition(not(is-erronious));(length,length)> sol-wm*;
      where(<debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.]);
      ( sol-wm := <Hd> sol-wm*
      < where(<debug> "> Found solution <");
        error* := <wm-errors;mapv(xmlencode)> sol-wm;
        warning* := <wm-warnings;mapv(xmlencode)> sol-wm;
        note* := <wm-notes;mapv(xmlencode)> sol-wm
      + where(<debug> "> No solution found <");
        error* := [];
        warning* := [];
        note* := []
      );
      analysis := [analysis1*, analysis2*, AlternativeSolutions(<Tl;map-with-index(id)> sol*)];
      S := (error*, warning*, note*, analysis)
    )

  analyze(pre,post): (PostprocessAST(),ast) -> ast'
    with <debug> ">>> Postprocessing AST <<<"
    with report-time(
      ast' := <post> ast
    )
 
  get-analysis = prim("SSL_EXT_get_analysis")

rules

  report-time(s) = measure-time(s,where(<debug> $[Finished in [<cputime-to-seconds;real-to-string(|2)>]s]))

