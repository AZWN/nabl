module nabl2/runtime/analysis/main

imports

  runtime/analysis/core
  runtime/editor/-
  runtime/index/-

  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

  signatures/nabl2/runtime/analysis/-

signature
  sorts AnalysisAction constructors
    Initialize : String * Term -> AnalysisAction
    IndexAST : String * Term -> AnalysisAction
    PreprocessAST : String * Term -> AnalysisAction
    GenerateConstraint : String * Term * List(Scope) -> AnalysisAction
    NormalizeConstraint : Constraint -> AnalysisAction
    SolveConstraint : Constraint -> AnalysisAction

rules

  analyze(pre): Initialize(source,global) -> C
    with <debug> $[>>> Initializing [source] <<<]
    with report-time(
      C := <generate-constraint-init(|source)> global
    )

  analyze(pre): IndexAST(source,ast) -> ast'
    with <debug> $[>>> Indexing AST [source] <<<]
    with report-time(
      ast' := <index-ast(|source)> ast
    )

  analyze(pre): PreprocessAST(source,ast) -> ast'
    with <debug> $[>>> Preprocessing AST [source] <<<]
    with report-time(
      ast' := <pre> ast
    )
  
  analyze(pre): GenerateConstraint(source,ast,params) -> C
    with <debug> $[>>> Generating constraints [source] <<<]
    with report-time(
      C := <generate-constraint-file(|source,params);normalize-constraint> ast
    )
 
  analyze(pre): NormalizeConstraint(C) -> C'
    with <debug> ">>> Normalizing constraints <<<"
    with report-time(
      C' := <normalize-constraint> C
    )

  analyze(pre): SolveConstraint(C) -> S
    with <debug> ">>> Solving constraints <<<"
    with report-time(
      sol-i := <initial-solution>;
      C' := <normalize-constraint> C;
      [(sol1,C1*)] := <solve-constraints-phase1> (sol-i,[C']);
      g := <sol-g> sol1;
      fr* := <resolve-all> g;
      (r1*,rn*) := <partition({\ (r,[dp]) -> (r,dp) \})> fr*;
      sol2 := <sol-add-r(|r1*)> sol1;
      lo* := <join(label-lt)> (<labels>,<labels>);
      sol3* := <solve-constraints-phase2;map(postprocess-errors(|rn*))> (sol2,C1*);
      analysis1* := [
        Constraint(C),
        InitialScopeGraph(g),
        InitialResolution(fr*),
        ResolutionParams(<labels>,<labels-wf>,lo*)
      ]
    )
    with <debug> ">>> Processing solutions <<<"
    with report-time(
      sol* := <qsort((sol-e;length,sol-e;length);lt)> sol3*;
      analysis2* := <Hd> sol*;
      (good,bad) := <partition(not(is-erronious));(length,length)> sol*;
      with(<debug> $[Found [<int-to-string> good] correct and [<int-to-string> bad] erronious solutions.])
    )
    where
      sol := <Hd> sol*
    with
      error* := <sol-e;mapv(xmlencode)> sol;
      warning* := <sol-w;mapv(xmlencode)> sol;
      note* := <sol-n;mapv(xmlencode)> sol;
      resolution := <sol-r;map((occurrence-index,Fst;occurrence-index))> sol;
      analysis := [
        analysis1*,
        analysis2*,
        AlternativeSolutions(<Tl;map-with-index(id)> sol*)
      ];
      S := (error*, warning*, note*, resolution, analysis)

  analyze(pre) = fatal-err(|"Unknown analysis action")

  get-analysis = prim("SG_get_analysis")

  report-time(s) = measure-time(s,where(<debug> $[Finished in [<cputime-to-seconds;real-to-string(|2)>]s]))

