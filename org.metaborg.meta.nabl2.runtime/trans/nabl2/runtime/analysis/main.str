module nabl2/runtime/analysis/main

imports

  nabl2/api
  
  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-
  nabl2/shared/-

  signatures/nabl2/runtime/analysis/-
  signatures/nabl2/runtime/solver/-
  nabl2/runtime/analysis/-
  nabl2/runtime/common/-
  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-


rules

  nabl2--analyze(pre):
    AnalyzeInitial(resource) -> InitialResult(C,params)
    with nabl2--analysis-step(!$[Initializing [resource]],
      (params,C) := <nabl2--generate-constraint-init(|resource)> resource
    )
    /*
    with nabl2--analysis-step(!$[Custom initial analysis [resource]],
      if custom := <nabl2-custom-analysis-init-hook> resource then
        result' := <nabl2--set-custom-analysis(|custom)> result
      else
        result' := result
      end
    )
    */


  nabl2--analyze(pre):
    AnalyzeUnit(resource,ast,args) -> UnitResult(ast',constraint*)
    where not(<nabl2--is-empty-ast> ast)
    with nabl2--analysis-step(!$[Preprocessing AST [resource]],
      ast' := <pre;nabl2--index-ast(|resource)> ast
    )
    with nabl2--analysis-step(!$[Generating constraints [resource]],
      constraint* := <nabl2--generate-constraint-file(|resource,args)> ast'
    )
    /*
    with nabl2--analysis-step(!$[Custom unit analysis [resource]],
      custom-initial := <nabl2--get-custom-analysis <+ !None()> initial;
      if custom := <nabl2-custom-analysis-unit-hook> (resource, ast', custom-initial) then
        result' := <nabl2--set-custom-analysis(|custom)> result
      else
        result' := result
      end
    )
    */

  nabl2--analyze(pre):
    AnalyzeUnit(resource,ast,_) -> UnitResult(ast,constraint*)
    where <nabl2--is-empty-ast> ast
    with constraint* := [CFalse(Message(Warning(),"Empty file was not parsed.",<nabl2--get-ast-index> resource))]
 

  nabl2--analyze(pre):
    AnalyzeFinal(resource) -> FinalResult()
  /*
    with nabl2--analysis-step(!$[Custom final analysis [resource]],
      custom-initial := <nabl2--get-custom-analysis <+ !None()> initial;
      custom-unit* := <filter(nabl2--get-custom-analysis)> unit*;
      if custom-result := <nabl2-custom-analysis-final-hook(|sol)> (resource, custom-initial, custom-unit*) then
        if (custom-error*, custom-warning*, custom-note*, custom-analysis) := custom-result then
          sol'1 := <foldr(!sol  ,\ (msg,sol) -> <nabl2--sol-add-error(|msg)> sol \)> custom-error*;
          sol'2 := <foldr(!sol'1,\ (msg,sol) -> <nabl2--sol-add-warning(|msg)> sol \)> custom-error*;
          sol'3 := <foldr(!sol'2,\ (msg,sol) -> <nabl2--sol-add-note(|msg)> sol \)> custom-error*;
          sol' := <nabl2--set-custom-analysis(|custom-analysis)> sol'3
        else
          <warn(|"Expected 4-tuple (error*,warning*,note*,custom-analysis) from custom final analysis, got:")> custom-result;
          sol' := sol
        end
      else
        sol' := <switch !(custom-initial, custom-unit*)
          case ?(None(), [])     : !sol
          case ?(None(), custom) : <nabl2--set-custom-analysis(|custom)> sol
          case ?(custom, [])     : <nabl2--set-custom-analysis(|custom)> sol
          case ?custom           : <nabl2--set-custom-analysis(|custom)> sol
        end>
      end
    )
    */


  nabl2--is-empty-ast = is-tuple; ?()

  nabl2--analysis-step(msg,s) =
    where(not(nabl2-debug-analysis-hook));
    s

  nabl2--analysis-step(msg,s) =
    where(nabl2-debug-analysis-hook);
    with(msg := <msg>; <debug> $[>>> [msg]]);
    measure-time(s,with(<debug> $[<<< [msg] (finished in [<cputime-to-seconds;real-to-string(|2)>]s)]))

  nabl2--time-analysis(key,s) =
    measure-time(s,?time');
    where(
      key := <key>;
      (count,time) := <key;AnalysisTiming <+ !(0,0.0)> key;
      rules(AnalysisTiming : key -> (<inc> count, <add> (time,time'))))

  nabl2--get-analysis-timing =
    dr-all-keys(|"AnalysisTiming");
    map(!(<id>,<AnalysisTiming;(id,cputime-to-seconds)>))
 <+ ![]
