module nabl2/runtime/solver/solver

imports

  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

signature

  constructors
    Active : Term -> Liveness
    Done   : Term -> Liveness

rules 
 
  // csolve-exhaustive :: (sol,[c]) -> [(sol,[c])] 
  // solve for all possible solutions

  csolve-exhaustive(pre,solve,post,s-cost,c-lt) = strict(
    map((id,csolve-one-sort(c-lt)));
    mapconcat(csolve-exhaustive-acc(pre,solve,post,s-cost,c-lt));
    time-analysis(!"solution sorting",qsort(csolve-exhaustive-lt(s-cost)))
  )

  csolve-exhaustive-lt(s-cost) =
    strict((s-cost,s-cost));
    lt

  csolve-exhaustive-acc(pre,solve,post,s-cost,c-lt) = strict(
    csolve-one(pre,solve,c-lt)
  < mapconcat(csolve-exhaustive-acc(pre,solve,post,s-cost,c-lt))
  + ![<post>]
  )
 
  // csolve-greedy :: (sol,[c]) -> [(sol,[c])] 
  // solve for the best solution (solve all good
  // branches exhaustively)

  csolve-greedy(pre,solve,post,s-cost,c-lt) = strict(
    map((id,csolve-one-sort(c-lt)));
    map(!Active(<id>));
    csolve-greedy-sort(s-cost);
    csolve-greedy-acc(pre,solve,post,s-cost,id,c-lt);
    map(csolve-unwrap(id))
  )
 
  csolve-greedy-acc(pre,solve,post,s-cost,s-guard,c-lt) = strict(
    if Hd;csolve-unwrap(s-cost);s-guard then
      if ?[Active(s)|s*] then
        if s'* := <csolve-one(pre,solve,c-lt)> s then
          <map(!Active(<id>));csolve-greedy-sort(s-cost)> s'*
        else
          ![Done(<post> s)]
        end;
        <csolve-greedy-insert(s-cost)> (<id>,s*);
        csolve-greedy-acc(pre,solve,post,s-cost,s-guard,c-lt)
      else
        if ?[s,s'|s*]; <csolve-unwrap(s-cost);?0> s' then
          ![s'|s*];
          csolve-greedy-acc(pre,solve,post,s-cost,?0,c-lt);
          ![s|<id>]
        end
      end
    end
  )

  csolve-greedy-insert(s-cost) =
    time-analysis(!"solution sorting",merge-sorted(csolve-greedy-lt(s-cost)))
    

  // compare solutions, first by errors, then active over done
  csolve-greedy-lt(s-cost) = strict(
    ?ss;
    cc := <(csolve-unwrap(s-cost),csolve-unwrap(s-cost))>
  );
  ( <lt> cc
 <+ <eq> cc;
    (Done(_),Active(_)) := ss
  )
 
  // sort list of solutions
  csolve-greedy-sort(s-cost) =
    time-analysis(!"solution sorting",qsort(csolve-greedy-lt(s-cost)))

  csolve-apply(s)  = strict(Active(s) + Done(s))
  csolve-unwrap(s) = strict(?Active(<s>) + ?Done(<s>))

  // csolve-one :: (sol,[c]) -> [(sol,[c])]
  // solve one constraint, or fail
 
  csolve-one(pre,solve,c-lt) =
    ?(sol,active*);
    <csolve-one-acc(pre,solve,c-lt)> (sol,active*,[])

  csolve-one-acc(pre,solve,c-lt) =
    ?(sol,[c|active*],defer*);
    with((sol',c') := <pre> (sol,c));
    ( s'* := <solve> (c',sol')
    < <map({ sol', new*, new'*, active'*:
        ?(sol',new*);
        new'* :=  <qsort(c-lt)> new*;
        active'* := <csolve-one-insert(c-lt)> (new'*,active*);
        !(sol', [active'*,defer*])
      })> s'*
    + <csolve-one-acc(pre,solve,c-lt)> (sol,active*,[c'|defer*])
    )

    csolve-one-sort(c-lt) =
      time-analysis(!"constraint sorting",qsort(c-lt))

    csolve-one-insert(c-lt) =
      time-analysis(!"constraint sorting",merge-sorted(c-lt))
 