module nabl2/runtime/solver/solver

imports

  nabl2/runtime/prelude/-
  nabl2/runtime/solver/-

signature

  constructors
    Active : Term -> Liveness
    Done   : Term -> Liveness

rules 
 
  // csolve-exhaustive :: (sol,[c]) -> [(sol,[c])] 
  // solve for all possible solutions

  csolve-exhaustive(pre,solve,post,s-lt,c-lt) =
    map((id,csolve-one-sort(c-lt)));
    mapconcat(csolve-exhaustive-acc(pre,solve,post,s-lt,c-lt));
    time-analysis(!"solution sorting",qsort(s-lt))

  csolve-exhaustive-acc(pre,solve,post,s-lt,c-lt) =
    csolve-one(pre,solve,c-lt)
  < mapconcat(csolve-exhaustive-acc(pre,solve,post,s-lt,c-lt))
  + ![<post>]
 
  // csolve-greedy :: (sol,[c]) -> [(sol,[c])] 
  // solve for the best solution (solve all good
  // branches exhaustively)

  csolve-greedy(pre,solve,post,s-lt,s-good,c-lt) =
    map((id,csolve-one-sort(c-lt)));
    map(!Active(<id>));
    csolve-greedy-sort(s-lt);
    csolve-greedy-acc(pre,solve,post,s-lt,s-good,id,c-lt);
    map(csolve-unwrap)
 
  csolve-greedy-acc(pre,solve,post,s-lt,s-good,s-guard,c-lt) =
    if ?[Active(s)|s*]; <s-guard> s then
      if s'* := <csolve-one(pre,solve,c-lt)> s then
        <map(!Active(<id>));csolve-greedy-sort(s-lt)> s'*
      else
        ![Done(<post> s)]
      end;
      <csolve-greedy-insert(s-lt)> (<id>,s*);
      csolve-greedy-acc(pre,solve,post,s-lt,s-good,s-guard,c-lt)
    else
      if ?[s,s'|s*]; <csolve-greedy-pred1(s-good)> s' then
        ![s'|s*];
        csolve-greedy-acc(pre,solve,post,s-lt,s-good,s-good,c-lt);
        ![s|<conc> (<id>,s*)]
      end
    end

  csolve-greedy-insert(s-lt) =
    time-analysis(!"solution sorting",merge-sorted(csolve-greedy-lt(s-lt)))

  // compare solutions, first by errors, then active over done
  csolve-greedy-lt(s-lt) =
    csolve-greedy-pred2(s-lt)
 <+ ?(Done(_),Active(_))
 

  // test if solution is good
  csolve-greedy-pred1(s) =
    with(s := <csolve-unwrap>);
    where(<s> s)

  csolve-greedy-pred2(s) =
    with( ss := <(csolve-unwrap,csolve-unwrap)> );
    where(<s> ss)

  // sort list of solutions
  csolve-greedy-sort(s-lt) =
    time-analysis(!"solution sorting",qsort(csolve-greedy-lt(s-lt)))

  csolve-unwrap = ?Active(<id>) + ?Done(<id>)

  // csolve-one :: (sol,[c]) -> [(sol,[c])]
  // solve one constraint, or fail
 
  csolve-one(pre,solve,c-lt) =
    ?(sol,active*);
    <csolve-one-acc(pre,solve,c-lt)> (sol,active*,[])

  csolve-one-acc(pre,solve,c-lt) =
    ?(sol,[c|active*],defer*);
    with((sol',c') := <pre> (sol,c));
    ( s'* := <solve> (c',sol')
    < <map({ sol', new*, new'*, active'*:
        ?(sol',new*);
        new'* :=  <qsort(c-lt)> new*;
        active'* := <csolve-one-insert(c-lt)> (new'*,active*);
        !(sol', [active'*,defer*])
      })> s'*
    + <csolve-one-acc(pre,solve,c-lt)> (sol,active*,[c'|defer*])
    )

    csolve-one-sort(c-lt) =
      time-analysis(!"constraint sorting",qsort(c-lt))
 
    csolve-one-insert(c-lt) =
      time-analysis(!"constraint sorting",merge-sorted(c-lt))
 