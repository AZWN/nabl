module nabl2/runtime/solver/base

imports

  nabl2shared
  nabl2/runtime/common/-
  nabl2/runtime/solver/-

rules
	
  solve-fact = fail
  
  solve-constraint = fail	
	
  constraint-priority = fail	
	
rules

  initial-solution = sol-new

	solve-ignore-placeholders: (c,sol) -> [(sol,[])]
	where <is-NaBL2-PrimitiveConstraint;
	       has-placeholder> c

  has-placeholder =
    not(?Message(_,_,_));
    (is-SDF-placeholder <+ one(has-placeholder))

  solve-facts =
    csolve-exhaustive( time-analysis(!"specialize",solve-specialise)
                     , solve-ignore-placeholders + solve-fact
                     , id
                     , solve-errors-lt
                     , constraint-lt
                     )

  solve-constraints =
    csolve-greedy( time-analysis(!"specialize",solve-specialise)
                 , solve-ignore-placeholders + solve-constraint
                 , postprocess-errors
                 , solve-errors-lt
                 , solve-zero-errors
                 , constraint-lt
                 )

  solve-specialise: (sol,c) -> res
  with <sol-s> sol => s*
     ; <S-apply(is-var)> (s*,c) => c'
     ; {| ReduceErrors:
            rules(ReduceErrors : _ -> [])
          ; <bottomup(try(reduce-op(|sol)))> c' => c''
          ; re* := <ReduceErrors>
          ; if [] := re*
            then
              !(sol,c'')
            else
              msg' := <get-constraint-message> c'
            ; msg'' := <foldr(!msg',{ ?(re,<id>) ; detail-message(|re) })> re*
            ; sol' := <add-message(id|msg'')> sol
            ; !(sol',CTrue())
            end
       |} => res

  add-reduce-error(|msg) =
    where(msg* := <ReduceErrors> ; rules(ReduceErrors : _ -> [msg|msg*]))

  solve-errors-lt =
    with( ll := <(Fst;sol-e;length, Fst;sol-e;length)> );
    <lt> ll

  solve-messages-lt =
    let count(s) = Fst ; s ; length
        comp(s) = with( ll := <(count(s), count(s))> ) ; <lt> ll
    in
      comp(sol-e) <+ comp(sol-w) <+ comp(sol-n)
    end

  solve-zero-errors =
   Fst ; sol-e ; length ; ?0

rules
 
  solve-fact = time-analysis(!"base",solve-base-fact) 
  solve-constraint = time-analysis(!"base",solve-base-constraint) 
 
  solve-base-fact = solve-junction

  solve-base-constraint: (CTrue(),sol) -> [(sol,[])]
  solve-base-constraint: (CFalse(msginfo),sol) -> [(sol',[])]
    with msg  := "False never succeeds";
         sol' := <add-message(default-message(|msg)|msginfo)> sol
  solve-base-constraint = solve-junction

  solve-junction: (CConj(c*),sol) -> [(sol,c*)]
  solve-junction: (CDisj(c*),sol) -> <map(\ c -> (sol,[c]) \)> c*
 
  constraint-priority: CTrue() -> 0
  constraint-priority: CFalse(_) -> 0
  constraint-priority: CConj(_) -> 0
  constraint-priority: CDisj(_) -> 0

rules

  constraint-lt =
    with( ll := <(constraint-priority-or-default,constraint-priority-or-default)> );
    <lt> ll
  
  constraint-priority-or-default = constraint-priority <+ !99

rules
 
  debug-solve(s): i@(c,sol) -> o*
    with <debug> $[solve [<pp-NaBL2-Constraint> c]]
    where if o* := <s> i then
            <with(map(Snd;debug;map(pp-NaBL2-Constraint);debug(!"--> ")))> o*
          else
            <debug> "--> (unsolved)"; fail
          end

