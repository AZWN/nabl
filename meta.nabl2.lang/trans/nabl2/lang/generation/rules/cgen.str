module nabl2/lang/generation/rules/cgen

imports

  libstrc

  nabl2/shared/-
  signatures/nabl2/shared/constraints/-
 
  signatures/nabl2/lang/common/-
  signatures/nabl2/lang/rules/-

  nabl2/lang/generation/-
  nabl2/lang/generation/-
  nabl2/lang/util/stratego

rules

  section-to-str:
    Rules(rule*) -> Rules([pp-str*, rule-str*])
    with
      rule-str* := <map(rule-to-str)> rule*;
      pp-str*   := <getfirst(?CGenInitRule(_,_,_));pp-rules <+ ![]> rule*

  rule-to-str:
    CGenRule(rdef@InitRule(),pattern,params,type,clause)
      -> RDefT(sname, sparams, [],
           Rule(spattern, sresult, strclause*))
    with
      sname    := <rdef-strategy-name> rdef;
      sparams  := <rdef-strategy-params> rdef;
      spattern := Term |[ (~<source-var>, ~pattern) ]|;
      sresult  := Term |[ (~<args-var>, ~<constraint-var>) ]|;
 
      index-str := |[ ~<index-var> := <nabl2--get-ast-index> ~<term-var> ]|;

      bound-var* := <all-vars> pattern;
      used-var*  := <concat;make-set> [ <all-vars> params
                                      , <all-vars> type
                                      , <nabl2--free-constraint-vars> clause
                                      ];
      free-var*  := <diff> (used-var*, bound-var*);
      var-str    := <vars-to-str> free-var*;

      params-term := <explode(injection-to-term)> params;
      if Type(type') := type then
        type-term := <explode(injection-to-term)> type';
        args-str := |[ ~<args-var> := ParamsAndType(~params-term,~type-term) ]|;
        debug-str := Strat |[ if nabl2--is-debug-collection-enabled then nabl2--collection-info-msg(|<concat-strings> ["init ^ ",<pp-NaBL2-CTerm> ~params-term," : ",<pp-NaBL2-objlangterm> ~type-term]) end ]|
      else
        args-str := |[ ~<args-var> := Params(~params-term) ]|;
        debug-str := Strat |[ if nabl2--is-debug-collection-enabled then nabl2--collection-info-msg(|<concat-strings> ["init ^ ",<pp-NaBL2-CTerm> ~params-term]) end ]|
      end;

      constraint-str  := |[ ~<constraint-var> := ~(<constraint-to-term> clause) ]|;

      strclause* := [
        With(var-str),
        With(index-str),
        With(args-str),
        With(constraint-str),
        With(debug-str)
      ]
 
  rule-to-str:
    CGenRule(rdef,pattern,params,type,clause)
      -> RDefT(sname, sparams, [],
           Rule(spattern, sresult, strclause*))
    with
      sname    := <rdef-strategy-name> rdef;
      sparams  := <rdef-strategy-params> rdef;
      spattern := Term |[ (~<source-var>, ~pattern, ~<args-var>) ]|;
      sresult  := <constraint-var>;

      index-str := |[ ~<index-var> := <nabl2--get-ast-index> ~<term-var> ]|;

      bound-var* := <concat;make-set> [ <all-vars> pattern
                                      , <all-vars> params
                                      , <all-vars> type
                                      ];
      used-var*  := <nabl2--free-constraint-vars> clause;
      free-var*  := <diff> (used-var*, bound-var*);
      var-str    := <vars-to-str> free-var*;

      pattern-string := Str(<strip-as-pattern;pp-stratego-string> pattern);
      params-pattern := As(<params-var>,<explode(injection-to-pattern)> params);
      params-string := <strip-as-pattern;pp-stratego-string> params-pattern;
      if Type(type') := type then
        type-pattern := As(<type-var>,<explode(injection-to-pattern)> type');
        type-string :=  <strip-as-pattern;pp-stratego-string> type-pattern;
        args-pattern := Term |[ ParamsAndType(~params-pattern,~type-pattern) ]|;
        args-string := Str($[^ [params-string] : [type-string]]);
        args-str := |[
          ~args-pattern := ~<args-var>
        ]|;
        debug-str := |[ if nabl2--is-debug-collection-enabled then nabl2--collection-info-msg(|<concat-strings> [~Str(<rdef-name> rdef)," [[ ",<pp-NaBL2-Term> ~<term-var>," ^ ",<pp-NaBL2-CTerm> ~<params-var>," : ",<pp-NaBL2-objlangterm> ~<type-var>," ]]"]) end ]|
      else
        args-pattern := Term |[ Params(~params-pattern) ]|;
        args-string := Str($[^ [params-string]]);
        args-str := |[
          ~args-pattern := ~<args-var>
        ]|;
        debug-str := |[ if nabl2--is-debug-collection-enabled then nabl2--collection-info-msg(|<concat-strings> [~Str(<rdef-name> rdef)," [[ ",<pp-NaBL2-Term> ~<term-var>," ^ ",<pp-NaBL2-CTerm> ~<params-var>," ]]"]) end ]|
      end;
      guarded-args-str := |[
        ~args-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~args-string," with actual ",<nabl2--pp-flat-args> ~<args-var>,
                                                  " when matching ",~pattern-string, " with ",<pp-NaBL2-Term> ~<term-var>,"."])
      ]|;

      constraint-str  := |[ ~<constraint-var> := ~(<constraint-to-term> clause) ]|;

      strclause* := [
        With(var-str),
        With(index-str),
        With(guarded-args-str),
        With(debug-str),
        With(constraint-str)
      ]
 
  rdef-strategy-name = !$[nabl2--generate-constraint-[<rdef-name>]-rule]

  rdef-strategy-params: InitRule()    -> []
  rdef-strategy-params: DefaultRule() -> []
  rdef-strategy-params: Rule(_,rs)    -> <map(\ r -> SVar(<rdef-strategy-name> Rule(r,[])) \)> rs
 
rules

  rule-to-str:
    FunDef(fdef,arg*,clause)
      -> RDefT(fname, [], [],
           Rule(fpattern, fresult, strclause*))
    with
      fname := <fun-name> fdef;
      fpattern := Term|[ (~<source-var>, ~<term-var>, ~<args-var>) ]|; 
      fresult  := <constraint-var>;

      index-str := |[ ~<index-var> := <nabl2--get-ast-index> ~<term-var> ]|;

      bound-var* := arg*;
      used-var*  := <nabl2--free-constraint-vars> clause;
      free-var*  := <diff> (used-var*, bound-var*);
      var-str    := <vars-to-str> free-var*;

      args-pattern := <explode(injection-to-pattern)> Tuple([arg*]);
      args-string := Str(<pp-stratego-string> args-pattern);
      args-str := |[ ~args-pattern := ~<args-var> ]|;
      guarded-args-str := |[
        ~args-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~args-string," with actual ",<nabl2--pp-flat-term> ~<args-var>," in call to ",~Str(fdef)])
      ]|;
      debug-str := |[ if nabl2--is-debug-collection-enabled then nabl2--collection-info-msg(|<concat-strings> [" << ",~Str(fdef),"(",<nabl2--pp-flat-term> ~<args-var>,") >>"]) end ]|;

      constraint-str  := |[ ~<constraint-var> := ~(<constraint-to-term> clause) ]|;

      strclause* := [
        With(index-str),
        With(guarded-args-str),
        With(debug-str),
        With(constraint-str)
      ]
 
  fun-name =
    !$[nabl2--constraint-function-[<id>]]
 

rules

  vars-to-str:
    v* -> str
    with str := <mapseq({\
                   v -> |[ ~v := <nabl2--new-var(|~<source-var>);try(nabl2--copy-origin(|~<term-var>))> ~n ]|
                   with n := Str(<var-name> v)
                 \})> v*

rules
 
  constraint-to-term =
    explode(explode-guard)
 
  explode-guard(e) = injection-to-term(e)
  explode-guard(e) = cgenrecurse-to-term(e)
  explode-guard(e) = funcall-to-term(e)

  cgenrecurse-to-term(e):
    CGenRecurse(rref,v,params,type) -> App(recurse-str,Tuple([<source-var>,v,recurse-arg]))
    with
      params-term := <e> params;
      if Type(type') := type then
        type-term := <e> type';
        recurse-arg := Term |[ ParamsAndType(~params-term,~type-term) ]|
      else
        recurse-arg := Term |[ Params(~params-term) ]|
      end;
      recurse-str := CallT(SVar("nabl2--generate-constraint"),[<rdef-strategy-call> rref],[Str(<rdef-name> rref)])

  rdef-strategy-call: DefaultRule()      -> CallNoArgs(SVar(<rdef-strategy-name> DefaultRule()))
  rdef-strategy-call: rdef@Rule(name,rs) -> Call(SVar(<rdef-strategy-name> rdef), <map(rdef-strategy-call)> rs)

  funcall-to-term(e):
    FunCall(name,arg*) -> App(fun-str,Tuple([<source-var>,<term-var>,args-term]))
    with
      args-term := Tuple(<map(e)> arg*);
      fun-str := Call(SVar(<fun-name> name),[])

rules

  pp-language-spec-name = prim("pp_language_spec_name")

  pp-rules =
    pp-name := <pp-language-spec-name>;
    ![ SDefT($[prettyprint-[pp-name]],[],[DefaultVarDec("sort")],CallT(SVar("prettyprint-NaBL2-api-term"),[],[Var("sort")]))
     , SDefT($[prettyprint-[pp-name]-NaBL2Scope],[],[],CallT(SVar("prettyprint-NaBL2-api-term"),[],[]))
     , SDefT($[prettyprint-[pp-name]-NaBL2Occurrence],[],[],CallT(SVar("prettyprint-NaBL2-api-term"),[],[]))
     ]
