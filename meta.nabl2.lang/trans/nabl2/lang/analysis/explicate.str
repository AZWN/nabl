module nabl2/lang/analysis/explicate

imports

  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-

  signatures/nabl2/lang/common/-
  signatures/nabl2/lang/modules/-
  signatures/nabl2/lang/rules/-
  signatures/nabl2/lang/signatures/-

  nabl2/lang/analysis/-
  nabl2/lang/generation/-
  nabl2/lang/util/-

  nabl2/shared/-

/**************************************
 * Explication rules
 * - make implicit things explicit
 * - preserve pretty-printability
 **************************************/

rules

  explicate-all =
    explicate-rule-params;
    explicate-rule-types;
    explicate-rule-wildcards;
    explicate-rule-matches;
    explicate-messages;
    explicate-indices;
    normalize-rule-clauses

rules

  explicate-rule-free-vars = try(sometd(explicate-rule-free-var))

  explicate-rule-free-var:
    CGenRule(rdef,pattern,params,type,clause)
      -> CGenRule(rdef,pattern,params,type,clause')
    with used-var* := <nabl2--free-constraint-vars> clause;
         rule-var* := <all-vars> (pattern,params,type);
         free-var* := <diff(strip-annos;eq);make-set> (used-var*, [<term-var>,rule-var*]);
         clause' := <nabl2--make-cexists> (free-var*, clause)

rules

  explicate-rule-params = try(sometd(explicate-rule-param))

  explicate-rule-param:
    CGenRule(rdef,pattern,param,type,clause)
      -> CGenRule(rdef,pattern,param,type,<nabl2--make-cconj> [clause'*,clause])
    with if InitRule() := rdef then
           clause'* := []
         else
           clause'* := [ CAstProperty(TermIndexFrom(<term-var>),Params(),param)
                       ]
         end

rules

  explicate-rule-types = try(sometd(explicate-rule-type))

  explicate-rule-type:
    CGenRule(rdef,pattern,param,Type(type),clause)
      -> CGenRule(rdef,pattern,param,Type(<type-var>),<nabl2--make-cconj> [clause'*,clause])
    with if InitRule() := rdef then
           clause'* := []
         else
           clause'* := [ CEqual(<type-var>, type, DefaultMessage())
                       , CAstProperty(TermIndexFrom(<term-var>),Type(),<type-var>)
                       ]
         end

rules

  explicate-rule-matches = try(sometd(explicate-rule-match))

  explicate-rule-match:
    CGenRule(rdef,pattern,param,type,clause)
      -> CGenRule(rdef,As(<term-var>,pattern),param,type,clause)

rules

  explicate-rule-wildcards = try(sometd(explicate-rule-wildcard))

  explicate-rule-wildcard:
    rule@CGenRule(_,_,_,_,_) -> rule'
    with rule' := <wlds-to-vars> rule

  explicate-rule-wildcard:
    fun@FunctionDef(_,_,_) -> fun'
    with fun' := <wlds-to-vars> fun

  wlds-to-vars: clause -> clause'
    with var-set := <new-iset>;
         {| NextVar:
           with(var-counter := <new-counter>);
           rules(
             NextVar: _ -> var
               with var := Var($[nabl2_wld[<next-counter;int-to-string> var-counter]]);
                    <iset-add(|var)> var-set
           );
           clause' := <topdown(try(\ Wld() -> <NextVar> \))> clause
         |};
         var* := <iset-elements> var-set

rules

  explicate-messages = topdown(try(explicate-message))

  // create default error message
  explicate-message:
    DefaultMessage() ->
      Message(Error(),Default(),DefaultMessagePosition())

rules

  explicate-indices =
    topdown(try(explicate-occurrence-indices));
    topdown(try(explicate-default-index))

  // record pattern vars to see if we can get index from name itself
  // otherwise, use matched term
  explicate-occurrence-indices:
    CGenRule(rdef,pattern,params,type,clause)
      -> CGenRule(rdef,pattern,params,type,clause')
    with pattern-var* := <all-vars> pattern;
         {| PatternVar:
           <map({v: ?v; rules(PatternVar: v -> v) })> pattern-var*;
           clause' := <topdown(try(explicate-occurrence-index))> clause
         |}

  explicate-occurrence-index:
    Occurrence(ns,name,DefaultOccurrenceIndex()) ->
      Occurrence(ns,name,OccurrenceIndexFrom(index))
    with index := <(is-var;PatternVar) <+ term-var> name

  // get index from matched term
  explicate-default-index:
    DefaultMessagePosition() -> TermIndexFrom(<term-var>)
