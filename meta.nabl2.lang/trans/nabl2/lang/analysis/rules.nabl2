module nabl2/lang/analysis/rules

imports

  signatures/nabl2/lang/rules/-

  nabl2/lang/analysis/common
  nabl2/lang/analysis/constraints

rules // constraint generation rules

  [[ Rules(rules) ^ (s_mod, s_root) ]] :=
    Map2(Rule)[[ rules ^ (s_mod, s_root) ]].

  Rule[[ CGenInitRule(params, type, clauses) ^ (s_mod, s_root) ]] :=
    InitMarker{()} <- s_mod,
    new s_rule,
    s_rule ---> s_mod,
    RuleType[[ type ^ (s_rule) ]],
    Map1(Clause)[[ clauses ^ (s_rule) ]].
 
  Rule[[ CGenMatchRule(def, pattern, params, type, clauses) ^ (s_mod, s_root) ]] :=
    new s_rule,
    s_rule ---> s_mod,
    RuleDef[[ def ^ (s_root, s_rule) ]],
    Term(ScopeVarDecl)[[ pattern ^ (s_rule) ]],
    RuleParams[[ params ^ (s_rule) ]],
    RuleType[[ type ^ (s_rule) ]],
    Map1(Clause)[[ clauses ^ (s_rule) ]].
 
  RuleParams[[ Tuple(params) ^ (s) ]] :=
    Map1(Term(ScopeVarDecl))[[ params ^ (s) ]].
 
  RuleType[[ NoType() ^ (s) ]]. 

  RuleType[[ Type(type) ^ (s) ]] :=
    Term(ScopeVarDecl)[[ type ^ (s) ]].
 
  RuleDef[[ NoName() ^ (s_rule, s_params) ]].

  RuleDef[[ Name(name, params) ^ (s_rule, s_params) ]] :=
    Rule{name @s_rule} <- s_rule,
    Map1(RuleDefParam)[[ params ^ (s_params) ]].

  RuleDefParam[[ name ^ (s) ]] :=
    Rule{name @s} <- s.

  RuleRef[[ NoName() ^ (s) ]].

  RuleRef[[ Name(name, args) ^ (s) ]] :=
    Rule{name} -> s,
    Rule{name} |-> _,
    Map1(RuleRef)[[ args ^ (s) ]].

rules

  Clause[[ CGenRecurse(ref, var, params, type) ^ (s) ]] :=
    RuleRef[[ ref ^ (s) ]],
    Term(VarRef)[[ var ^ (s) ]].
 
  Clause[[ NewScopes(scopes) ^ (s) ]] :=
    Map1(ScopeVarDecl)[[ scopes ^ (s) ]].
 
  Clause[[ NewVars(vars) ^ (s) ]] :=
    Map1(ScopeVarDecl)[[ vars ^ (s) ]].
 
rules // constraint generation functions

  Rule[[ FunDef(_,_,_) ^ (_,_) ]]. // TODO

  Clause[[ FunCall(_,_) ^ (_) ]]. // TODO
