module statixruntime

imports

  libstratego-lib
  libstratego-gpp

  libspoofax/analysis/constraint
  libspoofax/core/language

  pp/statix/runtime/-

signature
  constructors

    ProjectAnalysis : Scope * Constraint * Analysis -> AnalysisResult
    FileAnalysis    : Constraint -> AnalysisResult

    /* injection */ : List(Var, Term) -> SolveResult

    // duplicates from statix.lang
    Scope : String * String -> Scope
    CTrue : Constraint
    CConj : Constraint * Constraint -> Constraint
    C     : String * List(Term) -> Constraint

rules

  stx-analyze(|spec-name, init-constraint) =
    with(warn-msg(|"Using 'stx-analyze' is deprecated, use 'stx-editor-analyze' instead."));
  ( stx-editor-analyze(id|spec-name, init-constraint)
 <+ <stx-editor-analyze(id|spec-name, init-constraint)> (<id>, "", "")
  )

rules // single file analysis

  stx-editor-analyze(|spec-name, init-constraint) =
    stx-editor-analyze(id|spec-name, init-constraint)

  stx-editor-analyze(desugar|spec-name, init-constraint):
      AnalyzeSingle(change*) -> AnalysisResult(result*)
    with
      ast* := <filter((id, ?Added(<id>) + ?Changed(<id>, _)))> change*
    ; result* := <map({ resource, ast, ast', a', error*, warning*, note*:
                        ?(resource, ast)
                      ; ast' := <desugar;stx--index-ast(|resource)> ast
                      ; ( (a', error*, warning*, note*) :=
                              <stx--editor-analyze(desugar|spec-name, init-constraint)> ast'
                        < !(resource, Full(ast', a', error*, warning*, note*))
                        + !(resource, Failed())
                        )
                      })> ast*

  stx-editor-analyze(desugar|spec-name, init-constraint):
      AnalyzeMulti(_, _) -> <fatal-err-msg(|"Single-file `stx-editor-analyze_1_2` called for multi-file analysis. Use `stx-editor-analyze_1_3` instead.")>

  stx--editor-analyze(desugar|spec-name, init-constraint):
      ast -> (a, error*, warning*, note*)
    with spec  := <stx--find-spec(|spec-name)>;
         C     := C(init-constraint, [<stx--explode> ast]);
         level := <stx--log-level>;
         (a, error*, warning*, note*) :=
             <stx--solve-constraint(|spec, level)> ([], C)

rules // single file elaboration

  stx-editor-elaborate(desugar|spec-name, init-constraint):
      AnalyzeSingle(change*) -> AnalysisResult(result*)
    with
      ast* := <filter((id, ?Added(<id>) + ?Changed(<id>, _)))> change*
    ; result* := <map({ resource, ast, ast', ast'', a', error*, warning*, note*:
                        ?(resource, ast)
                      ; ast' := <desugar;stx--index-ast(|resource)> ast
                      ; ( (ast'', a', error*, warning*, note*) :=
                              <stx--evaluate(|spec-name, init-constraint)> [ast']
                        < !(resource, Full(ast'', a', error*, warning*, note*))
                        + !(resource, Failed())
                        )
                      })> ast*

rules // multi file analysis

  stx-editor-analyze(|spec-name, project-constraint, file-constraint) =
    stx-editor-analyze(id|spec-name, project-constraint, file-constraint)

  stx-editor-analyze(desugar|spec-name, project-constraint, file-constraint):
      AnalyzeMulti((project-resource, project-change), change*) -> AnalysisResult(result*)
    with spec  := <stx--find-spec(|spec-name)>
       ; level := <stx--log-level>
    with
      switch !project-change
        case ?Added(_) + ?Changed(_, _):
          global-scope := Scope("", "$")
        ; project-C := C(project-constraint, <map(stx--explode)> [global-scope])
        case ?Cached(ProjectAnalysis(global-scope, project-C, _)):
          id
        otherwise:
          fatal-err(|"Unexpected change on project")
      end
    ; ast* := <filter((id, ?Added(<id>) + ?Changed(<id>, _)))> change*
    ; file-result* := <map({ file-resource, file-ast, file-ast', file-C, file-analysis:
                             ?(file-resource, file-ast)
                           ; file-ast' := <desugar;stx--index-ast(|file-resource)> file-ast
                           ; file-C := C(file-constraint, <map(stx--explode)> [global-scope, file-ast'])
                           ; ( id
                             < !(file-resource, Full(file-ast', FileAnalysis(file-C), [], [], []))
                             + !(file-resource, Failed())
                             )
                           })> ast*
    ; file-C-new* := <map(Snd;?Full(_, FileAnalysis(<id>), _, _, _))> file-result*
    ; file-C-cached* := <filter(?(_, Cached(FileAnalysis(<id>))))> change*
    ; file-C* := [file-C-new*, file-C-cached*]
    ; C := <stx--conj> [project-C|file-C*]
    ; (project-analysis, error*, warning*, note*) := <stx--solve-constraint(|spec, level)> ([], C)
    ; switch !project-change
        case ?Added(project-ast) + ?Changed(project-ast, _):
          project-result := Full(project-ast, ProjectAnalysis(global-scope, project-C, project-analysis), error*, warning*, note*)
        case ?Cached(_):
          project-result := Update(ProjectAnalysis(global-scope, project-C, project-analysis), error*, warning*, note*)
      end
    ; result* := [(project-resource, project-result)|file-result*]

  stx-editor-analyze(desugar|spec-name, init-constraint):
      AnalyzeSingle(_) -> <fatal-err-msg(|"Multi-file `stx-editor-analyze_1_3` called for single-file analysis. Use `stx-editor-analyze_1_2` instead.")>

rules

  stx-evaluate(|spec-name, constraint): in* -> out
    where (out, a, [], _, _) := <stx--evaluate(|spec-name, constraint)> in*

  stx--evaluate(|spec-name, constraint):
      in* -> (out, a, error*, warning*, note*)
    with spec  := <stx--find-spec(|spec-name)>
       ; T*    := <map(stx--explode)> in*
       ; V     := Var("out")
       ; C     := C(constraint, [T*, V])
       ; level := <stx--log-level>
       ; (a, error*, warning*, note*) := <stx--solve-constraint(|spec, level)> ([V], C)
       ; out := <substitute(stx--is-var);stx--implode> (a, V)

rules

  stx--log-level = stx--is-debug-custom-enabled < !"Info" + !"None"

  stx--find-spec(|name) =
    language-components;
    getfirst({ loc, spec-file:
               ?(_, _, _, loc);
               spec-file := $[[loc]/src-gen/statix/[name].spec.aterm];
               <file-exists> spec-file;
               <ReadFromFile> spec-file
            })

  // solve-constraint(|Spec, LogLevel) : ([Var], Constraint) -> (SolveResult, [Error], [Warning], [Note])
  stx--solve-constraint(|spec, level) = prim("STX_solve_constraint", spec, level)

rules

  stx-index-ast(|source) =
    stx--index-ast(|source)

  stx--index-ast(|source) =
    prim("SG_index_ast", source)

  stx--is-debug-custom-enabled =
    prim("SG_is_debug_custom_enabled")

rules

  stx-editor-resolve:
      (node, position, ast, path, project-path) -> <fail>

  stx-editor-hover:
      (node, position, ast, path, project-path) -> <fail>

signature
  constructors
    Op    : String * List(Term) -> Term
    Tuple : List(Term)          -> Term
    List  : List(Term)          -> Term
    Str   : String              -> Term
    Int   : String              -> Term
    Var   : String              -> Term

rules

  stx--is-var = ?Var(_)


  stx--explode: t*{a*} -> List(<map(stx--explode)> t*){a*}
    where is-list

  stx--explode: ""#(t*){a*} -> Tuple(<map(stx--explode)> t*){a*}
    where is-tuple

  stx--explode: t{a*} -> Str(t){a*}
    where is-string

  stx--explode: t{a*} -> Int(<int-to-string> t){a*}
    where is-int

  stx--explode: c#(t*){a*} -> Op(c, <map(stx--explode)> t*){a*}
    where not(is-list + is-tuple + is-string + is-int)


  stx--implode: List(t*){a*} -> t{a*}
    with t := <map(stx--implode)> t*

  stx--implode: Tuple(t*){a*} -> t{a*}
    with t := <map(stx--implode);ListToTuple> t*

  stx--implode: Str(s){a*} -> t{a*}
    with t := s

  stx--implode: Int(i){a*} -> t{a*}
    with t := <string-to-int> i

  stx--implode: Op(c, t*){a*} -> t{a*}
    with t := c#(<map(stx--implode)> t*)

  stx--implode: _ -> <id>
    with warn(|"Cannot implode internal term representation")


  stx--conj: [C|C*] -> CConj(C, <stx--conj> C*)
  stx--conj: [C] -> C
  stx--conj: [] -> CTrue()

rules

  prettyprint-Statix-Int =
    ![S(<is-int;int-to-string>)]
