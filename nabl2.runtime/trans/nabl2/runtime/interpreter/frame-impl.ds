module nabl2/runtime/interpreter/frame-impl

imports
  nabl2/runtime/interpreter/frame-api
  nabl2/runtime/interpreter/util

signature
  constructors
    Addr : Frame * Occurrence -> Addr
  
  sort aliases
    Slots = Map(Occurrence, Val)
  
  constructors
    FC_ : Scope * Map(Label, Map(Scope, Frame)) * Map(Label, Map(Occurrence, Frame)) * Slots -> Frame
    
  constructors
    F_ : Int -> Frame
    H_ : Map(Frame, Frame) -> Heap

  arrows
    newframe(Scope) :: H --> Frame :: H
    newframe(Scope, Slots) :: H --> Frame :: H
    H |- linksOfF(Frame) --> Map(Label, Map(Scope, Frame))
    H |- importsOfF(Frame) --> Map(Label, Map(Occurrence, Frame))
    H |- slotsOfF(Frame) --> Slots
    F |- _lookup(Path) --> Addr
    getScopeOfFirstElem(Path) --> Scope

rules
  initHeap(_) --> H_({})

  frame(s, links) --> links(newframe(s), links)

  frame(s, links, slots) --> links(newframe(s, slots), links)

  framed(ast, links) --> frame(scopeOfTerm(ast), links)
  
  frame(ast, links, slots) --> frame(scopeOfTerm(ast), links, slots)
  
  newframe(s) --> newframe(s, DefaultSlots(declsOf(s)))
  
  newframe(s, slots) :: H H_(x) --> F :: H H_({F |--> FC_(s, {}, {}, slots), x})
  where
    F_(fresh) => F
  
  links(F, []) --> F
  
  links(F, [l|ls]) --> links(F, ls)
  where
    link(F, l) --> _ 
 
  link(F, L(l, F_to)) :: H H_(x) --> F :: H H_({F |--> FC_(s, {l |--> {s_to |--> F_to}, lks}, imps, slots), x})
  where
    x[F] => FC_(s, lks, imps, slots);
    scopeOf(F_to) --> s_to
  
  link(F, L(l, occ, F_to)) :: H H_(x) --> F :: H H_({F |--> FC_(s, lks, {l |--> {occ |--> F_to}, imps}, slots), x})
  where
    x[F] => FC_(s, lks, imps, slots)
 
  H H_(x) |- scopeOf(f) --> s
  where
    x[f] => FC_(s, _, _, _)
  
  lookup(ref) --> _lookup(pathOf(ref))
  
  F |- _lookup([D(_, d)]) --> Addr(F, d)

  H, F1 |- _lookup([E(_, l)|p]) --> addr
  where
    getScopeOfFirstElem(p) --> s';
    H |- linksOfF(F1) --> lks;
    lks[l][s'] => F2;
    H, F2 |- _lookup(p) --> addr
  
  H, F1 |- _lookup([N(_, l, o, _) | p]) --> addr
  where
    H |- importsOfF(F1) --> imps;
    imps[l][o] => F2;
    H, F2 |- _lookup(p) --> addr
    
 getScopeOfFirstElem([D(s, _)|_]) --> s
 getScopeOfFirstElem([E(s, _)|_]) --> s
 getScopeOfFirstElem([N(s, _, _, _)|_]) --> s

 
  H h |- get(Addr(F, d)) --> slots[d]
  where
    H h |- slotsOfF(F) --> slots

  set(Addr(F, d), v) :: H H_(x) --> v :: H H_({F |--> FC_(s, lks, imps, {d |--> v, slots}), x})
  where
    x[F] => FC_(s, lks, imps, slots)
  
rules
  
  H H_(x) |- linksOfF(F) --> lks
  where
    x[F] => FC_(_, lks, _, _)
  
  H H_(x) |- importsOfF(F) --> imps
  where
    x[F] => FC_(_, _, imps, _)
  
  H H_(x) |- slotsOfF(F) --> slots
  where
    x[F] => FC_(_, _, _, slots)
  
signature
  
  arrows
    DefaultSlots(List(Occurrence)) --> Map(Occurrence, Val)

rules // Utility function

  DefaultSlots([]) --> {}

  DefaultSlots([d|ds]) --> { d |--> v, slots }
  where
    typeOf(d) --> t;
    default(t) --> v;
    DefaultSlots(ds) --> slots

 
