resolve {s e T e1 e2}

	new s, typeOf(s, Let([
		Bind("b", BOOL(), True()),
		Bind("f", FUN([FLOAT(), INT(), INT()], INT()), Fun([
			Param("a", FLOAT()),
			Param("b", INT()),
			Param("c", INT())
		], Var("c")))
	], Call("f", [e, Zero(), Zero()]))) == T

//	new s, typeOf(s, Let([
//		Bind("b", BOOL(), True()),
//		Bind("f", FUN([BOOL(), INT(), BOOL()], BOOL()), Fun([
//			Param("a", BOOL()),
//			Param("b", INT()),
//			Param("c", BOOL())
//		], Var("a")))
//	], Plus(e2, e))) == T

//	new s, typeOf(s, Let([
//		Bind("b", BOOL(), True()),
//		Bind("f", FUN([BOOL(), INT(), BOOL()], BOOL()), Fun([
//			Param("a", BOOL()),
//			Param("b", INT()),
//			Param("c", BOOL())
//		], Var("a")))
//	], e)) == BOOL()
	

//	new s, typeOf(s, Let([
//		Bind("b", BOOL(), True())
//	], e)) == T
	
//	new s, typeOf(s, Let([
//		Bind("b", BOOL(), True()),
//		e,
//		Bind("f", FUN([BOOL(), INT()], BOOL()), Fun([
//			Param("a", BOOL()),
//			Param("b", INT())
//		], Var("a")))
//	], Plus(Var("i"), Zero()))) == T

signature

	sorts ID = string                         	// $x$

	sorts Exp constructors						// $e$ :=
		Zero : Exp								//      | 0
		True : Exp								// 		| true
		ZeroFloat : Exp							//		| 0.0
		OneFloat : Exp							//		| 1.0
		And  : Exp * Exp -> Exp					//		| $e$ && $e$
		Plus : Exp * Exp -> Exp			      	//		| $e$ + $e$
		Let  : list(Bind) * Exp -> Exp   		//      | let $b*$ in $e$
		Var  : ID -> Exp						//		| $x$
        Fun  : list(Param) * Exp -> Exp         //      | fun ($x$ : $T$) { $e$ }
//        App  : Exp * list(Exp) -> Exp           //      | $e$($e*$)
        Call : ID * list(Exp) -> Exp            //      | $x$($e*$)
        Coerce : Exp * Type -> Exp

	sorts Param constructors      				// $p$ :=
		Param : ID * Type -> Param				// 		| $x$ : $T$
		
		
  	sorts Bind constructors                   	// $b$ :=
    	Bind : ID * Type * Exp -> Bind   		//      | $x$ : $T$ = $e$
		
	sorts Type constructors
		BOOL : Type
		INT  : Type
		FLOAT: Type
    	UNIT : Type
    	FUN  : list(Type) * Type -> Type

  	relations
    	typeOfDecl : occurrence -> Type

  	namespaces
    	Var  : string

  	name-resolution
    	labels P
    	resolve Var filter P* min $ < P
    	
rules

    typeOf : scope * Exp -> Type

	subtype : Type * Type
	subtype(INT(), FLOAT()).
	subtype(INT(), INT()).
	subtype(FLOAT(), FLOAT()).
	

  	typeOf(_, True()) = BOOL().
  	
  	typeOf(_, Zero()) = INT().
  	
  	typeOf(_, ZeroFloat()) = FLOAT().
  	
//  	typeOf(_, OneFloat()) = FLOAT().
  	
  	typeOf(s, And(x, y)) = BOOL() :-
  		typeOf(s, x) == BOOL(),
  		typeOf(s, y) == BOOL().
  		
	typeOf(s, Plus(x, y)) = INT() :-
		typeOf(s, x) == INT(),
		typeOf(s, y) == INT().
	
  	typeOf(s, Let(binds, e)) = T :- {s_let}
    	new s_let, s_let -P-> s,
    	bindsOk(s, binds, s_let),
    	typeOf(s_let, e) == T,
    	binds != []. // additive
    	
  	typeOf(s, Var(x)) = T :- {p d}
    	typeOfDecl of Var{x@x} in s |-> [(p, (d, T))].
    
  	typeOf(s, Fun(params, e)) = FUN(PT, T) :- {s_fun}
    	new s_fun, s_fun -P-> s,
    	typeOfParams(s, params, s_fun) == PT,
    	typeOf(s_fun, e) == T.

//	typeOf(s, App(e, es)) = T :- {PT AT}
//		typeOf(s, e) == FUN(PT, T),
//		typesOf(s, es) == AT,
//		AT == PT.

	typeOf(s, Coerce(e, T)) = T :- {T2}
		typeOf(s, e) == T2.

	typeOf(s, Call(x, es)) = T :- {FT PT AT p d}
		typeOfDecl of Var{x@x} in s |-> [(p, (d, FT))],
		FT == FUN(PT, T),
		typesOk(s, es, PT).
		
	typesOk : scope * list(Exp) * list(Type)
	typesOk(s, [], []).
	typesOk(s, [e|es], [t|ts]) :- subtype(typeOf(s, e), t), typesOk(s, es, ts).
		
	typesOf maps typeOf(*, list(*)) = list(*)

  	bindOk : scope * Bind * scope

  	bindOk(s, Bind(x, T, e), s_bnd) :-
	    s_bnd -> Var{x@x} with typeOfDecl T,
    	typeOf(s, e) == T.

  	bindsOk maps bindOk(*, list(*), *)
  	
  	
  	typeOfParam : scope * Param * scope -> Type
  	
  	typeOfParam(s, Param(x, T), s_fun) = T :-
  		s_fun -> Var{x@x} with typeOfDecl T.
  		
  	typeOfParams maps typeOfParam(*, list(*), *) = list(*)

