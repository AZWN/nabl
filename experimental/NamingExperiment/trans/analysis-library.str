module analysis-library

imports
  libstratego-lib
  lib/editor-common.generated

signature constructors

  // Index elements:
  Def     : List(UriPart) -> Summary
  Use     : List(UriPart) * List(UriPart) -> Summary
  BadUse  : List(UriPart) -> Summary
  DefData : List(UriPart) * DefDataType * Term -> Summary
  Read    : List(UriPart) -> Summary

  // TODO: add a new constructor for URI header/path separation?
  
  // URI header:
  Namespace      : UriPart
  Unresolved     : Namespace -> UriPart
  INTERNAL_ERROR : UriPart
  
  // Remainder of URI:
  String : UriPart
  Anon   : Int -> UriPart
  Anon   : UriPart

rules // extension points
  
  // Should return list of Def(_) and/or [namespace | path]
  adjust-index-lookup(is-use |namespace, path, name) = fail
  
  // adjust-index-select(|namespace, path, use) = fail // (e.g., for imports)
  
  // Should call <store-results> on a (list of) DefData 
  adjust-index-def-data(store-results |namespace, path) = fail
  
  // Should return a path
  adjust-index-path(is-def |namespace, path) = fail
  
  // adjust-index-path-from-filesystem(|project-path, path)

rules // analysis traversals
   
  analyze-top:
    (ast, path, project-path) -> (ast5, defs, uses, data', added, removed)
    with
      // Init
      full-path := $[[project-path]/[path]];
      prim("LANG_index_setup", "NamingExperiment", [project-path])
    with 
      // Store copy of defs for diff and clear file
      olddefs := <filter(?Def(_))> <index-get-all-in-file> full-path;
      prim("LANG_index_clear_file", full-path)
    with
      {| ReadSet:
        readSet := <new-iset>;
        rules(ReadSet: _ -> readSet);
      
        // Add Unresolved annotations, record globals 
        (Some(ast2), defs) := <analyze-defs(|Anon(), Anon())> Some(ast); // HACK: force origin tracking with Some()... // TODO: still needed?
        <index-add-all(|full-path)> defs;
        
        // Find DefData
        ast3 := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast2;
        data := <origin-track-forced(analyze-tree-data)> ast3;
        <index-add-all(|full-path)> data;
        
        // Resolve an references in DefData (using what we just stored)
        (data', data-uses) := <analyze-uses> data;
        <index-remove-all(|full-path)> data;
        <index-add-all(|full-path)> data';
        
        // Resolve all unresolved references in the tree
        (ast4, uses) := <analyze-uses> ast3;
        <index-add-all(|full-path)> uses;
        ast5         := <prim("SSL_EXT_clone_and_set_parents", <id>)> ast4;
        
        // Store reads
        if not(<is-test-input> (ast, path)) then
          <index-add-all(|full-path)> <iset-elements> readSet
        end
      |}
    with
      // Find removed and added definitions
      (added, removed) := <analyze-diff> (olddefs, defs)
    with
      // Schedule re-analysis of files that have a use of a removed def
      <map(debug(!"Re-analyzing "); prim("SSL_EXT_queue_analysis"))> <analyze-changed(index-get-uses-all|full-path)> removed;
      // Schedule re-analysis of files that have a read of an added def
      <map(debug(!"Re-analyzing "); prim("SSL_EXT_queue_analysis"))> <analyze-changed(index-get-reads-all|full-path)> added
      
  analyze-diff: 
    (defs1, defs2) -> (added, removed)
    with
      added := <diff(analyze-diff-eq)> (defs2, defs1);
      removed := <diff(analyze-diff-eq)> (defs1, defs2)
  
  // Compensate for changing anonymous namespace names.
  analyze-diff-eq = ?(Def(u1), Def(u2)); (<eq> (u1, u2) <+ <eq> (<remove-all(?Anon(_))> u1, <remove-all(?Anon(_))> u2))
  
  // Tests if the current file is just a testing language input
  is-test-input:
    (ast, path) -> (ast, path)
    where
      <string-ends-with(|".spt")> path;
      not(prim("SSL_EXT_origin_language", ast) => "Spoofax-Testing")
  
  analyze-changed(get-all|currentFile):
    defs -> filenames
    where uses := <mapconcat(get-all)> defs
    where filenames := <make-set> <remove-all(?currentFile)> <mapconcat(index-get-file-of)> uses
  
  /**
   * Identifies all definitions in the tree
   * and annotates them with their URI.
   * Also annotates uses with a preliminary "Unresolved(_)" URI.
   */
  analyze-defs(|head-scope, head-scope-ns):
    ast -> (ast', defs')
    with
      if def := <nam-get-definition> ast then
        Def(def-path)                     := def;
        [head-scope-ns', head-scope' | _] := def-path
      else
        def-path       := INTERNAL_ERROR();
        head-scope-ns' := head-scope-ns;
        head-scope'    := head-scope
      end;
      if scope-types := <nam-get-scope-types> ast then
        {| IndexPath:
          <list-loop(update-index-path(|head-scope', head-scope-ns', ast))> scope-types;
          // <balanced-update-path> head-scope';
          (ast', defs) := <analyze-defs-recurse(|Anon(), Anon(), def-path)> ast
        |}
      else
        (ast', defs) := <analyze-defs-recurse(|head-scope', head-scope-ns', def-path)> ast
      end;
      defs' := <![def | defs] <+ !defs>
  
  analyze-defs-recurse(|head-scope, head-scope-ns, def-path):
    ast -> (ast'', defs)
    where
      analyzed      := <all(analyze-defs(|head-scope, head-scope-ns))> ast;
      (ast', defs)  := <unzip-analyzed> analyzed;
      ast''         := <try(nam-annotate-names(|def-path))> ast'
  
  update-index-path(|head-scope, head-scope-ns, ast):
    scope-type -> scope-type
    where
      if !head-scope-ns => Anon() then
        path  := <IndexPath <+ ![]> scope-type;
        path' := <do-adjusted-index-path(|scope-type, path, Anon(<new>))> ast
      else
        path  := <IndexPath <+ ![]> head-scope-ns;
        path' := <do-adjusted-index-path(|scope-type, path, head-scope)> ast
      end;
      rules(IndexPath: scope-type -> path')
  
  /* TODO: consider using simple-update-def-path
   *       which uses "balanced" path scopes
   *       e.g. when Entity doesn't scope Function
   *       then it's hard to access properties from a function
  balanced-update-index-path:
    head-scope -> head-scope
    where
      if !head-scope => Anon() then
        head-scope' := Anon(<new>)
      else
        head-scope' := head-scope
      end;
      (something with do-adjust-path)
      rules(IndexPath := [head-scope' | <IndexPath <+ ![]> ()])
  */
  
  /**
   * Analyze all uses, changing their preliminary
   * "Unresolve(_)" URI to a definite URI of their definition. 
   */
  analyze-uses = analyze-uses(|None())
  analyze-uses(|parent):
    ast -> (ast'', uses')
    with
      analyzed     := <all(analyze-uses(|ast))> ast;
      (ast', uses) := <unzip-analyzed> analyzed;
      if !ast' => _{unresolved@[Unresolved(namespace), x | path]} then
        if Def(path') := <index-lookup(id |namespace, path, "")> ast' then // TODO: Change ""
          ast'' := ast{path'};
          if key{keyUri} := <nam-get-definition-key> parent ; not(<eq>(key, ast')) then
            uses' := [Use(path', keyUri) | uses]
          else
            uses' := [Use(path', [namespace | path]) | uses]
          end
        else
          ast'' := ast';
          uses' := [BadUse([namespace, x]) | uses]
        end
      else
        ast'' := ast';
        uses' := uses
      end
  
  /**
   * Collects all index data (e.g., types of definitions).
   */
  analyze-tree-data:
    tree -> data
    where
      set := <new-iset>;
      <topdown(analyze-tree-data-part(|set))> tree;
      data := <iset-elements> set
  
  analyze-tree-data-part(|set):
    tree -> tree
    where
      if def-term := <nam-get-definition-key> then
        _{[namespace | path]} := def-term;
        if result := <adjust-index-def-data(store-index-data-results(|set) |namespace, path)> tree then
          <fatal-err(|"Unexpected result from adjust-index-def-data; should call <store-results>")> result
        end
      end
  
  store-index-data-results(|set):
    t -> <fail>
    where
      if is-list then
        <iset-addlist(|t)> set
      else
        <iset-add(|t)> set
      end
  
  /**
   * Transforms a term C( (a1, [b1]), (a2, [b2, b3]) )
   * to a tuple (C(a1, a2), [b1, b2, b3]).
   */
  unzip-analyzed:
    appl -> (appl', unzipped-parts)
    with
      appl'          := <all(\(a, _) -> a\)> appl;
      unzipped-parts := <concat> <get-appl-arguments(\(_, b) -> b\) <+ map(\(_, b) -> b\) <+ ![]> appl

rules // index construction
    
  index-add-all(|file) =
    list-loop(with(prim("LANG_index_add", <id>, file)))
    
  index-remove-all(|file) =
    list-loop(with(prim("LANG_index_remove", <id>, file)))
    
  index-clear = prim("LANG_index_clear_all")

rules // index API
  
  index-get-data(|kind):
    <with(?Def(uri) | "Def expected")> -> data
    where
      <index-get(|uri)> DefData(uri, kind, []) => [DefData(_, _, data) | _]
  
  index-get-data-all(|kind):
    <with(?Def(uri) | "Def expected")> -> datas'
    where
      datas  := <index-get(|uri)> DefData(uri, kind, []);
      datas' := <map(\DefData(_, _, d) -> d\)> datas
      
  index-get-uses-all:
    <with(?Def(uri) | "Def expected")> -> uses
    where
      uses := <index-get(|uri)> Use(uri, [])
      
  index-get-reads-all:
    <with(?Def(uri) | "Def expected")> -> reads
    where
      reads := <index-get(|uri)> Read(uri)
 
  index-get-all-in-file = prim("LANG_index_get_all_in_file", <id>)
  
  index-get-all-filenames = prim("LANG_index_all_filenames")
  
  index-get-file-of = prim("LANG_index_get_file_of", <id>)
  
  index-get(|uri):
    template -> <prim("LANG_index_get", template)>
      with
       if set := <ReadSet> then
         <iset-add(|Read(uri))> set
       end
      
  index-get-children(|template, name):
    x -> childs'
      with
        childs := <prim("LANG_index_get_children", template)> x;
        
        // Take inner name when name is a COMPLETION term.
        (
          COMPLETION(name') := name 
        <+ 
          name' := name
        );
        
        // Get namespace and URI.
        Def([namespace | uri]) := template;
        
        if "" := name' then
          childs' := childs;
          store := [namespace, <strip-annos> x | uri]
        else
          // Filter out unnecessary results using substring filter on name.
          childs' := <filter(index-substring-filter(|name'))> childs;
          store := [namespace, name' | uri]
      end;
      
      // Store read in index.
       if set := <ReadSet> then
         <iset-add(|Read(store))> set
       end
       
  index-substring-filter(|name):
    Def([_, n | _]) -> <id>
    where <is-substring(!name)> n
    
  index-uri:
    x{[namespace | path]} -> [<index-namespace-unwrap> namespace | path]
    
  index-namespace:
    x{[namespace | path]} -> <index-namespace-unwrap> namespace

  index-path:
    x{[namespace | path]} -> path'
    where
      if !namespace => Unresolved(namespace) then
        Def(path') := <index-lookup> 
      else
        path' := path
      end

  index-lookup:
    x{[namespace | path]} -> <index-lookup(id |<index-namespace-unwrap> namespace, path, "")>

  index-lookup-all:
    x{[namespace | path]} -> <index-lookup-all(id |<index-namespace-unwrap> namespace, path, "")>

  index-lookup(is-adjust-lookup-enabled |namespace, path, name):
    x -> def
    where
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, name)>;
      def        := <index-select(|namespace, path, x)>
    <+
      // TODO: optimize: try not to call do-adjust-index-lookup from here
      [_ | path'] := path;
      def         := <index-lookup(is-adjust-lookup-enabled |namespace, path', name)> x

  index-lookup-all(is-adjust-lookup-enabled |namespace, path, name):
    x -> defs'
    where
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, name)>;
      defs       := <index-select-all(|namespace, path, x)>;
      // TODO: optimize: try not to call do-adjust-index-lookup from here
      if [_ | path'] := path then
        defs2 := <index-lookup-all(is-adjust-lookup-enabled |namespace, path', name)> x;
        defs' := <conc> (defs, defs2)
      else
        defs' := defs
      end

  index-lookup-outermost(|name):
    x{[namespace | path]} -> <index-lookup-outermost(id |<index-namespace-unwrap> namespace, path, name)>

  index-lookup-outermost(is-adjust-lookup-enabled |namespace, path, name):
    x -> def
    where
      // TODO: optimize: just like index-lookup
      [_ | path'] := path;
      def         := <index-lookup-outermost(is-adjust-lookup-enabled |namespace, path', name)> x
    <+
      candidates := <index-lookup-one-level(is-adjust-lookup-enabled|namespace, path, name)>;
      def        := <index-select(|namespace, path, x)>

  index-lookup-one-level(|name):
    x{[namespace | path]} -> <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, name)>
  
  index-lookup-one-level(is-adjusted-lookup-enabled |namespace, path, name):
    x -> defs
    with
      is-adjusted-lookup-enabled;
      do-adjusted-index-lookup(|namespace, path, x, name);
      mapconcat(\d@Def(p) -> [d]\
          <+ \[namespace' | path'] -> <index-lookup-one-level(fail |namespace', path', name)> x\
          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a Def(_) or [namespace | path]"));
      ?defs
    <+
      defs := <index-get-children(|Def([namespace | path]), name)>

  index-lookup-all-levels(|name):
    x{[namespace | path]} -> <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, name)>
  
  index-lookup-all-levels(is-adjust-lookup-enabled |namespace, path, name):
    x -> all-defs
    with
      is-adjust-lookup-enabled;
      do-adjusted-index-lookup(|namespace, path, x, name);
      mapconcat(\d@Def(p) -> [d]\
          <+ \[namespace' | path'] -> <index-lookup-all-levels(fail |namespace', path', name)> x\
          <+ fatal-err(|"Unexpected result from adjust-index-lookup, should be a Def(_) or [namespace | path]"));
      ?all-defs
    <+
      one-level := <index-get-children(|Def([namespace | path]), name)>;
      if [_ | path'] := path then
        all-defs := <concat> [one-level, <index-lookup-all-levels(fail |namespace, path', name)> x]
      else
        all-defs := one-level
      end

  index-lookup-contained(|namespace, name):
    x{[ns | path]} -> defs
    with
      if !ns => Unresolved(_) then
        Def([_ | def-path]) := <index-lookup>;
        defs := <index-lookup-one-level(id|namespace, def-path, name)> x 
      else
        defs := <index-lookup-one-level(id|<index-namespace-unwrap> namespace, path, name)>
      end
      <+ defs := []

  index-lookup-contained-all-levels(|namespace, name):
    x{[ns | path]} -> defs
    with
      if !ns => Unresolved(_) then
        Def([_ | def-path]) := <index-lookup>;
        defs := <index-lookup-all-levels(id|namespace, def-path, name)> x
      else
        defs := <index-lookup-all-levels(id|<index-namespace-unwrap> namespace, path, name)>
      end
      <+ defs := []
  
  index-lookup-container(|namespace):
    x{[ns | path]} -> def
    with
      def := ();
      fatal-err(|"Not implemented") // TODO: index-lookup-container

  index-namespace-unwrap =
    \Unresolved(n) -> n\ <+ id
  
  do-adjusted-index-lookup(|namespace, path, use, name) =
    // UNDONE: try(origin-term);
    repeat-until(
      prim("SSL_EXT_get_parent", <id>)
    , adjust-index-lookup(origin-equal(|use) |namespace, path, name)
    )

  index-select(|namespace, path, use) =
    getfirst(
      where(
        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
      )
    )

  index-select-all(|namespace, path, use) =
    filter(
      where(
        ?Def([_, <SRTS-EXT-eq-ignore-annos(|use)> | _])
      )
    )
  
  index-is-definition =
    where(nam-get-definition-key)
  
  do-adjusted-index-path(|namespace, path, def) =
    adjust-index-path(origin-equal(|def) |namespace, path)
  <+
    ![def | path]
  
  index-eq(|namespace, expected) =
    where(
      ?Def([_, name | _]);
      <SRTS-EXT-eq-ignore-annos(|expected)> name
    )
  
  external SRTS-EXT-eq-ignore-annos(|t)

rules // interface for generated code
  
  nam-get-def(|namespace):
    x -> Def([namespace, x | <IndexPath <+ ![]> namespace])
    
  nam-annotate-use(|namespace):
    t -> t{[Unresolved(namespace), t | <IndexPath <+ ![]> namespace]}
    
  nam-get-scope-types = fail
  nam-get-definition = fail
  nam-get-definition-key = fail
  nam-annotate-names(|def-path) = fail
