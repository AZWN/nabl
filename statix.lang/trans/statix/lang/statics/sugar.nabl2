module statix/lang/statics/sugar

imports

  signatures/statix/lang/-

rules

/******************************************************************
 * User Constraints                                               *
 ******************************************************************/

  [[ CDeriveMap(x, x', lifts) ^ (s) ]] :=
    C{x'} -> s, C{x'} |-> d, @x'.decl := d,
    d : ty, ty != FUN(_, _) | error "Use `c maps c(...) = ...` for functional constraints." @x,
    d.ind := ind,

    tys is `in-types` of ty,
    lifts <`lifts-some`? () | error "At least one argument must be lifted.",
    tys' is `lift-types` of (lifts, tys),

    C{x} <- s, @x.decl := C{x},
    C{x} : PRED(tys') !!,
    C{x}.ind := ind !!,
    C{x}.kind := DerivedC() !!.

  [[ FDeriveMap(x, x', inlifts, outlift) ^ (s) ]] :=
    C{x'} -> s, C{x'} |-> d, @x'.decl := d,
    d : ty, ty != PRED(_) | error "Use `c maps c(...)` for non-functional constraints." @x,
    d.ind := ind,

    intys is `in-types` of ty,
    outtys is `out-types` of ty,
    inlifts <`lifts-some`? () | error "At least one input argument must be lifted.",
    outlifts is `lift-to-lifts` of outlift,
    intys' is `lift-types` of (inlifts, intys),
    outtys' is `lift-types` of (outlifts, outtys),

    C{x} <- s, @x.decl := C{x},
    C{x} : FUN(intys', outtys') !!,
    C{x}.ind := ind !!,
    C{x}.kind := DerivedC() !!.

  RuleHead[[ F(x, inargs, outarg) ^ (s_rule, s_body, y) ]] := x == y,
    C{x} -> s_rule, C{x} |-> d, @x.decl := d,
    d.kind := DeclaredC() | error "Rules can only be defined for declared constraints.",
    d : ty, ty != PRED(_) | error "Use `c(...) | ...` for non-functional constraints." @x,
    intys is `in-types` of ty,
    outty is `out-type` of ty,
    Map1T(Match)[[ inargs ^ (s_rule) : intys ]],
    Match[[ outarg ^ (s_rule) : outty ]].

  Term(V)[[ COp(x, args) ^ (s) : outty ]] :=
    C{x} -> s, C{x} |-> d, @x.decl := d,
    d : ty, ty != PRED(_) | error "Inline notation can only be used for functional constraints.",
    intys is `in-types` of ty,
    outty is `out-type` of ty,
    Map1T(Term(V))[[ args ^ (s) : intys ]].

  [[ LC(x) ^ (s) : ty ]] :=
    C{x} -> s, C{x} |-> d, @x.decl := d,
    d : ty.


/******************************************************************
 * Base Constraints                                               *
 ******************************************************************/

  [[ LTrue() ^ (_) : PRED(_) ]].

  [[ LFalse() ^ (_) : PRED(_) ]].

  Term(V)[[ NewOp() ^ (s) : SCOPE() ]].

  Term(V)[[ TermIdOp(t) ^ (s) : TERM_ID() ]] :=
    Term(V)[[ t ^ (s) : _ ]].


/******************************************************************
 * Relations                                                      *
 ******************************************************************/

  [[ CAskRel(rel, ts, st) ^ (s) ]] :=
    LabelRef[[ rel ^ (s) : DATA(ty) ]], ty != FUN(_, _) | error "Use inline notation for functional relations.",
    tys is `inout-types` of ty,
    Map1T(Build)[[ ts ^ (s): tys ]],
    Build[[ st ^ (s) : SCOPE() ]].

  Term(V)[[ AskRelOp(rel, ts, st) ^ (s) : outty ]] :=
    LabelRef[[ rel ^ (s) : DATA(ty) ]], ty != PRED(_) | error "Use predicate notation for non-functional relations.",
    intys is `in-types` of ty,
    outty is `out-type` of ty,
    Map1T(Term(V))[[ ts ^ (s) : intys ]],
    Term(V)[[ st ^ (s) : SCOPE() ]].


/******************************************************************
 * Scope Graph                                                    *
 ******************************************************************/
 
  [[ NamespaceQuery(x, filter, min) ^ (s) ]] :=
    Ns{x} -> s, Ns{x} |-> d, @x.decl := d,
    NsQ{x} <- s,
    [[ filter ^ (s, NsQ{x}) ]],
    [[ min ^ (s, NsQ{x}) ]].

  [[ NamespaceFilter(re) ^ (s, d) ]] :=
    d.wf := re,
    LabelRE[[ re ^ (s) : EDGE() ]].

  [[ NamespaceMin(prs) ^ (s,d ) ]] :=
    d.ord := prs,
    Map1(EdgeLabelPair)[[ prs ^ (s) ]].

  EdgeLabelPair[[ LabelPair(lbl1, lbl2) ^ (s) ]] :=
    LabelRef[[ lbl1 ^ (s) : EDGE() ]],
    LabelRef[[ lbl2 ^ (s) : EDGE() ]].

  LabelRef[[ t@Decl() ^ (s) : ty ]] :=
    Lbl{t} -> s, Lbl{t} |-> d, @t.decl := d,
    d : ty.

  LabelRef[[ t@EOP() ^ (s) : ty ]] :=
    Lbl{EOP()} -> s, Lbl{EOP()} |-> d, @t.decl := d,
    d : ty.


  RE(L)[[ l@Decl() ^ (s) : ty ]] :=
    L[[ l ^ (s) : ty ]].

  RE(L)[[ l@EOP() ^ (s) : ty ]] :=
    L[[ l ^ (s) : ty ]].


  Term(V)[[ PathSrcOp(t) ^ (s) : SCOPE() ]] :=
    Term(V)[[ t ^ (s) : PATH() ]].
  Term(V)[[ PathScopesOp(t) ^ (s) : LIST(SCOPE()) ]] :=
    Term(V)[[ t ^ (s) : PATH() ]].
  Term(V)[[ PathLabelsOp(t) ^ (s) : LIST(LABEL()) ]] :=
    Term(V)[[ t ^ (s) : PATH() ]].
  Term(V)[[ PathDstOp(t) ^ (s) : SCOPE() ]] :=
    Term(V)[[ t ^ (s) : PATH() ]].

  [[ LPathMatch(re) ^ (s) : PRED([LIST(LABEL())]) ]] :=
    LabelRE[[ re ^ (s) : EDGE() ]].

  [[ LPathLt(ord) ^ (s) : PRED([LABEL(), LABEL()]) ]] :=
    LabelOrd[[ ord ^ (s) ]].


/******************************************************************
 * Resolve & Query
 ******************************************************************/

  RE(L)[[ t@ResolveMatch(r@Occurrence(ns, _, _), rel) ^ (s) : DATA(ty) ]] :=
    Build[[ r ^ (s) : OCCURRENCE() ]],
    NsQ{ns} -> s, NsQ{ns} |-> d, @t.decl := d,
    LabelRef[[ rel ^ (s) : DATA(ty) ]],
    [OCCURRENCE()] is `in-types` of ty.

  LabelOrd[[ t@ResolveLt(r@Occurrence(ns, _, _), rel) ^ (s) ]] :=
    Build[[ r ^ (s) : OCCURRENCE() ]],
    NsQ{ns} -> s, NsQ{ns} |-> d, @t.decl := d,
    LabelRef[[ rel ^ (s) : DATA(ty) ]],
    [OCCURRENCE()] is `in-types` of ty.

  [[ OccurrenceMatch(r) ^ (s) : PRED([OCCURRENCE()]) ]] :=
    Build[[ r ^ (s) : OCCURRENCE() ]].


/******************************************************************
 * Sorts & Constructors                                           *
 ******************************************************************/


/******************************************************************
 * Terms                                                          *
 ******************************************************************/

