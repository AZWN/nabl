module statix/lang/statics/normalize

  /////////////////////////////////////////////////////////////////////
  // Normalization: rewrite rules to normalized forms
  /////////////////////////////////////////////////////////////////////

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  nabl2/api

  signatures/statix/lang/-
  statix/lang/statics/-

rules

  normalize-phase1(|a) =
    explicate-cmaps(|a);
    normalize-functional-heads(|a);
    normalize-inline-patterns(|a);
    normalize-functional-cdecls;
    normalize-functional-cops(|a)

  normalize-phase2(|a) =
    normalize-ho-constraints(|a);
    normalize-wildcards;
    normalize-as-patterns

rules

  explicate-cmaps(|a): Module(x, section*){a*} -> Module(x, section''*){a*}
    with (section'*, maps) := <collect-map(replace-cmap(|a))> section*;
         rule* := <map(cmap-to-rules(|a)); concat> maps;
         section''* := <conc> (section'*, [Rules(rule*)])

  replace-cmap(|a): CDeriveMap(x, _, _) -> CDecl(ind, x, sort)
    with d   := <nabl2-get-ast-property(|a,"decl")> x;
         ind := <nabl2-get-property(|a,"ind")> d;
         sort  := <nabl2-get-type(|a);type-to-sort> d

  cmap-to-rules(|a): (CDeriveMap(x, y, lsort*), _) -> [base-rule, elem-rule]
    with base-rule := <cmap-base-rule> (x, y, lsort*);
         elem-rule := <cmap-elem-rule> (x, y, lsort*)


  cmap-base-rule: (x, y, lsort*) -> Rule(C(x, ps), [], CTrue(), [], CTrue())
    with ps := <map(lift-base)> lsort*

  lift-base: Id() -> Wld()

  lift-base: ToList() -> List([])


  cmap-elem-rule: (x, y, lsort*) -> Rule(C(x, ps), [], CTrue(), [], CConj(call, rec))
    with ps   := <map-with-index(lift-elem-head)> lsort*;
         call := C(y, <map-with-index(lift-elem-call)> lsort*);
         rec  := C(x, <map-with-index(lift-elem-rec)> lsort*)

  lift-elem-head: (i, Id())     -> <lift-var(|"x")> i
  lift-elem-head: (i, ToList()) -> ListTail([<lift-var(|"x")> i], <lift-var(|"xs")> i)

  lift-elem-call: (i, _) -> <lift-var(|"x")> i

  lift-elem-rec: (i, Id())     -> <lift-var(|"x")> i
  lift-elem-rec: (i, ToList()) -> <lift-var(|"xs")> i

  lift-var(|base) = !Var($[[base][<int-to-string>]])

rules

  normalize-functional-heads(|a) = topdown(try(normalize-functional-head(|a)))

  normalize-functional-head(|a): F(x, in_ts, out_t) -> C(x, ts)
    with FUN(intys, outtys) := <nabl2-get-ast-property(|a,"decl");nabl2-get-type(|a)> x;
         if [_] := outtys then
           out_ts := <![<id>]> out_t
         else
           out_ts := <?Tuple(<id>)> out_t
         end;
         ts := <conc> (in_ts, out_ts)

rules

  normalize-inline-patterns(|a) = topdown(try(normalize-inline-pattern(|a)))

  normalize-inline-pattern(|a):
      Rule(C(x, ps), gvs, guard, bvs, body){a*} -> Rule(C(x, ps'), gvs', guard', bvs', body'){a*}
    with ty := <nabl2-get-ast-property(|a,"decl");nabl2-get-type(|a)> x;
         n := <(?PRED(<length>) + ?FUN(<length>, _))> ty;

         // extract inline patterns
         (gps', guard') := <take(|n);extract-inline-patterns(|guard)> ps;
         (bps', body') := <drop(|n);extract-inline-patterns(|body)> ps;

         // compute new head variables
         ps' := <conc> (gps', bps');
         head-var* := <collect-all(?Var(_));raw-make-set> ps';

         // compute new existental guard variables
         guard-var* := <collect-all(?Var(_));raw-make-set> guard';
         new-guard-var* := <raw-diff> (guard-var*, head-var*);
         gvs' := <conc;raw-make-set> (new-guard-var*, gvs);

         // compute new existental body variables
         body-var* := <collect-all(?Var(_));raw-make-set> body';
         new-body-var* := <raw-diff> (body-var*, <conc> (head-var*, gvs'));
         bvs' := <conc;raw-make-set> (new-body-var*, bvs)

  normalize-inline-pattern(|a):
      LLam(ps, vs, body){a*} -> LLam(ps', vs', body'){a*}
    with (ps', body') := <extract-inline-patterns(|body)> ps;
         head-var* := <collect-all(?Var(_));raw-make-set> ps';
         body-var* := <collect-all(?Var(_));raw-make-set> body';
         new-body-var* := <raw-diff> (body-var*, head-var*);
         vs' := <conc;raw-make-set> (new-body-var*, vs)

  extract-inline-patterns(|C): [] -> ([], C)

  extract-inline-patterns(|C): [v|ps] -> ([v|ps'], C')
    where <?Var(_) + ?Wld()> v
    with (ps', C') := <extract-inline-patterns(|C)> ps

  extract-inline-patterns(|C): [p|ps] -> ([v|ps'], CConj(CEqual(v, p'), C'))
    where <?As(v, p')> p
    with (ps', C') := <extract-inline-patterns(|C)> ps

  extract-inline-patterns(|C): [p|ps] -> ([v|ps'], CConj(CEqual(v, p), C'))
    where <not(?Var(_) + ?Wld() + ?As(_, _))> p
    with v := Var(<newname> "p");
         (ps', C') := <extract-inline-patterns(|C)> ps

rules

  normalize-functional-cdecls = topdown(try(normalize-functional-cdecl))

  normalize-functional-cdecl:
      CDecl(ind, x, t@FunType(s1*, s2*)) -> CDecl(ind, x, t')
    with s* := <conc> (s1*, s2*);
         t' := <origin-track-forced(!SimpleType(s*))> t

rules

  normalize-functional-cops(|a) =
    topdown(try(normalize-functional-cop(|a)))

  normalize-functional-cop(|a):
      Rule(head, gvs, guard, bvs, body){a*} -> Rule(head, gvs', guard'', bvs', body''){a*}
    with (guard', gmaps) := <collect-map(replace-cop(|a))> guard;
         guard'' := <map(cop-to-c(|a));list-to-conj(|guard')> gmaps;
         new-gvs := <map(Snd);collect-all(?Var(_))> gmaps;
         gvs' := <conc> (gvs, new-gvs);
         (body', bmaps) := <collect-map(replace-cop(|a))> body;
         body'' := <map(cop-to-c(|a));list-to-conj(|body')> bmaps;
         new-bvs := <map(Snd);collect-all(?Var(_))> bmaps;
         bvs' := <conc> (bvs, new-bvs)

  normalize-functional-cop(|a):
      LLam(ts, vs, body){a*} -> LLam(ts', vs', body''){a*}
    with (ts', tsmaps) := <collect-map(replace-cop(|a))> ts;
         (body', bmaps) := <collect-map(replace-cop(|a))> body;
         maps := <conc> (tsmaps, bmaps);
         body'' := <map(cop-to-c(|a));list-to-conj(|body)> maps;
         new-var* := <map(Snd);collect-all(?Var(_))> maps;
         vs' := <conc> (vs, new-var*)

  normalize-functional-cop(|a):
      CEqual(t1, t2){a*} -> C
    with (t1', maps1) := <collect-map(replace-cop(|a))> t1;
         (t2', maps2) := <collect-map(replace-cop(|a))> t2;
         C := <conc;map(cop-to-c(|a));list-to-conj(|CEqual(t1, t2'){a*})> (maps1, maps2)


  replace-cop(|a): COp(x, in_ts) -> out_t
    with FUN(_, outtys) := <nabl2-get-ast-property(|a,"decl");nabl2-get-type(|a)> x;
         out_ts := <make-vars(|<newname> x)> outtys;
         out_t := <?[<id>] <+ !Tuple(<id>)> out_ts

  cop-to-c(|a): (COp(x, in_ts), out_t) -> C(x, ts)
    with FUN(_, outtys) := <nabl2-get-ast-property(|a,"decl");nabl2-get-type(|a)> x;
         if [_] := outtys then
           out_ts := <![<id>]> out_t
         else
           out_ts := <?Tuple(<id>)> out_t
         end;
         ts := <conc> (in_ts, out_ts)


  replace-cop(|a): NewOp() -> v
    with v := Var(<newname> "new")

  cop-to-c(|a): (NewOp(), v) -> CNew([v])


  replace-cop(|a): PathSrcOp(_) -> v
    with v := Var(<newname> "src")

  cop-to-c(|a): (PathSrcOp(t), v) -> CPathSrc(t, v)


  replace-cop(|a): PathDstOp(_) -> v
    with v := Var(<newname> "dst")

  cop-to-c(|a): (PathDstOp(t), v) -> CPathDst(t, v)


  replace-cop(|a): PathScopesOp(_) -> v
    with v := Var(<newname> "scopes")

  cop-to-c(|a): (PathScopesOp(t), v) -> CPathScopes(t, v)


  replace-cop(|a): PathLabelsOp(_) -> v
    with v := Var(<newname> "labels")

  cop-to-c(|a): (PathLabelsOp(t), v) -> CPathLabels(t, v)


  replace-cop(|a): AskRelOp(rel, in_ts, st) -> out_t
    with FUN(_, outtys) := <nabl2-get-ast-type(|a)> rel;
         out_ts := <make-vars(|<newname> "t")> outtys;
         out_t := <?[<id>] <+ !Tuple(<id>)> out_ts

  cop-to-c(|a): (op@AskRelOp(rel, in_ts, st), out_t) -> c
    with FUN(_, outtys) := <nabl2-get-ast-type(|a)> rel;
         if [_] := outtys then
           out_ts := <![<id>]> out_t
         else
           out_ts := <?Tuple(<id>)> out_t
         end;
         ts := <conc> (in_ts, out_ts);
         c := <with-origin(|op); desugar-rel-shorthand> CAskRel(rel, ts, st)


  list-to-conj(|tl): [] -> tl

  list-to-conj(|tl): [C|Cs] -> CConj(C, <list-to-conj(|tl)> Cs)

rules

  normalize-ho-constraints(|a) =
    topdown(try(replace-ho-constraint(|a)))

  replace-ho-constraint(|a): l@LTrue() -> LLam(ps, [], CTrue())
    with ty := <nabl2-get-ast-type(|a)> l;
         sort := <type-to-sort> ty;
         ps := <sort-args;map(!Wld())> sort

  replace-ho-constraint(|a): l@LFalse() -> LLam(ps, [], CFalse())
    with ty := <nabl2-get-ast-type(|a)> l;
         sort := <type-to-sort> ty;
         ps := <sort-args;map(!Wld())> sort

  replace-ho-constraint(|a): l@LC(x) -> LLam(ps, [], C(x, ps))
    with ty := <nabl2-get-ast-property(|a,"decl");nabl2-get-type(|a)> x;
         sort := <type-to-sort> ty;
         ps := <sort-args;make-vars(|"t")> sort

  replace-ho-constraint(|a): l@LPathMatch(re) -> LLam([p], [], CPathMatch(re, p))
    with p := Var("ls")

  replace-ho-constraint(|a): l@LPathLt(ord) -> LLam([l1, l2], [], CPathLt(ord, l1, l2))
    with l1 := Var("l1");
         l2 := Var("l2")


rules

  normalize-wildcards = topdown(try(normalize-wildcard))

  normalize-wildcard:
      Rule(C(x, ps), gvs, guard, bvs, body){a*} -> Rule(C(x, ps'), gvs', guard', bvs', body'){a*}
    with (ps', _) := <collect-map(replace-wld)> ps
    with (guard', gmaps) := <collect-map(replace-wld)> guard;
         new-gvs := <map(Snd)> gmaps;
         gvs' := <conc> (gvs, new-gvs)
    with (body', bmaps) := <collect-map(replace-wld)> body;
         new-bvs := <map(Snd)> bmaps;
         bvs' := <conc> (bvs, new-bvs)

  replace-wld: Wld() -> Var(<newname> "wld")

rules

  normalize-as-patterns = topdown(try(normalize-as-pattern))

  normalize-as-pattern:
      Rule(C(x, ps), gvs, guard, bvs, body){a*} -> Rule(C(x, ps), gvs, guard'', bvs, body''){a*}
    with (guard', gmaps) := <collect-map(replace-as)> guard;
         guard'' := <map(as-to-constraint);list-to-conj(|guard')> gmaps
    with (body', bmaps) := <collect-map(replace-as)> body;
         body'' := <map(as-to-constraint);list-to-conj(|body')> bmaps

  as-to-constraint: (As(v, t), _) -> CEqual(v, t)

  replace-as: As(v, t) -> v

rules

  make-vars(|x) = ?[_] < ![Var(x)] + map-with-index(\ (i, _) -> Var($[[x][<int-to-string> i]]) \)

rules

  type-to-sort: SORT(d)      -> SimpleSort(<nabl2-get-occurrence-name> d)
  type-to-sort: INT()        -> IntSort()
  type-to-sort: STRING()     -> StringSort()
  type-to-sort: PATH()       -> PathSort()
  type-to-sort: LABEL()      -> LabelSort()
  type-to-sort: OCCURRENCE() -> OccurrenceSort()
  type-to-sort: SCOPE()      -> ScopeSort()
  type-to-sort: LIST(ty)     -> ListSort(<type-to-sort> ty)
  type-to-sort: TUPLE(tys)   -> TupleSort(<map(type-to-sort)> tys)

  type-to-sort: PRED(tys)          -> SimpleType(<map(type-to-sort)> tys)
  type-to-sort: FUN(intys, outtys) -> SimpleType(<map(type-to-sort)> tys)
    with tys := <conc> (intys, outtys)

  sort-args: SimpleType(args) -> args
