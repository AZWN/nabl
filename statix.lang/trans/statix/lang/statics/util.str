module statix/lang/statics/util

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  signatures/statix/lang/-

rules

  is-var    = ?Var(_) + ?As(_, <is-var>)
  is-wld    = ?Wld() + ?As(_, <is-var>)
  is-constr = not(is-var + is-wld)
            ; try(?As(_, <is-constr>))

  all-vars = collect-all(?Var(_))

rules

  keep-origin(s) = origin-track-forced(s)

  with-origin(|t) = ?u; <keep-origin(!u)> t

rules

  unzip3 = ?[(x,y,z)|xyz*] < <unzip3> xyz* => (x*,y*,z*); !([x|x*],[y|y*],[z|z*]) + !([],[],[])
  unzip4 = ?[(x,y,z,a)|xyza*] < <unzip4> xyza* => (x*,y*,z*,a*); !([x|x*],[y|y*],[z|z*],[a|a*]) + !([],[],[],[])

  raw-eq = where((strip-annos, strip-annos); eq)
  raw-union = union(raw-eq)
  raw-elem = elem(raw-eq)
  raw-lookup = raw-lookup-entry;Snd
  raw-lookup-entry = lookup((id,Fst);raw-eq)
  raw-diff = diff(raw-eq) 
  raw-make-set = foldr(![], union(raw-eq), ![<id>]) 

  topdown-om(s) = s <+ all(topdown-om(s))

  partitions(s): [] -> []
  partitions(s): [x|ys] -> [xs|<partitions(s)> ys']
    with
      (xs', ys') := <partition(\ x' -> x' where <s> (x, x') \)> ys
    ; xs := [x|xs']

  // list n of lists m1, ..., mn to list m1 * ... * mn of lists n
  // <list-cart> [ [1,2], ["a","b"], [true,false] ]
  //   => [ [1,"a",true], [1,"a",false]
  //      , [1,"b",true], [1,"b",false]
  //      , [2,"a",true], [2,"a",false]
  //      , [2,"b",true], [2,"b",false]
  //      ]
  list-cart: [] -> []
  list-cart: [xs] -> <map(MkSingleton)> xs
  list-cart: [xs|xss] -> <cart(![<Fst>|<Snd>])> (xs, <list-cart> xss)

  flatmap(s): [] -> []
  flatmap(s): [x|xs] -> <conc> (<s> x, <flatmap(s)> xs)

  // @param key : a -> k
  // @param val : a -> v
  // @type List(a) -> List(k * List(v))
  external group-by(key,val|)

rules

  // collect-map(s: a -> b, guard: a -> a) : x -> (x, [(a * b)])
  // apply bottomup and collect the substitutions that were done

  collect-map(s) = collect-map(s, id)

  collect-map(s, guard): t -> (t'', maps)
    where where(guard); c#(ts){a*} := t
    with (ts', tsmaps) := <map(collect-map(s, guard)); unzip; (id, concat)> ts;
         t' := <with-origin(|t)> c#(ts'){a*};
         (t'', tmaps) := <keep-origin(s) < !(<id>, [(t', <id>)]) + !(<id>, [])> t';
         maps := <conc> (tmaps, tsmaps)

  collect-map(s, guard): t{a*} -> (t{a*}, [])
    where not(guard) + not(c#(_) := t)
