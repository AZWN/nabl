module statix/lang/normalize/queries

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  nabl2/shared/vars
  nabl2/api

  signatures/statix/lang/-
  statix/lang/statics/-
  statix/lang/normalize/util

rules

  // normalize namespace based resolve stand-ins
  // before functional relations

  normalize-resolves(|a) =
    nabl2-custom-analysis-info-msg(|"| Normalize namespace-based queries...");
    bottomup(
      try(normalize-resolve(|a))
    )

  normalize-resolve(|a): t@ResolveMatch(_){a*} -> wf{a*}
    with wf := <norm-get-ast-decl-property(|a, "wf")> t

  normalize-resolve(|a): t@ResolveLt(_){a*} -> ord{a*}
    with ord := <norm-get-ast-decl-property(|a, "ord")> t

  normalize-resolve(|a): OccurrenceMatch(Occurrence(ns, ts, _)){a*} -> lam{a*}
    with NS(tys) := <norm-get-ast-decl-type(|a)> ns;
         us := <make-fresh-vars(|"u")> tys;
         w := <make-wildcard> AST_ID();
         d := <norm-set-ast-type(|OCCURRENCE())> Occurrence(ns, us, w);
         lam := LLam([d], [], CEqual(<build-terms(|tys)> us, <build-terms(|tys)> ts))
  
rules

  // normalize queries
  // before functional relations, before wildcards

  normalize-queries =
    nabl2-custom-analysis-info-msg(|"| Normalize queries...");
    bottomup(
      try(normalize-query)
    ; try(normalize-query-ops)
    )


  normalize-query: CAskRel(rel, ts, st) -> c
    with PRED(tys) := <norm-get-ast-type> rel
       ; c := <ask-rel-query(|tys, [])> (rel, st, ts, [])


  normalize-query-ops =
    normalize-in-rules(replace-functional-relop,id,functional-relop-to-c)

  replace-functional-relop: t@AskRelOp(rel, in_ts, st){a*} -> out_v{a*}
    with ty := <norm-get-ast-type> t
    with out_v := <make-fresh-var(|"t")> ty

  functional-relop-to-c: (AskRelOp(rel, in_ts, st), out_v) -> c
    with FUN(intys, outty) := <norm-get-ast-type> rel
       ; c := <ask-rel-query(|intys, outty)> (rel, st, in_ts, [out_v])


  ask-rel-query(|intys, outty): (rel, st, in_ts, out_ts) -> c // FIXME Create some types here!
    with tys      := <conc> (intys, [outty]);
         inty     := <build-types> intys;
         ty       := <build-types> tys;
         ts       := <conc> (in_ts, out_ts);

         us       := <make-fresh-vars(|"u")> intys;
         eq       := CEqual(<build-terms(|intys)> us, <build-terms(|intys)> in_ts);

         in_v     := <build-terms(|intys)> us;
         match    := <norm-set-ast-type(|PRED([inty]))> LLam([in_v], [], eq);
         filter   := Filter(Epsilon(), match);

         in_wlds  := <make-wildcards> intys;
         in_wld   := <build-terms(|intys)> in_wlds;
         ord      := <norm-set-ast-type(|PRED([inty, inty]))> LLam([in_wld, in_wld], [], CFalse());
         min      := Min([], ord);

         t        := <conc;build-terms(|tys)> (in_wlds, out_ts);
         p_ty     := PATH();
         p        := <make-wildcard> p_ty;
         pt_ty    := TUPLE([p_ty, ty]);
         pt       := <norm-set-ast-type(|pt_ty)> Tuple([p, t]);
         pts      := <norm-set-ast-type(|LIST(pt_ty))> List([pt]);

         c        := CResolveQuery(rel, filter, min, st, pts)
