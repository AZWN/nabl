module statix/lang/normalize/util

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  nabl2/shared/vars
  nabl2/api

  signatures/statix/lang/-
  statix/lang/statics/-
  statix/lang/util

rules

  free-constraint-vars = rec x (
    collect-om(free-constraint-vars(x) + ![<is-var>])
  ; concat
  )

  free-constraint-vars(fv): CExists(vs, body) -> fvs
    with fvs := <raw-diff> (<fv> body, vs)

  free-constraint-vars(fv): LLam(ps, body) -> fvs
    with fvs := <raw-diff> (<fv> body, <all-vars> ps)


  try-in-constraints(s) = rec x (
    CExists(id, x)
 <+ CConj(x, x)
 <+ CTry(x, id)
 <+ try(s)
  )


rules

  norm-get-ast-type =
    nabl2-get-anno-type
 <+ fatal-err(|"Missing AST type")

  norm-set-ast-type(|ty) =
    nabl2-set-anno-type(|ty)

  norm-copy-ast-type(|t) =
    nabl2-copy-anno-type(|t)

  norm-get-ast-property(|a,prop) =
    not(nabl2-get-ast-index)
  < fatal-err(|"Missing AST index")
  + nabl2-get-ast-property(|a,prop)

  norm-get-ast-decl(|a) =
    not(nabl2-get-ast-index)
  < fatal-err(|"Missing AST index")
  + nabl2-get-ast-property(|a,"decl")

  norm-get-ast-decl-type(|a) =
    norm-get-ast-decl(|a)
  ; nabl2-get-type(|a)

  norm-get-ast-decl-property(|a,prop) =
    not(nabl2-get-ast-index)
  < fatal-err(|"Missing AST index")
  + nabl2-get-ast-property(|a,"decl")
  ; nabl2-get-property(|a,prop)

  norm-preserve-ast-type(s) =
    nabl2-preserve-anno-type(s)


rules

  // replace : old:Term -> new:Term
  // to-c : (old:Term, new:Term) -> Constraint

  normalize-scoped(replace,in-head,add-vars,to-c):
      Rule(lbl, head, body){a*} -> Rule(lbl, head', <mk-CExists>(bvs'', body'')){a*}
    with (head', hmaps) := <in-head < collectom-map(replace) + !(<id>, [])> head;
         // variables in the removed terms which are not in the new head
         hvs := <raw-diff> (<map(Fst);all-vars> hmaps, <all-vars> head');
         body' := <filter(to-c);list-to-conj(|body)> hmaps;
         (body'', bvs') := <collect-map-in-constraints(replace, add-vars, to-c)> body';
         bvs'' := <if add-vars then <conc> (bvs', <id>) else !bvs' end; raw-make-set> hvs

  normalize-scoped(replace,in-head,add-vars,to-c):
      LLam(ts, body){a*} -> LLam(ts', <mk-CExists>(bvs'', body'')){a*}
    with (ts', tmaps) := <in-head < collectom-map(replace) + !(<id>, [])> ts;
         // variables in the removed terms which are not in the new head
         tvs := <raw-diff> (<map(Fst);all-vars> tmaps, <all-vars> ts');
         body'  := <filter(to-c);list-to-conj(|body)> tmaps;
         (body'', bvs') := <collect-map-in-constraints(replace, add-vars, to-c)> body';
         bvs'' := <if add-vars then <conc> (bvs', <id>) else !bvs' end; raw-make-set> tvs


  collect-map-in-constraints(replace,add-vars,to-c): CExists(vs, c) -> (c'', [])
    with (c', vs') := <collect-map-in-constraints(replace,add-vars,to-c)> c
       ; vs'' := <if add-vars then <conc> (vs, <id>) else !vs end; raw-make-set> vs'
       ; c'' := <mk-CExists>(vs'', c')

  collect-map-in-constraints(replace,add-vars,to-c): CConj(c1, c2) -> (c'', vs'')
    with (c1', vs1') := <collect-map-in-constraints(replace,add-vars,to-c)> c1
       ; (c2', vs2') := <collect-map-in-constraints(replace,add-vars,to-c)> c2
       ; c'' := CConj(c1', c2')
       ; vs'' := <conc> (vs1', vs2')

  collect-map-in-constraints(replace,add-vars,to-c): CTry(c, msg) -> (CTry(c'', msg), [])
    with (c', vs') := <collect-map-in-constraints(replace,add-vars,to-c)> c
       ; vs'' := <if add-vars then id else ![] end; raw-make-set> vs'
       ; c'' := <mk-CExists>(vs'', c')

  collect-map-in-constraints(replace,add-vars,to-c): c -> (c'', vs'')
    with (c', maps) := <collectbu-map(replace, not-a-scope)> c
       ; c'' := <filter(to-c);list-to-conj(|c')> maps
         // variables in the new term that were not already in the old one
       ; vs'' := <raw-diff> (<map(Snd);all-vars> maps, <all-vars> c)


  is-scope = ?Rule(_, _, _)
  is-scope = ?LLam(_, _)

  not-a-scope = not(is-scope)


rules // smart constructors for typed terms

  mk-Wld(|ty): _ -> <norm-set-ast-type(|ty)> Wld()

  mk-Wlds = map(\ ty -> <mk-Wld(|ty)> \)

  mk-fresh-Var(|ty) = newname; mk-Var(|ty)

  mk-fresh-Vars(|x) = map(\ ty -> <mk-fresh-Var(|ty)> x \)

  mk-Var(|ty): x -> <norm-set-ast-type(|ty)> Var(x)

  mk-seq-Vars(|x) = map-with-index(\ (i, ty) -> <mk-Var(|ty)> $[[x][<int-to-string> i]] \)

  mk-Op(|ty): (x, ts) -> <norm-set-ast-type(|ty)> Op(x, ts)

  mk-Tuple: ts -> <norm-set-ast-type(|ty)> t
    with if [t] := ts then
           ty := <norm-get-ast-type> t
         else
           t := Tuple(ts);
           ty := TUPLE(<map(norm-get-ast-type)> ts)
         end

  mk-TUPLE: tys -> ty
    with if [ty] := tys then
           id
         else
           ty := TUPLE(tys)
         end

  mk-Nil(|ty): _ -> <norm-set-ast-type(|LIST(ty))> List([])

  mk-Some: t -> <norm-set-ast-type(|OPTION(ty))> Some(t)
    with ty := <norm-get-ast-type> t

  mk-None(|ty): _ -> <norm-set-ast-type(|OPTION(ty))> None()

  mk-List: ts -> <norm-set-ast-type(|ty)> List(ts)
    with tys := <map(norm-get-ast-type)> ts;
         (<map(?ty')> tys <+ fatal-err(|"List types do not agree"));
         ty := LIST(ty')

  mk-ListTail: (ts, t) -> <norm-set-ast-type(|ty)> ListTail(ts, t)
    with tys := <map(norm-get-ast-type)> ts;
         LIST(ty') := <norm-get-ast-type> t;
         (<map(?ty')> tys <+ fatal-err(|"List types do not agree"));
         ty := LIST(ty')

  mk-LLam: (ps, c) -> <norm-set-ast-type(|ty)> LLam(ps, c)
    with tys := <map(norm-get-ast-type)> ps;
         ty := PRED(tys)

  mk-As(|ty): (v, t) -> <norm-set-ast-type(|ty)> As(v, t)

  mk-Occurrence: (ns, us, p) -> <norm-set-ast-type(|OCCURRENCE())> Occurrence(ns, us, p)

rules

  list-to-conj(|tl): []     -> tl
  list-to-conj(|tl): [C|Cs] -> CConj(C, <list-to-conj(|tl)> Cs)

  list-to-conj: []     -> CTrue()
  list-to-conj: [C]    -> C
  list-to-conj: [C|Cs] -> CConj(C, <list-to-conj> Cs)

  mk-CExists: ([], c              ) -> c
  mk-CExists: (vs, CExists(vs', c)) -> CExists(vs'', c)
    where not([] := vs)
    with vs'' := <conc; raw-make-set> (vs', vs)
  mk-CExists: (vs, c              ) -> CExists(vs, c)
    where not([] := vs)

  type-to-sort: SORT(d)      -> SimpleSort(<nabl2-get-occurrence-name> d)
  type-to-sort: INT()        -> IntSort()
  type-to-sort: STRING()     -> StringSort()
  type-to-sort: PATH()       -> PathSort()
  type-to-sort: LABEL()      -> LabelSort()
  type-to-sort: OCCURRENCE() -> OccurrenceSort()
  type-to-sort: SCOPE()      -> ScopeSort()
  type-to-sort: AST_ID()     -> AstIdSort()
  type-to-sort: LIST(ty)     -> ListSort(<type-to-sort> ty)
  type-to-sort: TUPLE(tys)   -> TupleSort(<map(type-to-sort)> tys)

  type-to-sort: PRED(tys)         -> SimpleType(<map(type-to-sort)> tys)
  type-to-sort: FUN(intys, outty) -> FunType(<map(type-to-sort)> intys, <type-to-sort> outty)

  fun-to-pred-type:
      FUN(intys, outty) -> PRED(<conc> (intys, [outty]))

  fun-to-pred-type:
      FunType(insorts, outsort) -> SimpleType(<conc> (insorts, [outsort]))
