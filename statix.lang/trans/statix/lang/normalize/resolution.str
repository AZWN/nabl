module statix/lang/normalize/resolution

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  nabl2/shared/vars
  nabl2/api

  signatures/statix/lang/-
  statix/lang/statics/-
  statix/lang/normalize/util

rules

  // normalize namespace based resolve stand-ins
  // before functional relations

  normalize-resolves = ?(a, <id>);
    nabl2-custom-analysis-info-msg(|"| Normalize namespace-based queries...");
    bottomup(try(normalize-resolve(|a)));
    !(a, <id>)

  normalize-resolve(|a): t@ResolveMatch(Occurrence(ns, ts, _), rel) -> wf'
    with wf := <norm-get-ast-decl-property(|a, "wf")> t;
         wf' := Concat(wf, rel)

  normalize-resolve(|a): t@ResolveLt(_, rel) -> ord'
    with ord := <norm-get-ast-decl-property(|a, "ord")> t;
         ord' := <topdown(try(?EOP();!rel))> ord

  normalize-resolve(|a): OccurrenceMatch(Occurrence(ns, ts, _)) -> lam
    with NS(tys) := <norm-get-ast-decl-type(|a)> ns;
         us := <make-fresh-vars(|"u")> tys;
         d := Occurrence(ns, us, Wld());
         lam := LLam([d], [], CEqual(<build-terms(|tys)> us, <build-terms(|tys)> ts))
  
rules

  // normalize functional relations (eliminate askrelop)
  // after lambda's, before normalizing queries

  normalize-functional-relations = ?(a, <id>);
    nabl2-custom-analysis-info-msg(|"| Normalize functional relations...");
    !(a, <id>)



  replace-cop(|a): AskRelOp(rel, in_ts, st) -> out_t
    with outtys := <norm-get-ast-type(|a);out-types> rel;
         out_ts := <make-fresh-vars(|"t")> outtys;
         out_t := <build-terms(|outtys)> out_ts

  cop-to-c(|a): (op@AskRelOp(rel, in_ts, st), out_t) -> c
    with outtys := <norm-get-ast-type(|a);out-types> rel;
         out_ts := <match-terms(|outtys)> out_t;
         ts := <conc> (in_ts, out_ts);
         c := CAskRel(rel, ts, st)

rules

  // normalize queries
  // after functional relations, before wildcards

  normalize-queries = ?(a, <id>);
    nabl2-custom-analysis-info-msg(|"| Normalize queries...");
    bottomup(try(normalize-query(|a)));
    !(a, <id>)


  normalize-query(|a): CAskRel(rel, ts, st) -> c
    with DATA(ty) := <norm-get-ast-type(|a)> rel;
         tys      := <in-types> ty;

         us       := <make-fresh-vars(|"u")> tys;
         p        := <build-terms(|tys)> us;
         eq       := CEqual(<build-terms(|tys)> us, <build-terms(|tys)> ts);
         match    := LLam([p], [], eq);
         filter   := Filter(rel, match);

         min      := Min([], LFalse());

         t        := <build-terms(|tys)> ts;
         pts      := List([Tuple([Wld(), t])]);

         c         := CResolveQuery(filter, min, st, pts)
