module statix/lang/normalize/relations

imports

  libspoofax/term/annotation
  libspoofax/term/origin

  nabl2/shared/vars
  nabl2/api

  signatures/statix/lang/-
  statix/lang/statics/-
  statix/lang/normalize/util

rules

  // normalize functional relations
  // after lambda's, after normalizing queries

  normalize-functional-relations = ?(a, <id>);
    nabl2-custom-analysis-info-msg(|"| Normalize functional relations...");
    bottomup(
      try(normalize-functional-reldecl)
    ; try(normalize-functional-query(|a))
    );
    !(a, <id>)


  normalize-functional-reldecl:
      RelDecl(x, FunType(s1*, s2*)) -> RelDecl(x, t')
    with s* := <conc> (s1*, s2*);
         t' := SimpleType(s*)

  normalize-functional-query(|a):
      CResolveQuery(Filter(wf, lwf), Min(ord, lord), st, pts)
      -> CResolveQuery(Filter(wf, lwf'), Min(ord, lord'), st, pts)
    where DATA(ty@FUN(_, _)) := <norm-get-ast-type(|a)> wf
    with lwf' := <normalize-functional-wf(|ty)> lwf;
         lord' := <normalize-functional-ord(|ty)> lord

  normalize-functional-wf(|ty):
      LLam([p], vs, c) -> LLam([p'], vs', c')
   with (p', new-vs, c*) := <normalize-functional-pattern(|ty)> p;
        vs' := <conc> (vs, new-vs);
        c' := <list-to-conj(|c)> c*

  normalize-functional-ord(|ty):
      LLam([p1, p2], vs, c) -> LLam([p1', p2'], vs', c')
   with (p1', new-vs1, c1*) := <normalize-functional-pattern(|ty)> p1;
        (p2', new-vs2, c2*) := <normalize-functional-pattern(|ty)> p2;
        vs' := <concat> [vs, new-vs1, new-vs2];
        c' := <conc;list-to-conj(|c)> (c1*, c2*)

  normalize-functional-pattern(|ty): p -> (p', vs, c*)
    with in_tys  := <in-types> ty;
         out_tys := <out-types> ty;
         tys     := <conc> (in_tys, out_tys);
         out_wlds := <map(!Wld())> out_tys;
         if in_ts := <match-terms(|in_tys)> p then
           p' := <conc;build-terms(|tys)> (in_ts, out_wlds);
           vs := [];
           c* := []
         else
           us := <make-fresh-vars(|"u")> in_tys;
           p' := <conc;build-terms(|tys)> (us, out_wlds);
           vs := <all-vars> p;
           c* := [CEqual(<build-terms(|in_tys)> us, p)]
         end
