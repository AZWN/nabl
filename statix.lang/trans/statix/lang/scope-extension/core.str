module statix/lang/scope-extension/core

imports

  nabl2/api

  signatures/statix/lang/-
  statix/lang/-
  statix/lang/statics/-
  statix/lang/scope-extension/-

signature
  sorts Extensions constructors
    VarExt   : Var -> Extensions
    ParamExt : Term * Integer -> Extension
             : List(Term) -> Extension
  sorts ExtensionConstraint constructors
    Provide : Extensions * Extensions -> ExtensionConstraint
    Require : Extensions * Extensions -> ExtensionConstraint

rules // collect extension constraints

  ext-constraints: Rule(C(x, arg*), _, body) -> c
    with c := < add-indices
              ; filter(param-ext-constraints(|x))
              ; combine-ext-constraints
              > arg*

  param-ext-constraints(|x): (i, t) -> c
    where (term-ext, term-c) := <term-ext> t
    with param-ext := <with-origin(|x)> ParamExt(x, i)
       ; provide* := [Provide(term-ext, [()])]
         // Provide(param-ext, term-ext) for exporting permissions
         // But need to figure out how to solve those, since a constriant
         // should only provide permission if *all* its rules to so.
       ; require* := [Require(term-ext, param-ext)]
       ; param-c := (provide*, require*)
       ; c := <combine-ext-constraints> [term-c, param-c]


  ext-constraints: CNew(vs) -> c
    with (term-ext*, term-c*) := <map(term-ext);unzip> vs
       ; provide* := <map(!Provide(<id>,[()]))> term-ext*
       ; new-c := (provide*, [])
       ; c := <combine-ext-constraints> [new-c|term-c*]

  ext-constraints: CTellEdge(t, lbl, _) -> c
    where (term-ext, term-c) := <term-ext> t
    with edge-c := ([], [Require([lbl], term-ext)])
       ; c := <combine-ext-constraints> [term-c, edge-c]

  ext-constraints: CTellRel(lbl, _, t) -> c
    where (term-ext, term-c) := <term-ext> t
    with data-c := ([], [Require([lbl], term-ext)])
       ; c := <combine-ext-constraints> [term-c, data-c]

  // FIXME this also matches rule heads!
  ext-constraints: C(x, arg*) -> c
    with c := < add-indices
              ; filter(arg-ext-constraints(|x))
              ; combine-ext-constraints
              > arg*

  arg-ext-constraints(|x): (i, t) -> c
    where (term-ext, term-c) := <term-ext> t
    with param-ext := <with-origin(|x)> ParamExt(x, i)
       ; provide* := [Provide(term-ext, param-ext)]
       ; require* := [Require(param-ext, term-ext)]
       ; arg-c := (provide*, require*)
       ; c := <combine-ext-constraints> [term-c, arg-c]


  term-ext: Var(x) -> (ext, c)
    with ext := <with-origin(|x)> VarExt(x)
       ; c := ([], [])

