module statix/lang/scope-extension/core

imports

  nabl2/api

  signatures/statix/lang/-
  statix/lang/-
  statix/lang/statics/-

signature
  sorts Extensions constructors
    TermExt  : Term -> Extensions
    ParamExt : Term * Integer -> Extension
             : List(Term) -> Extension
  sorts ExtensionConstraint constructors
    Provide : Extensions * Extensions -> ExtensionConstraint
    Require : Extensions * Extensions -> ExtensionConstraint

rules // collect extension constraints

  rule-ext-constraints: Rule(head, _, body) -> c
    with head-c := <head-ext-constraints> head
       ; body-c := < collect-om(constraint-ext-constraints)
                   ; combine-ext-constraints
                   > body
       ; c := <combine-ext-constraints> [head-c, body-c]
  

  head-ext-constraints: C(x, arg*) -> c
    with c := < add-indices
              ; filter(param-ext-constraints(|x))
              ; combine-ext-constraints
              > arg*

  param-ext-constraints(|x): (i, t) -> c
    where (term-ext, term-c) := <term-ext> t
    with param-ext := ParamExt(x, i)
       ; param-c := ([Provide(param-ext, term-ext)], [Require(term-ext, param-ext)])
       ; c := <combine-ext-constraints> [term-c, param-c]


  constraint-ext-constraints: CNew(vs) -> c
    with (term-ext*, term-c*) := <map(term-ext);unzip> vs
       ; new-c := (<map(!Provide(<id>,[()]))> term-ext*, [])
       ; c := <combine-ext-constraints> [new-c|term-c*]

  constraint-ext-constraints: CTellEdge(t, lbl, _) -> c
    with (term-ext, term-c) := <term-ext> t
       ; edge-c := ([], [Require([lbl], term-ext)])
       ; c := <combine-ext-constraints> [term-c, edge-c]

  constraint-ext-constraints: CTellRel(lbl, _, t) -> c
    with (term-ext, term-c) := <term-ext> t
       ; data-c := ([], [Require([lbl], term-ext)])
       ; c := <combine-ext-constraints> [term-c, data-c]

  constraint-ext-constraints: C(x, arg*) -> c
    with c := < filter(arg-ext-constraints(|x))
              ; combine-ext-constraints
              > arg*

  arg-ext-constraints(|x): (t, i) -> c
    where (term-ext, term-c) := <term-ext> t
    with param-ext := ParamExt(x, i)
       ; arg-c := ([Provide(term-ext, param-ext)], [Require(param-ext, term-ext)])
       ; c := <combine-ext-constraints> [term-c, arg-c]


  term-ext: v@Var(_) -> (ext, c)
    with ext := TermExt(v)
       ; c := ([], [])


rules // shared

  combine-ext-constraints =
    unzip
  ; (concat, concat)


rules // explicate occurrences

  expl-ext-constraint(|a) = Provide(expl-ext(|a), expl-ext(|a))
  expl-ext-constraint(|a) = Require(expl-ext(|a), expl-ext(|a))

  expl-ext(|a) = is-list

  expl-ext(|a): TermExt(v@Var(x)) -> TermExt(d)
    with ty := <nabl2-get-ast-type(|a)> v
    where SCOPE() := ty
    with d := <nabl2-get-ast-property(|a,"decl")> x

  expl-ext(|a): ParamExt(x, i) -> ParamExt(d, i)
    with d := <nabl2-get-ast-property(|a,"decl")> x
       ; tys := <nabl2-get-type(|a);inout-types> d
       ; ty := <index(|i)> tys
    where SCOPE() := ty

/*

rules // shared

  rule-vars: Rule(head, var*, body) -> (head-proj*, new-var*)
    with head-proj* := <head-projs> head;
         new-var*   := <all-fresh> body

  head-name: C(x, _) -> x

  head-projs: C(_, arg*) -> proj*
    with proj* := <map-with-index(Swap);filter(?(Var(_), _))> arg*

  all-fresh = collect-om(\ CNew(var*) -> var* \); concat

rules // base facts, constraints directly adding to the scope graph

  base-extensions(|error-iset, note-iset): rule@Rule(head, _, body) -> rule-ext*
    with x := <head-name> head;
         (head-proj*, new-var*) := <rule-vars> rule;
         head-var*  := <map(Fst)> head-proj*;
         all-ext*   := <collect-om(base-extension);concat;filter(?(Var(_),_))> body;

         new-ext*   := <filter(\ (v, lbl) -> (v, lbl) where <raw-elem> (v, new-var*) \)> all-ext*;
       //<map(\ (v, lbl) -> <iset-add(|(v, $[Extends locally fresh scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> note-iset \)> new-ext*;

         head-ext*  := <filter({v' : \ (v, lbl) -> (v', lbl) where (v', _) := <raw-lookup> (v, head-proj*) \})> all-ext*;
       //<map(\ (v, lbl) -> <iset-add(|(v, $[Extends parameter scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> note-iset \)> head-ext*;

         local-ext* := <filter(\ (v, lbl) -> (v, lbl) where <not(raw-elem)> (v, <conc> (head-var*, new-var*)) \)> all-ext*;
         <map(\ (v, lbl) -> <iset-add(|(v, $[Cannot extend non-local scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> error-iset \)> local-ext*;

         rule-ext*  := <join(\ ((v1, i), (v2, lbl)) -> (x, i, lbl) where <raw-eq> (v1, v2) \)> (head-proj*, head-ext*)

  base-extension: CTellEdge(s, lbl, _) -> [(s, lbl)]
  base-extension: CTellRel(rel, _, s) -> [(s, rel)]

rules // derived facts, constraints indirectly adding to the scope graph

  derive-extensions(|ast, error-iset, note-iset): ext -> ext*
    with ext* := <collect-om(derived-extensions(|ext, error-iset, note-iset));concat> ast

  derived-extensions(|ext, error-iset, note-iset): rule@Rule(head, var*, body) -> rule-ext*
    with x := <head-name> head;
         (y, i, lbl) := ext;
         (head-proj*, new-var*) := <rule-vars> rule;
         head-var*  := <map(Fst)> head-proj*;
         all-ext*   := <collect-om(derive-extension(|y, i);?Var(_))> body;

         new-ext*   := <filter(\ v -> v where <raw-elem> (v, new-var*) \)> all-ext*;
       //<map(\ v -> <iset-add(|(v, $[Extends locally fresh scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> note-iset \)> new-ext*;

         head-ext*  := <filter({v' : \ v -> v' where (v', _) := <raw-lookup> (v, head-proj*) \})> all-ext*;
       //<map(\ v -> <iset-add(|(v, $[Extends parameter scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> note-iset \)> head-ext*;

         local-ext* := <filter(\ v -> v where <not(raw-elem)> (v, <conc> (head-var*, new-var*)) \)> all-ext*;
         <map(\ v -> <iset-add(|(v, $[Cannot extend non-local scope [<pp-partial-Statix-string> v] in [<pp-partial-Statix-string> lbl]]))> error-iset \)> local-ext*;

         rule-ext* := <join(\ ((v1, i), v2) -> (x, i, lbl) where <raw-eq> (v1, v2) \)> (head-proj*, head-ext*)

  derive-extension(|y, i): C(x, arg*) -> arg
    where <raw-eq> (x, y)
    with arg := <index(|i)> arg*

*/