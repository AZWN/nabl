module statix/lang/scope-extension/core

imports

  nabl2/api

  signatures/statix/lang/-
  statix/lang/-
  statix/lang/statics/-
  statix/lang/scope-extension/-

rules // collect extension constraints

  ext-constraints: Rule(C(x, ps), _, body) -> c*
    with c* := <map-with-index(ext-param-constraints(|x));concat> ps

  ext-param-constraints(|x): (i, Var(y)) -> c*
    with c* := [ ExtProvides(ExtParam(x, i), ExtVar(y))
               , ExtRequires(ExtParam(x, i), ExtVar(y))
               ]

  ext-param-constraints(|x): (i, p) -> c*
    where not(Var(_) := p)
    with c* := <all-vars;map(\ Var(y) -> ExtIsCovered(ExtVar(y)) \)> p


  ext-constraints: LLam(ps, body) -> c*
    with c* := <all-vars;map(\ Var(y) -> ExtIsCovered(ExtVar(y)) \)> ps


  ext-constraints: CNew(vs) -> c*
    with c* := <map(\ Var(y) -> ExtProvides(ExtVar(y), ExtAll()) \)> vs

  ext-constraints: CTellEdge(Var(y), lbl, _) -> c*
    with c* := [ExtRequires(ExtVar(y), ExtLit([lbl]))]

  ext-constraints: CTellRel(lbl, _, Var(y)) -> c*
    with c* := [ExtRequires(ExtVar(y), ExtLit([lbl]))]


  // FIXME This also matches rule heads! This gives an unnecessary circular
  //       constraint, but won't invalidate the result of the analysis.
  ext-constraints: C(x, args) -> c*
    with c* := <map-with-index(ext-arg-constraints(|x));concat> args

  ext-arg-constraints(|x): (i, Var(y)) -> c*
    with c* := [ ExtProvides(ExtVar(y), ExtParam(x, i))
               , ExtRequires(ExtVar(y), ExtParam(x, i))
               ]

  ext-arg-constraints(|x): (i, _) -> []
