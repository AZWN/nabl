module statics/scope-extension

imports

  nabl2/api

  signatures/-
  statics/-
  pp

rules

  compute-scope-extensions(|a): ast -> (ext*, error*, [], note*)
    with ast' := <normalize-all(|a)> ast;
         error-iset := <new-iset>;
         note-iset := <new-iset>;
         base-ext* := <collect-om(base-extensions(|error-iset, note-iset));concat> ast';
         ext-iset := <new-iset>;
         <iset-addlist(|base-ext*)> ext-iset;
         <iset-fixpoint(derive-extensions(|ast', error-iset, note-iset))> ext-iset;
         ext* := <iset-elements> ext-iset;
         error* := <iset-elements> error-iset;
         note* := <iset-elements> note-iset

  unzip3 = ?[(x,y,z)|xyz*] < <unzip3> xyz* => (x*,y*,z*); !([x|x*],[y|y*],[z|z*]) + !([],[],[])
  unzip4 = ?[(x,y,z,a)|xyza*] < <unzip4> xyza* => (x*,y*,z*,a*); !([x|x*],[y|y*],[z|z*],[a|a*]) + !([],[],[],[])

  raw-eq = (strip-annos, strip-annos); eq
  raw-elem = elem(raw-eq)
  raw-lookup = lookup((id,Fst);raw-eq)
  raw-diff = diff(raw-eq)

rules // shared

  rule-x: C(x, _) -> x
  rule-x: F(x, _, _) -> x

  rule-vars: Rule(head, _, _, var*, body) -> (head-proj*, new-var*)
    with head-proj* := <head-projs> head;
         new-var*   := <all-fresh> body

  head-projs: C(_, arg*) -> proj*
    with proj* := <map-with-index(Swap);filter(?(Var(_), _))> arg*

  head-projs: F(_, inarg*, _) -> proj*
    with proj* := <map-with-index(Swap);filter(?(Var(_), _))> inarg*

  all-fresh = collect-om(\ CNew(var*) -> var* \); concat

rules // base facts, constraints directly adding to the scope graph

 base-extensions(|error-iset, note-iset): rule@Rule(head, _, _, _, body) -> rule-ext*
    with x := <rule-x> head;
         (head-proj*, new-var*) := <rule-vars> rule;
         head-var*  := <map(Fst)> head-proj*;
         all-ext*   := <collect-om(base-extension);concat;filter(?(Var(_),_))> body;
         new-ext*   := <filter(\ (v, lbl) -> (v, lbl) where <raw-elem> (v, new-var*) \)> all-ext*;
         head-ext*  := <filter({v' : \ (v, lbl) -> (v', lbl) where (v', _) := <raw-lookup> (v, head-proj*) \})> all-ext*;
         local-ext* := <filter(\ (v, lbl) -> (v, lbl) where <not(raw-elem)> (v, <conc> (head-var*, new-var*)) \)> all-ext*;
       //<map(\ (v, lbl) -> <iset-add(|(v, $[Extended in [<pp-label> lbl]]))> note-iset \)> head-ext*;
       //<map(\ (v, _) -> <iset-add(|(v, $[Extends locally fresh scope]))> note-iset \)> new-ext*;
         <map(\ (v, _) -> <iset-add(|(v, $[Cannot extend non-local scope]))> error-iset \)> local-ext*;
         rule-ext*  := <join(\ ((v1, i), (v2, lbl)) -> (x, i, lbl) where <raw-eq> (v1, v2) \)> (head-proj*, head-ext*)

  base-extension: CTellDirectEdge(s, lbl, _) -> [(s, lbl)]
  base-extension: CTellRel(rel, _, s) -> [(s, rel)]
  base-extension: CTellDecl(s, _) -> [(s, Decl())]
  base-extension: CTellDeclWithRel(s, _, rel, _) -> [(s, Decl()), (s, rel)]

rules // derived facts, constraints indirctly adding to the scope graph

  derive-extensions(|ast, error-iset, note-iset): ext -> ext*
    with ext* := <collect-om(derived-extensions(|ext, error-iset, note-iset));concat> ast

  derived-extensions(|ext, error-iset, note-iset): CDeriveMap(x, x', lsorts) -> ext*
    where (y, i, lbl) := ext;
          <raw-eq> (y, x');
          lsort       := <index(|i)> lsorts
    with switch !lsort
           case ?Id():
             ext* := [(x, i, lbl)]
           //<iset-add(|(lsort, $[Extended in [<pp-label> lbl]]))> note-iset
           case ?ToList():
             ext* := [];
             <iset-add(|(lsort, $[Cannot extend list of scopes]))> error-iset
         end

  derived-extensions(|ext, error-iset, note-iset): rule@Rule(head, _, _, var*, body) -> rule-ext*
    where (y, i, lbl) := ext
    with x := <rule-x> head;
         (head-proj*, new-var*) := <rule-vars> rule;
         head-var*  := <map(Fst)> head-proj*;
         all-ext*   := <collect-om(derive-extension(|y, i);?Var(_))> body;
         new-ext*   := <filter(\ v -> v where <raw-elem> (v, new-var*) \)> all-ext*;
         head-ext*  := <filter({v' : \ v -> v' where (v', _) := <raw-lookup> (v, head-proj*) \})> all-ext*;
         local-ext* := <filter(\ (v, lbl) -> (v, lbl) where <not(raw-elem)> (v, <conc> (head-var*, new-var*)) \)> all-ext*;
       //<map(\ v -> <iset-add(|(v, $[Extended in [<pp-label> lbl]]))> note-iset \)> head-ext*;
       //<map(\ v -> <iset-add(|(v, $[Extends locally fresh scope]))> note-iset \)> new-ext*;
         <map(\ v -> <iset-add(|(v, $[Cannot extend non-local scope]))> error-iset \)> local-ext*;
         rule-ext* := <join(\ ((v1, i), v2) -> (x, i, lbl) where <raw-eq> (v1, v2) \)> (head-proj*, head-ext*)

  derive-extension(|y, i): C(x, arg*) -> arg
    where <raw-eq> (x, y);
          arg := <index(|i)> arg*

  derive-extension(|y, i): COp(x, arg*) -> arg
    where <raw-eq> (x, y);
          arg := <index(|i)> arg*

rules

  pp-label: lbl -> pp
    with lbl' := <try( Rel(nabl2-get-occurrence-name)
                     + Label(nabl2-get-occurrence-name)
                     )> lbl;
         pp := <pp-partial-StatixLang-string> lbl'
