module statics/statix

imports

  signatures/-

/** How to deal with AST terms?
 *
 * Terms from the AST are somehwat special, as they are indexed. We want
 * to record information per index, and same AST terms are sometimes considered
 * different based on location even though the terms are the same.
 *
 * This is an issue when recording the scope of an expression, or when
 * taking the index of something.
 */

signature

  sorts
    TClass
    SKind

  constructors
    SimpleSort : SKind
    SortAlias  : SKind

    OccurrenceEdge : TClass
    DirectEdge     : TClass
    NamedEdge      : TClass
    CanQuery       : TClass

  namespaces
    C
    Lang
    Lbl
    Ns
    Op
    Rel
    Sort

  relations
    in  : Type * TClass

  name resolution
    labels P I
    well-formedness P* I?
    order D < P, I < P

rules

  init ^ (s) :=
    new s,

    (SCOPE(),      SCOPE()     ) <in! DirectEdge(),
    (OCCURRENCE(), SCOPE()     ) <in! OccurrenceEdge(),
    (SCOPE(),      OCCURRENCE()) <in! OccurrenceEdge(),
    (OCCURRENCE(), SCOPE()     ) <in! NamedEdge(),
    (SCOPE(),      OCCURRENCE()) <in! NamedEdge(),

    OCCURRENCE() <in! CanQuery().

  [[ Module(x, sections) ^ (s) ]] :=
    new s',
    Lang{x} <- s, Lang{x} ===> s',
    Lang{x} -> s, Lang{x} <=== s',
    Map1[[ sections ^ (s') ]],
    (D(s')/C    lsect/name (W(s')/C    minus D(s')/C   )) subseteq 0 | error $[Duplicate constraint [NAME]] @NAMES,
    (D(s')/Lbl  lsect/name (W(s')/Lbl  minus D(s')/Lbl )) subseteq 0 | error $[Duplicate relation [NAME]] @NAMES,
    (D(s')/Ns   lsect/name (W(s')/Ns   minus D(s')/Ns  )) subseteq 0 | error $[Duplicate namespace [NAME]] @NAMES,
    (D(s')/Op   lsect/name (W(s')/Op   minus D(s')/Op  )) subseteq 0 | error $[Duplicate constructor [NAME]] @NAMES,
    (D(s')/Rel  lsect/name (W(s')/Rel  minus D(s')/Rel )) subseteq 0 | error $[Duplicate relation [NAME]] @NAMES,
    (D(s')/Sort lsect/name (W(s')/Sort minus D(s')/Sort)) subseteq 0 | error $[Duplicate sort [NAME]] @NAMES.

  [[ Signature(sigs) ^ (s) ]] :=
    Map1[[ sigs ^ (s) ]].

  [[ Sorts(sorts) ^ (s) ]] :=
    Map1(SortDecl)[[ sorts ^ (s) ]].

  SortDecl[[ SortDecl(x) ^ (s) ]] :=
    Sort{x} <- s,
    Sort{x} : SORT(Sort{x}) !!,
    Sort{x}.kind := SimpleSort().

  SortDecl[[ SortAlias(x, sort) ^ (s) ]] :=
    Sort{x} <- s,
    Sort{x} : ty !!,
    Sort{x}.kind := SortAlias(),
    SortRef[[ sort ^ (s) : ty ]].

  [[ Constructors(ctors) ^ (s) ]] :=
    Map1[[ ctors ^ (s) ]].

  [[ OpDecl(x, sort) ^ (s) ]] :=
    Op{x} <- s,
    Op{x} : ty !!,
    OpSort[[ sort ^ (s) : ty ]].

  OpSort[[ ConstOp(sort) ^ (s) : OP([], ty) ]] :=
    RealSortRef[[ sort ^ (s) : ty ]].

  OpSort[[ ArrowOp(args, sort) ^ (s) : OP(tys, ty) ]] :=
    Map1T(SortRef)[[ args ^ (s) : tys ]],
    RealSortRef[[ sort ^ (s) : ty ]].

  RealSortRef[[ SimpleSort(x) ^ (s) : ty ]] :=
    Sort{x} -> s, Sort{x} |-> d,
    d : ty !,
    d.kind := k, k != SortAlias() | error $[Cannot refer to alias [d]].

  SortRef[[ IntSort() ^ (_) : INT() ]].
  SortRef[[ StringSort() ^ (_) : STRING() ]].
  SortRef[[ OccurrenceSort() ^ (_) : OCCURRENCE() ]].
  SortRef[[ PathSort(sort) ^ (_) : PATH(ty) ]] :=
    SortRef[[ sort ^ (s) : ty ]].
  SortRef[[ ScopeSort() ^ (_) : SCOPE() ]].
  SortRef[[ TupleSort(sorts) ^ (s) : TUPLE(tys) ]] :=
    Map1T(SortRef)[[ sorts ^ (s) : tys ]].
  SortRef[[ ListSort(sort) ^ (s) : LIST(ty) ]] :=
    SortRef[[ sort ^ (s) : ty ]].
  SortRef[[ SimpleSort(x) ^ (s) : ty ]] :=
    Sort{x} -> s,
    Sort{x} |-> d,
    d : ty.

  [[ Namespaces(nss) ^ (s) ]] :=
    Map1[[ nss ^ (s) ]].

  [[ NsDecl(x) ^ (s) ]] :=
    Ns{x} <- s, Ns{x} : NS([STRING()]).

  [[ Constraints(cs) ^ (s) ]] :=
    Map1[[ cs ^ (s) ]].

  [[ CDecl(x, params, kind) ^ (s) ]] :=
    C{x} <- s,
    C{x} : CON(tys) !,
    Map1T[[ params ^ (s) : tys ]].

  [[ Param(inOut, sort) ^ (s) : ty ]] :=
    SortRef[[ sort ^ (s) : ty ]].

  [[ NameResolution(params) ^ (s) ]] :=
    Map1[[ params ^ (s) ]].

  [[ Labels(lbls) ^ (s) ]] :=
    Map1(LabelDecl)[[ lbls ^ (s) ]].

  [[ DefaultELabel(lbl) ^ (s) ]] :=
    Lbl{DefaultELabel()} <- s, 
    LabelRef[[ lbl ^ (s) ]].

  [[ DefaultNLabel(lbl) ^ (s) ]] :=
    Lbl{DefaultNLabel()} <- s, 
    LabelRef[[ lbl ^ (s) ]].

  [[ Strategy(Occurrence(x, params, pos), target, match, disamb) ^ (s) ]] :=
    Ns{x} <- s, Ns{x} : NS(tys) !,
    new s',
    s' ---> s,
    Map1T(Match)[[ params ^ (s') : tys ]],
    [[ target ^ (s) : rty ]],
    [[ match ^ (s', rty) ]],
    [[ disamb ^ (s', rty) ]].

  [[ OverrideStrategy(Occurrence(x, params, pos), match, disamb) ^ (s) ]] :=
    Ns{x} -> s, Ns{x} |-> d, d : NS(tys),
    new s',
    s' ---> s,
    Map1T(Match)[[ params ^ (s') : tys ]],
    [[ match ^ (s', OCCURRENCE()) ]],
    [[ disamb ^ (s', OCCURRENCE()) ]].

  [[ DeclTarget() ^ (s) : OCCURRENCE() ]].

  [[ EmptyTarget() ^ (s) : TUPLE([]) ]].

  [[ Target(x) ^ (s) : TUPLE(tys) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := ScopedRel() | warning $[Relation [x] is global, use a scoped relation instead.].

  [[ Match(var, clauses) ^ (s, ty) ]] :=
    new s',
    s' ---> s,
    VarDecl[[ var ^ (s') : PATH(ty) ]],
    Map1[[ clauses ^ (s') ]].

  [[ Disamb(var1, var2, clauses) ^ (s, ty) ]] :=
    new s',
    s' ---> s,
    VarDecl[[ var1 ^ (s') : PATH(ty) ]],
    VarDecl[[ var2 ^ (s') : PATH(ty) ]],
    Map1[[ clauses ^ (s') ]].

  LabelDecl[[ Label(x) ^ (s) ]] :=
    Lbl{x} <- s.

  LabelRef[[ Label(x) ^ (s) ]] :=
    Lbl{x} -> s,
    Lbl{x} |-> _.

  LabelRef[[ lbl@DefaultELabel() ^ (s) ]] :=
    Lbl{lbl} -> s,
    Lbl{lbl} |-> _ | error "No default edge label declared".

  LabelRef[[ lbl@DefaultNLabel() ^ (s) ]] :=
    Lbl{lbl} -> s,
    Lbl{lbl} |-> _ | error "No default named label declared".

  LabelRef[[ D() ^ (s) ]].

  [[ Rules(rs) ^ (s) ]] :=
    Map1[[ rs ^ (s) ]].

  [[ Rule(h, vs, g, c) ^ (s) ]] :=
    new s', s' ---> s,
    distinct/name D(s')/Var | error $[Duplicate local variable [NAME]] @NAMES,
    UserConstraint(NonUniqueVarDecl)[[ h ^ (s') ]],
    [[ vs ^ (s') ]],
    [[ g ^ (s') ]],
    [[ c ^ (s') ]].

  [[ NoLocalVars() ^ (s) ]].

  [[ LocalVars(vs) ^ (s) ]] :=
    Map1T(VarDecl)[[ vs ^ (s) : _ ]].

  [[ Relations(rdecls) ^ (s) ]] :=
    Map1[[ rdecls ^ (s) ]].

  [[ RelDecl(props, x, reltype, kind) ^ (s) ]] :=
    Rel{x} <- s,
    Rel{x} : ty !,
    [[ reltype ^ (s) : ty ]],
    [[ kind ^ (Rel{x}) ]].

  [[ SimpleRelation(sorts) ^ (s) : REL(tys) ]] :=
    Map1T(SortRef)[[ sorts ^ (s) : tys ]].

  [[ FunctionalRelation(insorts, outsorts) ^ (s) : REL(_) ]] :=
    Map1T(SortRef)[[ insorts ^ (s) : intys ]],
    SortRef[[ outsorts ^ (s) : outtys ]],
    false | error "Cannot type check functional relations correctly yet".

  [[ GlobalRel() ^ (d) ]] :=
    d.kind := GlobalRel() !.

  [[ ScopedRel() ^ (d) ]] :=
    d.kind := ScopedRel() !.

rules

  UserConstraint(V)[[ C(x, args) ^ (s) ]] :=
    C{x} -> s,
    C{x} |-> d,
    d : CON(tys),
    Map1T(Term(V))[[ args ^ (s) : tys ]].

  [[ c@C(_, _) ^ (s) ]] :=
    UserConstraint(VarRef)[[ c ^ (s) ]].

  [[ CTrue() ^ (_) ]].
  [[ CFalse() ^ (_) ]].

  [[ CConj(c1, c2) ^ (s) ]] :=
    [[ c1 ^ (s) ]],
    [[ c2 ^ (s) ]].

  [[ CNew(vs) ^ (s) ]] :=
    Map1t(VarRef)[[ vs ^ (s) : SCOPE() ]].

  [[ CScope(vs, c) ^ (s) ]] :=
    new s', s' ---> s,
    Map1T(VarDecl)[[ vs ^ (s') : _ ]],
    [[ c ^ (s') ]].

  [[ CDisamb(t1, t2, t3, t4, c) ^ (s) ]] :=
    Build[[ t1 ^ (s) : LIST(ty) ]],
    new s', s' ---> s,
    Match[[ t2 ^ (s') : ty ]],
    Match[[ t3 ^ (s') : ty ]],
    Build[[ t4 ^ (s) : LIST(ty) ]],
    [[ c ^ (s') ]].

  [[ CEqual(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty ]],
    Build[[ t2 ^ (s) : ty ]].

  [[ CInequal(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty ]],
    Build[[ t2 ^ (s) : ty ]].

  [[ CTellRightOccurrence(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? OccurrenceEdge().

  [[ CAskRightOccurrence(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? OccurrenceEdge().

  [[ CTellLeftOccurrence(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? OccurrenceEdge().

  [[ CAskLeftOccurrence(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? OccurrenceEdge().

  [[ CTellRightEdge(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? DirectEdge().

  [[ CAskRightEdge(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? DirectEdge().

  [[ CTellLeftEdge(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? DirectEdge().

  [[ CAskLeftEdge(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? DirectEdge().

  [[ CTellRightNamed(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? NamedEdge().

  [[ CAskRightNamed(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? NamedEdge().

  [[ CTellLeftNamed(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? NamedEdge().

  [[ CAskLeftNamed(t1, lbl, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty1 ]],
    LabelRef[[ lbl ^ (s) ]],
    Build[[ t2 ^ (s) : ty2 ]],
    (ty1, ty2) <in? NamedEdge().

  [[ CResolve(t1, t2) ^ (s) ]] :=
    Build[[ t1 ^ (s) : OCCURRENCE() ]],
    Build[[ t2 ^ (s) : LIST(PATH(_)) ]].

  [[ CQuery(t1, t2, t3) ^ (s) ]] :=
    Build[[ t1 ^ (s) : ty ]],
    ty <in? CanQuery(),
    Build[[ t2 ^ (s) : SCOPE() ]],
    Build[[ t3 ^ (s) : LIST(PATH(_)) ]].

  [[ CAskGlobalRel(x, ts) ^ (s) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := GlobalRel() | error $[Relation [x] is scoped, use `?r(...) in s` instead.],
    Map1T(Build)[[ ts ^ (s) : tys ]].

  [[ CTellGlobalRel(x, ts) ^ (s) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := GlobalRel() | error $[Relation [x] is scoped, use `!r(...) in s` instead.],
    Map1T(Build)[[ ts ^ (s): tys ]].

  [[ CAskScopedRel(x, ts, st) ^ (s) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := ScopedRel() | warning $[Relation [x] is global, use `?r(...)` instead.],
    Map1T(Build)[[ ts ^ (s) : tys ]],
    Build[[ st ^ (s) : SCOPE() ]].

  [[ CNotScopedRel(x, ts, st) ^ (s) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := ScopedRel() | warning $[Relation [x] is global.],
    Map1T(Build)[[ ts ^ (s) : tys ]],
    Build[[ st ^ (s) : SCOPE() ]].

  [[ CTellScopedRel(x, ts, st) ^ (s) ]] :=
    RelRef[[ x ^ (s, d) : tys ]],
    d.kind := ScopedRel() | warning $[Relation [x] is global, use `!r(...)` instead.],
    Map1T(Build)[[ ts ^ (s): tys ]],
    Build[[ st ^ (s) : SCOPE() ]].

  RelRef[[ x ^ (s, d) : tys ]] :=
    Rel{x} -> s,
    Rel{x} |-> d,
    d : REL(tys).

  [[ CPathLt(prs, p1, p2) ^ (s) ]] :=
    Build[[ p1 ^ (s) : PATH(ty) ]],
    Build[[ p2 ^ (s) : PATH(ty) ]],
    Map1[[ prs ^ (s) ]].

  [[ LabelPair(lbl1, lbl2) ^ (s) ]] :=
    LabelRef[[ lbl1 ^ (s) ]],
    LabelRef[[ lbl2 ^ (s) ]].

  [[ CPathMatch(re, p) ^ (s) ]] :=
    LabelRE[[ re ^ (s) ]],
    Build[[ p ^ (s) : PATH(_) ]].

rules

  Match[[ t ^ (s) : ty ]] :=
    Term(VarDecl)[[ t ^ (s) : ty ]].

  Build[[ t ^ (s) : ty ]] :=
    Term(VarRef)[[ t ^ (s) : ty ]].

  NonUniqueVarDecl[[ Var(x) ^ (s) : ty ]] :=
    Var{x @s} <- s,
    Var{x @s} : ty !.

  NonUniqueVarDecl[[ Wld() ^ (_) : _ ]].

  VarDecl[[ Var(x) ^ (s) : ty ]] :=
    Var{x} <- s,
    Var{x} : ty !.

  VarDecl[[ Wld() ^ (_) : _ ]].

  VarRef[[ Var(x) ^ (s) : ty ]] :=
    Var{x} -> s,
    Var{x} |-> d,
    d : ty.

  VarRef[[ Wld() ^ (_) : _ ]].

  Term(V)[[ v@Var(_) ^ (s) : ty ]] :=
    V[[ v ^ (s) : ty ]].
  Term(V)[[ Wld() ^ (_) : ty ]].
  Term(V)[[ List(ts) ^ (s): LIST(ty) ]] :=
    Map1t(Term(V))[[ ts ^ (s) : ty ]].
  Term(V)[[ ListTail(ts, t) ^ (s) : LIST(ty) ]] :=
    Map1t(Term(V))[[ ts ^ (s) : ty ]],
    Term(V)[[ t ^ (s) : LIST(ty) ]].
  Term(V)[[ ListLength(t) ^ (s): INT() ]] :=
    Term(V)[[ t ^ (s) : LIST(_) ]].
  Term(V)[[ Tuple(ts) ^ (s) : TUPLE(tys) ]] :=
    Map1T(Term(V))[[ ts ^ (s) : tys ]].
  Term(V)[[ Op(x, args) ^ (s) : ty ]] :=
    Op{x} -> s,
    Op{x} |-> d,
    d : OP(tys, ty),
    Map1T(Term(V))[[ args ^ (s) : tys ]].
  Term(V)[[ Str(_) ^ (_) : STRING() ]].
  Term(V)[[ StrBuild(ts) ^ (s) : STRING() ]] :=
    Map1T(Term(V))[[ ts ^ (s) : _ ]].
  Term(V)[[ Int(_) ^ (_) : INT() ]].
  Term(V)[[ Occurrence(ns, ts, pos) ^ (s) : OCCURRENCE() ]] :=
    Ns{ns} -> s, Ns{ns} |-> d, d : NS(tys),
    Map1T(Term(V))[[ ts ^ (s) : tys ]],
    Pos(V)[[ pos ^ (s) ]].
  Term(V)[[ As(v, t) ^ (s) : ty ]] :=
    V[[ v ^ (s) : ty ]],
    Term(V)[[ t ^ (s) : ty ]].
  Term(V)[[ Ascribe(t, sort) ^ (s) : ty ]] :=
    SortRef[[ sort ^ (s) : ty ]],
    Term(V)[[ t ^ (s) : ty ]].

  Term(V)[[ PathSrc(t) ^ (s) : SCOPE() ]] :=
    Term(V)[[ t ^ (s) : PATH(_) ]].
  Term(V)[[ PathDst(t) ^ (s) : SCOPE() ]] :=
    Term(V)[[ t ^ (s) : PATH(_) ]].
  Term(V)[[ PathScopes(t) ^ (s) : LIST(SCOPE()) ]] :=
    Term(V)[[ t ^ (s) : PATH(_) ]].
  Term(V)[[ PathDecl(t) ^ (s) : ty ]] :=
    Term(V)[[ t ^ (s) : PATH(ty) ]].

  Pos(V)[[ Position(v) ^ (s) ]] :=
    V[[ v ^ (s) : ty ]].

rules

  LabelRE[[ Empty() ^ (_) ]].
  LabelRE[[ Epsilon() ^ (_) ]].
  LabelRE[[ lbl@Label(_) ^ (s) ]] :=
    LabelRef[[ lbl ^ (s) ]].
  LabelRE[[ Closure(re) ^ (s) ]] :=
    LabelRE[[ re ^ (s) ]].
  LabelRE[[ Neg(re) ^ (s) ]] :=
    LabelRE[[ re ^ (s) ]].
  LabelRE[[ Concat(re1, re2) ^ (s) ]] :=
    LabelRE[[ re1 ^ (s) ]],
    LabelRE[[ re2 ^ (s) ]].
  LabelRE[[ And(re1, re2) ^ (s) ]] :=
    LabelRE[[ re1 ^ (s) ]],
    LabelRE[[ re2 ^ (s) ]].
  LabelRE[[ Or(re1, re2) ^ (s) ]] :=
    LabelRE[[ re1 ^ (s) ]],
    LabelRE[[ re2 ^ (s) ]].

rules

  Map1t(X)[[ [x|xs] ^ (s) : ty ]] :=
    X[[ x ^ (s) : ty ]],
    Map1t(X)[[ xs ^ (s) : ty ]].

  Map1t(X)[[ [] ^ (s) : _ ]].
