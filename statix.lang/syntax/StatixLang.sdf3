module StatixLang

imports

  Layout
  Common
  Sugar

template options

  keyword -/- [a-zA-Z0-9\_\-\']

context-free start-symbols

  Start

context-free syntax

  Start = Module


/******************************************************************
 * Modules                                                        *
 ******************************************************************/

context-free syntax

  Module.Module = <
    module <ID>

    <{Section "\n\n"}*>
  > {longest-match}

  Section.Signature = <
    signature

      <{Signature "\n\n"}*>
  > {longest-match}

  Signature.Sorts = <
    sorts
      <{SortDecl "\n"}*>
  > {longest-match}

  Signature.Constraints = <
    constraints
      <{CDecl "\n"}*>
  > {longest-match}

  Signature.Constructors = <
    constructors
      <{OpDecl "\n"}*>
  > {longest-match}

  Signature.Namespaces = <
    namespaces
      <{NsDecl "\n"}*>
  > {longest-match}

  Signature.Relations = <
    relations
      <{RelDecl "\n"}*>
  > {longest-match}

  Signature.NameResolution = <
    name-resolution
      <{ResolutionParam "\n"}*>
  > {longest-match}

  Section.Rules = <
    rules

    <{Rule "\n\n"}*>
  > {longest-match}

  Rule = <constraint <CDecl>>
  Rule = <relation <RelDecl>>
  Rule.Rule = <
    <UserConstraint> :- <LocalVars> <Constraint> | <Constraint>.
  >

  LocalVars.NoLocalVars = <>
  LocalVars.LocalVars   = <{<{Var " "}+>}>

/******************************************************************
 * Constraints                                                    *
 ******************************************************************/

context-free syntax

  RelDecl.RelDecl = <<{RelProp " "}*> <LCID> : <RelType> <RelKind>>

  RelType.SimpleRelation     = [[{SortRef " * "}+]]
  RelType.FunctionalRelation = [[{SortRef " * "}+] -> [SortRef]] // FIXME Turning SortRef into a list breaks parsing

  RelProp.Reflexive     = <reflexive>
  RelProp.Irreflexive   = <irreflexive>
  RelProp.Transitive    = <transitive>
  RelProp.NonTransitive = <non-transitive>
  RelProp.Symmetric     = <symmetric>
  RelProp.AntiSymmetric = <anti-symmetric>

  RelKind.GlobalRel       = <{global}>
  RelKind.ScopedRel       = <{scoped}>
  RelKind.DefaultRelScope =

syntax

  Constraint-CF.CAskGlobalRel  = "?" LCID-LEX "(" CommaTerms-CF ")"
  Constraint-CF.CTellGlobalRel = "!" LCID-LEX "(" CommaTerms-CF ")"

  Constraint-CF.CAskScopedRel  = "?" LCID-LEX "(" CommaTerms-CF ")" LAYOUT?-CF "in" LAYOUT?-CF Var-CF
  Constraint-CF.CNotScopedRel  = "?" LCID-LEX "(" CommaTerms-CF ")" LAYOUT?-CF "not" LAYOUT?-CF "in" LAYOUT?-CF Var-CF
  Constraint-CF.CTellScopedRel = "!" LCID-LEX "(" CommaTerms-CF ")" LAYOUT?-CF "in" LAYOUT?-CF Var-CF


/******************************************************************
 * Constraints                                                    *
 ******************************************************************/

context-free syntax

  Constraint.CTrue  = <true>
  Constraint.CFalse = <false>

  Constraint         = <(<Constraint>)> {bracket}
  Constraint.CConj   = <<Constraint>, <Constraint>> {left}
  Constraint.CNew    = <new <{Var " "}+>>
  Constraint.CDisamb = <<Term> disamb <Term>, <Term> : <Term> <WrappedClause>>

  WrappedClause.CScope = <{ <{Var " "}+>: <Constraint> }>
  WrappedClause        = <{ <Constraint> }>

  UserConstraint.C = [[ConstraintId]([{Term ", "}*])]

  Constraint                  = UserConstraint
  Constraint.CEqual           = [[Term] == [Term]]
  Constraint.CInequal         = [[Term] != [Term]]
  Constraint.CTellRightOccurrence = [[Term] -> [Term]]
  Constraint.CTellLeftOccurrence  = [[Term] <- [Term]]
  Constraint.CResolve         = [[Term] |-> [Term]]
  Constraint.CQuery           = [[Term] in [Term] |-> [Term]]

  CDecl.CDecl = [[ConstraintId] : [{CParam " * "}+] [CKind]]

  CKind.InductiveC   = <{inductive}>
  CKind.CoinductiveC = <{coinductive}>
  CKind.DefaultC     =

  CParam.Param = <<InOut> <SortRef>>

  InOut.In = "in"
  InOut.Out = "out"

syntax

  Constraint-CF.CTellRightEdge  = Term-CF LAYOUT?-CF "-" ELabel-CF "->" LAYOUT?-CF Term-CF
  Constraint-CF.CTellLeftEdge   = Term-CF LAYOUT?-CF "<-" ELabel-CF "-" LAYOUT?-CF Term-CF
  Constraint-CF.CTellRightNamed = Term-CF LAYOUT?-CF "=" NLabel-CF "=>" LAYOUT?-CF Term-CF
  Constraint-CF.CTellLeftNamed  = Term-CF LAYOUT?-CF "<=" NLabel-CF "=" LAYOUT?-CF Term-CF

  Constraint-CF.CAskRightEdge  = Term-CF LAYOUT?-CF "?-" ELabel-CF "->" LAYOUT?-CF Term-CF
  Constraint-CF.CAskLeftEdge   = Term-CF LAYOUT?-CF "?<-" ELabel-CF "-" LAYOUT?-CF Term-CF
  Constraint-CF.CAskRightNamed = Term-CF LAYOUT?-CF "?=" NLabel-CF "=>" LAYOUT?-CF Term-CF
  Constraint-CF.CAskLeftNamed  = Term-CF LAYOUT?-CF "?<=" NLabel-CF "=" LAYOUT?-CF Term-CF

lexical syntax

  ConstraintId = LCID
  ConstraintId = "true" | "false"
               | "new" | "disamb"
               | "inductive" |"coinductive" {reject}


/******************************************************************
 * Scope Graph                                                    *
 ******************************************************************/

context-free syntax

  ResolutionParam.Labels = <labels <{Label " "}*>>
  ResolutionParam.DefaultELabel = <default edge label <Label>>
  ResolutionParam.DefaultNLabel = <default named label <Label>>
  ResolutionParam.Strategy = <
    resolve <Occurrence> with
      <StrategyMatch>
      <StrategyDisamb>
  >
  ResolutionParam.OverrideStrategy = <
    override resolve <Occurrence> with
      <StrategyMatch>
      <StrategyDisamb>
  >

  StrategyMatch.NoMatch =
  StrategyMatch.Match   = <match(<Var>) :- <{Constraint " | "}+>.>

  StrategyDisamb.NoDisamb =
  StrategyDisamb.Disamb   = <disamb(<Var>, <Var>) :- <{Constraint ";"}+>.>

  Label.Label = LabelId

  ELabel               = Label
  ELabel.DefaultELabel = "-"

  NLabel               = Label
  NLabel.DefaultNLabel = "="

  LabelRef   = Label
  LabelRef.D = <D>

  LabelRE.Empty      = <0>
  LabelRE.Epsilon    = <e>
  LabelRE            = Label
  LabelRE.Closure    = <<LabelRE>*>
  LabelRE.Neg        = <~<LabelRE>>
  LabelRE.Concat     = <<LabelRE> <LabelRE>>     {right}
  LabelRE.And        = <<LabelRE> & <LabelRE>>   {left}
  LabelRE.Or         = <<LabelRE> | <LabelRE>>   {left}
  LabelRE            = <(<LabelRE>)>             {bracket}

  NsDecl.NsDecl = <<UCID>>

  LabelPairs          = <<{LabelPair ","}*>>
  LabelPair.LabelPair = [[LabelRef] < [LabelRef]]

syntax

  Term-CF.PathRef    = Term-CF "." "ref"
  Term-CF.PathScopes = Term-CF "." "scopes"
  Term-CF.PathDecl   = Term-CF "." "decl"

  Constraint-CF.CPathMatch  = "pathMatch" "[" LAYOUT?-CF LabelRE-CF LAYOUT?-CF "](" LAYOUT?-CF Term-CF LAYOUT?-CF ")"
  Constraint-CF.CPathLt     = "pathLt" "[" LAYOUT?-CF LabelPairs-CF LAYOUT?-CF "](" LAYOUT?-CF Term-CF LAYOUT?-CF "," LAYOUT?-CF Term-CF LAYOUT?-CF ")"

context-free priorities

    LabelRE.Neg
  > LabelRE.Closure
  > LabelRE.Concat
  > LabelRE.And
  > LabelRE.Or

lexical syntax

  ConstraintId = "pathMatch" | "pathDisamb" {reject}

  LabelId = UCID
  LabelId = "D" {reject}


/******************************************************************
 * Sorts & Constructors                                           *
 ******************************************************************/

context-free syntax

  SortDecl.SortDecl  = SortId
  SortDecl.SortAlias = <<SortId> = <SortRef>>

  Sort.SimpleSort = SortId

  SortRef                = Sort
  SortRef.ListSort       = <list(<SortRef>)>
  SortRef.TupleSort      = <(<{SortRef " * "}*>)>
  SortRef.IntSort        = "int"
  SortRef.StringSort     = "string"
  SortRef.PathSort       = "path"
  SortRef.OccurrenceSort = "occurrence"
  SortRef.ScopeSort      = "scope"

  OpDecl.OpDecl  = <<SID> : <OpSort>>

  OpSort.ConstOp = Sort
  OpSort.ArrowOp = [[{SortRef " * "}+] -> [Sort]]

lexical syntax

  SortId = UCID

  SortVarId = LCID
  SortVarId = "list" | "int" | "string" | "occurrence" | "scope" | "path" | "in" | "out" {reject}


/******************************************************************
 * Terms                                                          *
 ******************************************************************/

context-free syntax

  Var.Var = VARID
  Var.Wld = <_>

  Term            = Var
  Term.Int        = INT
  Term.List       = <[<{Term ", "}*>]>
  Term.ListTail   = <[<{Term ", "}*>|<Term>]>
  Term.Tuple      = <(<{Term ", "}*>)>
  Term            = Occurrence
  Term.As         = <<Var>@<Term>>
  Term.Ascribe    = <<Term> : <SortRef>>

  CommaTerms = <<{Term ", "}*>>
  SpaceTerms = <<{Term " "}*>>

syntax

  Term-CF.ListLength = Term-CF "." "length"
  Term-CF.Op         = UCID-LEX "(" LAYOUT?-CF CommaTerms-CF LAYOUT?-CF ")"
  Term-CF.Str        = "\"" StrChars-LEX "\""
  Term-CF.StrBuild   = "$" "[" StrBuild-CF* "]"

  StrBuild-CF.Str2 = StrBuildChars-LEX
  StrBuild-CF      = "[" LAYOUT?-CF Term-CF LAYOUT?-CF "]"

  Occurrence-CF.Occurrence = UCID-LEX "{" LAYOUT?-CF SpaceTerms-CF LAYOUT?-CF Position-CF LAYOUT?-CF "}"

  Position-CF.Position = "@" Var-CF

lexical syntax

  StrChars   = StrChar*
  StrChar    = ~[\"\\\t\r\n]
  StrChar    =  "\\\"" | "\\\\" | "\\t" | "\\r" | "\\n"

  StrBuildChars = StrBuildChar+
  StrBuildChar  = ~[\[\]\\\t\r\n]
  StrBuildChar  =  "\\[" | "\\]" | "\\\\" | "\\t" | "\\r" | "\\n"

lexical restrictions

  StrChars -/- ~[\"]

  StrBuildChars -/- ~[\[\]]
