module NaBLCore
imports common/Layout common/Identifiers terms/Terms core/Modules
        core/Namespaces core/Bindings

exports
  context-free start-symbols
    Start

  context-free syntax
    Module -> Start 

  context-free syntax
    "properties" PropertyDef*                    -> ModuleSection   {cons("Properties")}
    PropertyID "of" {NamespaceRef ","}+ ":" Sort -> PropertyDef     {cons("PropertyDef")}
    "type"                                       -> PropertyRef     {cons("TypeProp")}
    PropertyID                                   -> PropertyRef     {cons("PropertyRef")}
    "of" PropertyRef Term                        -> PropertyTerm    {cons("PropertyTerm")}
    "of" PropFilter PropertyRef Term             -> PropertyPattern {cons("PropertyPattern")}
                                                 -> PropFilter      {cons("Equal")}
    "conformant"                                 -> PropFilter      {cons("Conformant")}

  context-free syntax
    CONTENTCOMPLETE -> ModuleSection   {cons("COMPLETION-ModuleSection")}
    CONTENTCOMPLETE -> PropertyDef     {cons("COMPLETION-PropertyDef")}
    CONTENTCOMPLETE -> PropertyRef     {cons("COMPLETION-PropertyRef")}
    CONTENTCOMPLETE -> PropertyTerm    {cons("COMPLETION-PropertyTerm")}
    CONTENTCOMPLETE -> PropertyPattern {cons("COMPLETION-PropertyPattern")}
    CONTENTCOMPLETE -> PropFilter      {cons("COMPLETION-PropFilter")}

  lexical restrictions
    "properties" "type" "of" "conformant" -/- [a-zA-z]

  lexical syntax
    Id     -> PropertyID 
    "type" -> PropertyID {reject}

  context-free syntax
    "binding" "rules" BindingRule*        -> ModuleSection {cons("BindingRules")}
    Pattern Constraints ":" BindingClause -> BindingRule   {cons("BindingRule")}

  context-free syntax
    CONTENTCOMPLETE -> ModuleSection {cons("COMPLETION-ModuleSection")}
    CONTENTCOMPLETE -> BindingRule   {cons("COMPLETION-BindingRule")}

  lexical restrictions
    "binding" "rules" -/- [a-zA-z]

  context-free syntax
    DefKind "defines" Unique NamespaceRef Term "in" DefScopes -> BindingClause {cons("DefClause")}
                                                              -> DefKind       {cons("Explicit")}
    "implicitly"                                              -> DefKind       {cons("Implicit")}
    "unique"                                                  -> Unique        {cons("Unique")}
    "non-unique"                                              -> Unique        {cons("NonUnique")}
    "scopes" NamespaceRef                                     -> BindingClause {cons("ScopeClause")}
    "non-transitively" "scopes" NamespaceRef                  -> BindingClause {cons("NonTransitiveScopeClause")}

  context-free syntax
    CONTENTCOMPLETE -> DefKind       {cons("COMPLETION-DefKind")}
    CONTENTCOMPLETE -> Unique        {cons("COMPLETION-Unique")}
    CONTENTCOMPLETE -> BindingClause {cons("COMPLETION-BindingClause")}

  lexical restrictions
    "defines" "in" "implicitly" "unique" "non-unique" "non-transitively"
    "scopes" -/- [a-zA-z]

  context-free syntax
    "where" {Constraint "and"}+                                         -> Constraints {bracket}
    "when" {Constraint "and"}+                                          -> Conditions  {bracket}
    "true"                                                              -> Constraint  {cons("True")}
    Term "has" PropertyRef Pattern                                      -> Constraint  {cons("PropertyConstraint")}
    NamespaceRef Term "has" PropertyRef Pattern                         -> Constraint  {cons("RefPropertyConstraint"), avoid}
    Term "refers" "to" NamespaceRef Pattern PropertyPattern* InRefScope -> Constraint  {cons("ReferenceConstraint")}

  context-free syntax
    CONTENTCOMPLETE -> Constraints {cons("COMPLETION-Constraints")}
    CONTENTCOMPLETE -> Conditions  {cons("COMPLETION-Conditions")}
    CONTENTCOMPLETE -> Constraint  {cons("COMPLETION-Constraint")}

  lexical restrictions
    "where" "when" "true" "has" "refers" "to" -/- [a-zA-z]

  context-free syntax
    "into" -> Id {reject}

  context-free syntax
    MessageKind Term "on" Term Conditions -> BindingClause {cons("MessageClause")}
    "note"                                -> MessageKind   {cons("Note")}
    "warning"                             -> MessageKind   {cons("Warning")}
    "error"                               -> MessageKind   {cons("Error")}

  context-free syntax
    CONTENTCOMPLETE -> BindingClause {cons("COMPLETION-BindingClause")}
    CONTENTCOMPLETE -> MessageKind   {cons("COMPLETION-MessageKind")}

  lexical restrictions
    "on" "note" "warning" "error" -/- [a-zA-z]