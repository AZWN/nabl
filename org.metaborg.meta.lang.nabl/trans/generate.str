module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameBindingLanguage
  lib/editor-common.generated

rules
    
	generate-name-analysis:
		(selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-ppable-str; nabl-to-str> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

    to-ppable-str = alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)
	
overlays
	
	TERM(o, args) 		= NoAnnoList(Op(o, args))
	TERM(o)       		= NoAnnoList(Op(o, []))
	TUPLE(args)  	    = NoAnnoList(Tuple(args))
	LIST(elems)   		= NoAnnoList(List(elems))
	LIST(elems, tail) = NoAnnoList(ListTail(elems, tail))
	CALL(c)       		= CallNoArgs(SVar(c))
	CALL(c, args)    	= CallT(SVar(c), [], args)

	RULE(n, lhs, rhs, clauses)			 = RDefNoArgs(n, Rule(lhs, rhs, clauses))
	RULE(n, args, lhs, rhs, clauses) = RDefT(n, [], args, Rule(lhs, rhs, clauses))
	
overlays
	
	PATH        = DefaultVarDec("path__")	
	PATHS       = DefaultVarDec("scopes__")	
	PATHS'      = DefaultVarDec("scopes'__")	
	SUBSEQUENT  = DefaultVarDec("subsequent__")
	TARGET      = CALL("target__")
	LOOKUP_PATH = CALL("lookup-scope")
	
	DEF(uri)									= TERM("Def", [uri])
	DEF(ns, name, path) 			= TERM("Def", [ns, name, path])
	DEF_DATA(uri, kind, data) = TERM("DefData", [uri, TERM(kind), data])
	IMPORT(uri1, uri2)        = DEF_DATA(uri1, "Import", uri2)
	TIMPORT(uri1, uri2)       = DEF_DATA(uri1, "TImport", uri2)
	
overlays
	
	REGULAR(ns, n)              = TERM("Regular", [ns, n])
	REGULAR(ns, n, t)           = TERM("Regular", [ns, n, t])
	CHILD(ns, n, pns, p)        = TERM("Child", [ns, n, pns, p])
	CHILD(ns, n, pns, p, t)     = TERM("Child", [ns, n, pns, p, t])
	
	ANON                        = TERM("Anon", [App(CALL("newname"), NoAnnoList(Str("anon")))])
	SCOPE                       = TERM("Anon", [App(CALL("newname"), NoAnnoList(Str("scope")))])
	UNIQUE                      = TERM("Anon", [App(CALL("newname"), NoAnnoList(Str("unique")))])
	
	LOOKUP_PATH(nsv, paths) 	  = App(LOOKUP_PATH(), TUPLE([nsv, paths]))	
  
	LOOKUP_PATH(nsv, v, paths) 	= WhereClause(Assign(v, App(LOOKUP_PATH(), TUPLE([nsv, paths]))))	
  ANNOTATE(v)             		= CALL("nam-annotate", [v])
  ANNOTATE_USE(nss)           = CALL("nam-annotate-use", [PATHS'(), LIST(nss)])
  ANNOTATE_SCOPE(v)           = CALL("nam-annotate-scope", [LIST([v])])
	ANNOTATE_IMPORT(v)          = CALL("nam-annotate-use", [TERM("Unresolved", [v])])

  DEF_KEY_RULE(t, ks)         = RULE("nam-get-definition-keys", t, LIST(ks), [])
  USE_KEY_RULE(t, ks)         = RULE("nam-get-use-keys", t, LIST(ks), [])
  DEF_RULE(t, t', ds, is, cs) = RULE("nam-get-definitions", [PATHS(), PATHS'(), SUBSEQUENT()], t, TUPLE([RootApp(t'), LIST(ds), LIST(is)]), cs) 
	USE_RULE(t, t')             = RULE("nam-annotate-uses", [PATHS()], t, RootApp(t'), [])
	
overlays
	
	IMPORTS = 
		Imports(
			[ Import("lib/nabl-prelim") ]
		)
			
	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	
	VTARGET() = Var("reference__")
	ADJUST_LOOKUP(term, adjusts, clauses) = 
		RDefT(
			  "nam-resolve"
			, [DefaultVarDec("target__")]
			, []
			, Rule(
			  	  term
			  	, LIST(adjusts)
				, [WhereClause(App(TARGET(), VTARGET()))|clauses]
				)
  		)
    
rules
	
	to-stratego-term:
		cons#(args) -> TERM(cons, args)
    
  nonempty = where(Hd)

rules // modules
	
	nabl-to-str:
		Module(name, section*) -> Module(name, [IMPORTS()|<filter(nabl-to-str)> section*])
		
rules // namespace and property sections
			
	nabl-to-str:
		Namespaces(namespace*) -> Signature([Constructors(<map(nabl-to-str)> namespace*)])
		
	nabl-to-str:
		Properties(prop*) -> Signature([Constructors(<map(nabl-to-str)> prop*)])
	
	nabl-to-str: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
		
	nabl-to-str:
		Property(prop, _, _) -> CONS_DECL(prop, "Property")	

	nabl-to-str:
		Imports(_) -> <id>
		
rules // binding section
	
	nabl-to-str:
		BindingRules(rule*) -> Rules(<mapconcat(nabl-to-str); nonempty> rule*)

	nabl-to-str:
		rule@BindingRule(_, _) -> [vs-rule*, hs-rule*, def-rule*]
		where
			vs-rule*	:= <opt-rule(nabl-vertical-scope-rule)> rule;
			hs-rule*	:= <opt-rule(nabl-horizontal-scope-rule)> rule;
			def-rule* := <opt-rule(nabl-def-rule)> rule
			
	opt-rule(s) = s < MkSingleton + ![]		

	nabl-vertical-scope-rule:
		BindingRule(term, part*) -> RULE("nam-get-vscope", term, LIST(t*), [])
		where
			t* := <fetch-elem(nabl-vertical-scoped)> part*
	
	nabl-vertical-scoped:
		Scopes(ns*) -> <map(ns-to-term)> ns*
	
	nabl-horizontal-scope-rule:
		BindingRule(term, part*) -> RULE("nam-get-hscope", term, LIST(t*), [])
		where
			ns* := <collect(nabl-horizontal-scoped)> part*;
			t*  := <nonempty; map(ns-to-term)>
			
	nabl-horizontal-scoped:
		DefSite(_, NameBinding(ns, _), DefScopes(scope*), _, _) -> <ns-to-term> ns
		where
			<fetch-elem(?Subsequent())> scope*
	
	nabl-def-rule:
		BindingRule(term, part*) -> RULE("nam-get-defs", [PATHS(), PATHS'()], TUPLE([term, Var("defs")]), TUPLE([RootApp(term'), LIST(def*, Var("defs"))]), clause*)
		where
			replace1*				:= <filter(nabl-in-scope)> part*;
			(def*, clause*) := <filter(nabl-def); nonempty; unzip> part*;
			replace2*				:= <map(def-to-anno)> def*;
			term'						:= <replace-all(|[replace1*, replace2*])> term

	nabl-def: 
		DefSite(_, NameBinding(ns, name), _, DefScopes([Current()]), _) -> (DEF(nst, name, v), LOOKUP_PATH(nst, v, PATHS()))
		where
			v		:= Var(<newname> "scope");
			nst := <ns-to-term> ns

	nabl-def: 
		DefSite(_, NameBinding(ns, name), _, _, _) -> (DEF(nst, name, v), LOOKUP_PATH(nst, v, PATHS'()))
		where
			nst := <nabl-horizontal-scoped>;
			v		:= Var(<newname> "scope")

	nabl-def: 
		DefSite(_, NameBinding(ns, name), _, DefScopes(_), _) -> (DEF(nst, name, v), LOOKUP_PATH(nst, v, PATHS'()))
		where
			not(nabl-horizontal-scoped);
			nst := <ns-to-term> ns;
			v		:= Var(<newname> "scope")

	nabl-in-scope:
		DefScope(t) -> (t, ANNOTATE(t))
		
	nabl-use:
		UseSite(ref*) -> <filter(nabl-use)> ref* 
	
	nabl-use:
		Reference(NameBinding(ns, name), _, RefScope(Current()), _) -> LOOKUP_PATH(nst, v, PATHS())
		where
			v		:= Var(<newname> "path");
			nst := <ns-to-term> ns
	
	def-to-anno:
		d@DEF(_, name, _) -> (name, ANNOTATE(d))
	
	ns-to-term:
		NamespaceRef(namespace) -> TERM(namespace)

	replace-all(|replacement*) = alltd(replace(|replacement*) <+ introduce-id)
	
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()

/*
			
	nabl-def-clause(|replaces): 
		ND-Def(_, Binding(ns, name), _, scope, _) -> LOOKUP_PATH(nsv, v, [name | path])
		where
			v			:= Var(<newname> "uri");
			nsv   := <namespace-to-term> ns;
			path  := <nabl-scope-path(|v, replaces)> scope;
			<iset-add(|(name, ANNOTATE_DEF(v)))> replaces

	nabl-scope-path(|v, replaces):
		DefScope(scope*) -> [SCOPE()]
		where
			annos := <map(!(<id>, ANNOTATE_SCOPE(v)))> scope*;
			<iset-addlist(|annos)> replaces
	
	nabl-scope-path(|v, replaces):
		Current() -> []
		
rules 
													
	nabl-to-str-old:
		ND-Rule(term, part*) -> rule5*
		with
			replaces := <new-iset> ;
			dkey*    := <collect(nabl-def-key)> part* ;
			ukey*		 := <collect(nabl-use-key)> part* ;
			(dkey*, ukey*, def*, imp*, clause*, rule*) := <map(nabl-to-intermediate(|term, replaces)); unzip4> part*;
			if <nonempty> dkey* then
				rule1* := [DEF_KEY_RULE(term, dkey*)|rule*]
			else
		    rule1* := rule*
		  end;
		  if <nonempty> ukey* then
		  	ukey'* := <map(!Var(<newname> "key"))> ukey* ;
		  	repl*  := <zip(\(k, k') -> (k, As(k', k))\)> (ukey*, ukey'*);
		  	term'  := <alltd(replace(|repl*))> term ;
				rule2* := [USE_KEY_RULE(term', ukey'*)|rule1*]
			else
		  	rule2* := rule1*
		  end;
		  if replace* := <iset-elements; nonempty> replaces then
		  	term'' := <alltd(replace(|replace*) <+ introduce-id)> term;
				rule3* := [DEF_RULE(term, term'', def*, imp*, clause*)|rule2*]
			else
				rule3* := rule2*
			end;
			if ordered* := <filter(ordered-scope); concat; nonempty> part* then
				rule4* := [RULE("nam-ordered-def", term, LIST(ordered*), [])|rule3*]
			else
				rule4* := rule3*
			end;
			var := Var(<newname> "anon");
			if scope* := <filter(to-scope(|var)) ; concat; nonempty> part* then
				rule5* := [RULE("nam-get-scope-types", term, LIST(scope*), [WhereClause(Assign(var, UNIQUE()))])|rule4*]
			else
				rule5* := rule4* 
			end
	
	nabl-def-key: ND-Def(_, Binding(_, name), _, _, _) -> name
	nabl-use-key: Reference(Binding(_, name), _, _, _) -> name
	
	nabl-def-clause(|replaces): 
		ND-Def(_, Binding(ns, name), _, scope, _) -> LOOKUP_PATH(nsv, v, [name | path])
		where
			v			:= Var(<newname> "uri");
			nsv   := <namespace-to-term> ns;
			path  := <nabl-scope-path(|v, replaces)> scope;
			<iset-add(|(name, ANNOTATE_DEF(v)))> replaces

	nabl-scope-path(|v, replaces):
		DefScope(scope*) -> [SCOPE()]
		where
			annos := <map(!(<id>, ANNOTATE_SCOPE(v)))> scope*;
			<iset-addlist(|annos)> replaces
	
	nabl-scope-path(|v, replaces):
		Current() -> []
					
	to-reference-part:
		Reference(Binding(ns, name), [], Current(), clause*) -> (name, nst, REGULAR(nst, VTARGET()), clause'*)
		with
			nst      := <namespace-to-term> ns;
			clause'* := <filter(to-type-clause)> clause*

	// to-reference-part:
	// 	Reference(Binding(ns, name), TypeBinding(t), None(), clause*) -> (name, nst, REGULAR(nst, VTARGET(), t), clause'*)
	// 	with
	// 		nst      := <namespace-to-term> ns;
	// 		clause'* := <filter(to-type-clause)> clause*

	to-reference-part:
		Reference(Binding(ns, name), [], RefScope(Binding(pns, parent)), clause*) -> (name, nst, CHILD(nst, VTARGET(), pnst, parent), clause'*)
		with
			nst      := <namespace-to-term> ns;
			pnst     := <namespace-to-term> pns;
			clause'* := <filter(to-type-clause)> clause*
			
	// to-reference-part:
	// 	Reference(Binding(ns, name), TypeBinding(t), RefScope(pns, parent), clause*) -> (name, nst, CHILD(nst, VTARGET(), pnst, parent, t), clause'*)
	// 	with
	// 		nst      := <namespace-to-term> ns;
	// 		pnst     := <namespace-to-term> pns;
	// 		clause'* := <filter(to-type-clause)> clause*
			
	nabl-to-intermediate(|term, replaces):
		ND-Import(ns*, ref, scope) -> ([], [name], [], term*, [clause|clause*], [ADJUST_LOOKUP(rterm, [resolution], clause*)])
		with
			v      := Var(<newname> "import");
			v*     := <map(!Var(<newname> "uri"))> ns*;
			(name, ns, resolution, clause*) := <to-reference-part> ref;
  	  rterm  := <alltd(replace(|[(name, As(VTARGET(), name))]))> term;
			nsv    := <namespace-to-term> ns;
			clause := WhereClause(Assign(v, App(ANNOTATE_USE([nsv]), name)));
			<iset-add(|(name, Build(v)))> replaces;
			if <?DefScope(scope*)> scope then
			  (term*, clause*) := <zip(import-to-data(|nsv, v, [SCOPE()])); unzip> (ns*, v*);
				<iset-addlist(|<map(to-scope-replacement(|v*))> scope*)> replaces
			else
			  (term*, clause*) := <zip(import-to-data(|nsv, v, [])); unzip> (ns*, v*)
			end	
	
	nabl-to-intermediate(|term, replaces):
		ND-Ref(ref*) -> ([], [name], [], [], [], [ADJUST_LOOKUP(rterm, resolution*, clause*)])
	  with
	  	([name|_], ns*, resolution*, clause*) := <map(to-reference-part); unzip4'> ref*;
	  	rterm := <alltd(replace(|[(name, As(VTARGET(), name))]))> term;
			<iset-add(|(name, ANNOTATE_USE(ns*)))> replaces
  	

	import-to-data(|nsv, v, anon):
		(TransitiveImport(ns), v') -> (TIMPORT(v', v), LOOKUP_PATH'(nsv', v', [nsv'|anon]))
		where
			nsv' := <namespace-to-term> ns
			
	import-to-data(|nsv, v, anon):
		(Import(ns), v') -> (IMPORT(v', v), LOOKUP_PATH'(nsv', v', [nsv'|anon]))
		where
			nsv' := <namespace-to-term> ns
		
	unzip4: [] -> ([], [], [], [])
	unzip4: [(h1*, h2*, h3*, h4*)|t] -> ([h1*, t1*], [h2*, t2*], [h3*, t3*], [h4*, t4*]) where (t1*, t2*, t3*, t4*) := <unzip4> t
	
	to-scope-replacement(|v):
		scope -> (scope, ANNOTATE_SCOPE(v))

rules
			
	unzip4': [] -> ([], [], [], [])
	unzip4': [(h1, h2, h3, h4*)|t] -> ([h1|t1], [h2|t2], [h3|t3], [h4*, t4*]) where (t1, t2, t3, t4*) := <unzip4'> t
	
rules
		
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
		        
rules
					
	ordered-scope:
		ND-Def(_, Binding(ns, _), _, Subsequent(), _) -> [<namespace-to-term> ns]
	
	ordered-scope:
		ND-Import(ns*, _, Subsequent()) -> <map(inamespace-to-term)> ns*
		
	to-scope(|var): 
		ND-Def(unique, Binding(ns, name), _, scope*, _) -> <map(scope-to-term(|anon, <namespace-to-term> ns, name))> scope*
		with
			if Unique() := unique then
				anon := var
			else
				anon := TUPLE([])
			end
			
	to-scope(|var):
		ND-Scope(scope*) -> <map(scope-to-term)> scope*
	
	scope-to-term:
		scope -> TUPLE([t, ANON(), t, TUPLE([])])
		with 
			t := <namespace-to-term> scope
			
	scope-to-term(|unique, ns, name):
		scope -> TUPLE([ns, name, <namespace-to-term> scope, unique])
			
	namespace-to-term:
		NamespaceRef(namespace) -> TERM(namespace)

	inamespace-to-term = 
		(?TransitiveImport(<id>) + ?Import(<id>));
		namespace-to-term
		
rules
		
	// to-type-rules(|term):
	// 	ND-Def(_, Binding(ns, name), TypeBinding(type), _, clause*) -> RULE("nam-get-type", term, TUPLE([name, type]), clause'*)
	// 	with
	// 		clause'* := <filter(to-type-clause)> clause*
		
rules
					
	to-type-clause: 
	 	Constraint(term, Property("type", type)) -> WhereClause(Assign(type, App(CALL("type-of"), term)))

	to-resolve-clause:
		Constraint(term, Reference(NamespaceRef(ns), name, None(), None())) -> WhereClause(Assign(TERM("Def", [LIST([TERM(ns)], name)]), App(Seq(CALL("index-find-key"), CALL("index-lookup")), term)))
*/
