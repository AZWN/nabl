module generation/propositions

imports 
  
  include/NameBindingLanguage
  libstrc
  
  generation/-

rules
  
  formula-to-tasks(|dep, r) = formula-to-tasks(|dep)
  
  formula-to-tasks(|dep): 
    True()  -> NEW_TASK(dep, TERM("Id", [TUPLE([])]))
  
  formula-to-tasks(|dep): 
    False() -> NEW_TASK(dep, TERM("Fail", []))
   
  formula-to-tasks(|dep): 
    Eq(v, t) -> NEW_TASK(dep, TERM("Eq", [t, v]))
	
	formula-to-tasks(|dep):
    DefOf(v, d) -> Assign(d, NEW_TASK(dep, TERM("CollectDefs", [v])))
    
  formula-to-tasks(|dep):
    RefersTo(v, ns) -> NEW_TASK(dep, TERM("CheckDefs", [ns', App(COLLECT_USE(), v)]))
    with
      ns' := <ns-to-term> ns
      
  formula-to-tasks(|dep):
    Property(v1, p, v2) -> Assign(v2, NEW_TASK(dep, TERM("Id", [TASK("get-or-create-property-task", [p'], v1)])))
    with
      p':= <prop-to-term> p
      
rules
	
	formula-to-tasks(|dep, r):
    Match(v, p) -> result 
    with 
	     v*     := <collect(?Var(_) + ?ListVar(_))> p
	   ; result := <not(?[]); map(var-to-match-task(|dep, r, v, p)); to-seq> v*
	  <+ <add-rule(?key|p)> r
	   ; result := NEW_TASK(dep, TERM("Rewrite", [key, v]))
  
  var-to-match-task(|dep, r, t, p):
  	v -> Assign(v, NEW_TASK(dep, TERM("Rewrite", [key, t])))
    with
    	r' := <add-rule(?key|p, v)> r
    
  add-rule(key|p):
    r -> <iset-add(|MATCH_RULE(key, p))> r
    with 
      key := $[match[<iset-elements; length> r]]
  
  add-rule(key|p, v):
    r -> <iset-add(|MATCH_RULE(key, p, v))> r
    with 
      key := $[match[<iset-elements; length> r]]
   
overlays
	
	TASK(s, t)      = TASK(s, [], t)
  TASK(s, ts, t)  = App(CALL(s, [CTX()|ts]), t)
  NEW_TASK(dep, task) = App(CALL("new-task", [CTX(), LIST(dep)]), task)
  COLLECT_USE = CALL("try", [ Seq(CALL("nabl-collect-use"), Match(TERM("Use", [RootApp(Id())])))])
	
  MATCH_RULE(key, lhs)      = SDefNoArgs("task-rewrite", Match(TUPLE([key, TUPLE([lhs, LIST([])])])))
  MATCH_RULE(key, lhs, rhs) = RDefNoArgs("task-rewrite", RuleNoCond(TUPLE([key, TUPLE([lhs, LIST([])])]), rhs))
