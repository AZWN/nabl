module generation/scoping-sites

imports
  libstrc
  include/NameBindingLanguage
  
  generation/util
  generation/sections
  generation/prop-sites
  
rules 
  
  // anonymous scope
  binding-to-scope-rules:
    BindingRule(pattern, constr*, clause*) -> [SCOPE_RULE(pattern, seq), q*]
    where
      cong* := <filterconcat(to-scope-cong(|pattern))> clause*
    where
       // scopes at least one namespace
       ns-term* := <filterconcat(?ScopeClause(<map(ns-to-term)>)); nonempty> clause*
       // but does not define any explicit name
     ; <not(fetch-elem(?DefClause(Explicit(), _, _, _, _, _, _)))> clause*
     ; anon* := [SCOPE_CALL(ns-term*)]
     ; q*    := [QUERY_SCOPE_RULE(pattern, ns-term*)]
    <+ anon* := []
     ; q*    := []
    where
      seq := <nonempty; to-seq> [cong*, anon*] 
  
  // named scope
  binding-to-scope-rules:
    BindingRule(pattern, constr*, clause*) -> [QUERY_SCOPE_RULE(pattern, ns-term*)]
    where
      cong* := <filterconcat(to-scope-cong(|pattern))> clause*
    where
      // scopes at least one namespace 
      ns-term* := <filterconcat(?ScopeClause(<map(ns-to-term)>)); nonempty> clause*
      // does define an explicit name
    ; <fetch-elem(?DefClause(Explicit(), _, _, _, _, _, _))> clause*
    
  to-scope-cong(|pattern):
    _ -> <filterconcat(to-scope-cong(|pattern)); nonempty> part*
    where
      ?RefClause(part*)
    + ?ImportClause(part*)
    
  to-scope-cong(|pattern):
    _ -> [cong1*, cong2*]
    where
       ?DefClause(_, _, ns, term, _, into, _)
     ; ns* := [ns]
    <+ ?RefClausePart(_, ns, _, _, from, _)
     ; ns* := [ns]
    <+ ?SingleImport(_, ns, _, _, from, _, into, _)
     ; ns* := [ns]
    <+ ?WildcardImport(import*, _, from, into, _)
     ; ns* := <map(?Restricted(_, <id>)); make-set> import*
    where
       ns-term* := <map(ns-to-term)> ns*
    where
       repl   := (<collect-one(?RefScope(<id>))> from, SCOPE_CALL(ns-term*))
     ; cong1* := [<add-force-origins; replace-all-id(|[repl])> pattern]
    <+ cong1* := []
    where
    	 scope* := <?DefScopes(<filter(?DefScope(<id>))>); nonempty> into
     ; repl*  := <map(!(<id>, SCOPE_CALL(ns-term*)))> scope*
     ; cong2* := [<add-force-origins; replace-all-id(|repl*)> pattern]
    <+ cong2* := []
 
 /**
  * scope-to-term transforms NaBL scope definition into a Stratego term for consumption by the NaBL runtime
  *
  * NaBL input     : defines   ... in current scope
  * NaBL input     : refers to ... in current scope
  * Stratego output: Current()
  * 
  * NaBL input      : defines ... in subsequent scope
  * Stratego output : [Subsequent()]
  *
  * NaBL input      : defines ... in ctx1, ..., ctxn
  * Stratego output : [DefScope(ctx1), ..., DefScope(ctxn)]
  *
  * NaBL input      : defines ... in subsequent scope, ctx1, ..., ctxn
  * Stratego output : [Subsequent(), DefScope(ctx1), ..., DefScope(ctxn)]
  *
  * NaBL input      : refers to ... in enclosing Namespace
  * Stratego output : Enclosing(NablNsNamespace())
  *
  * NaBL input      : refers to ... in ctx
  * Stratego output : scope-i
  *
  */

  scope-to-term: Current()      -> TERM("Current")
  scope-to-term: Subsequent()   -> TERM("Subsequent")
  scope-to-term: DefScopes(ds*) -> LIST(<map(scope-to-term)> ds*)
  scope-to-term: DefScope(term) -> TERM("DefScope", [term])
  scope-to-term: Enclosing(ns)  -> TERM("Enclosing", [<ns-to-term> ns])
  scope-to-term: RefScope(term) -> TERM("RefScope", [term])
    
  scope-to-term:
    Context(disamb, ns, term, prop*, ctx) -> TERM("Context", [ns-term, term, LIST(prop-term*), ctx-term])
    where
      ns-term    := <ns-to-term> ns
    ; prop-term* := <map(prop-to-str(|[]))> prop*
    ; ctx-term   := <scope-to-term> ctx
  
overlays
  
  QUERY_SCOPE_RULE(pattern, ns) = SDefNoArgs("nabl-get-scope", Seq(Match(pattern), Build(LIST(ns))))
  
  SCOPE_RULE(pattern, body) = SDefNoArgs("nabl-scoping-site", Seq(Match(pattern), body))
  SCOPE_CALL(ns)            = CallT(SVar("nabl-scope"), [], [LIST(ns)])
 
   
