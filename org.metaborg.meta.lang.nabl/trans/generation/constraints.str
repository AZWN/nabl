module generation/constraints

imports 
  
  libstrc
  include/NameBindingLanguage
  generation/util
  generation/main
  
rules
  
  constraints-to-str(|replace*, bound*, rule*, task*) = 
    !(<id>, task*);
    foldl(constraint-to-str(|replace*, bound*, rule*))
    
  constraint-to-str(|replace*, bound*, rule*):  
    (PropertyConstraint(t1, p, t2), cs*) -> [cs*, PROP_TASK(r, <nabl-to-str> p, t1'), match*]
    where
      t1' := <alltd(replace(|replace*))> t1;
      // create new task for property calculation
      n   := <length> cs*;
      r   := Var($[r[n]]);
      if 
        Var(v) := t2;
        <not(iset-contains(|t2))> bound* 
     then // single unbound variable is replaced with result
        <hashtable-put(|Var(v), r)> replace*;
        <iset-add(|Var(v))> bound*;
        match* := []
      else
      	var*   := <collect-all(?Var(_))> t2;
      	bvar*  := <isect> (var*, <iset-elements> bound*);
      	bvar'* := <alltd(replace(|replace*))> bvar*;
      	match* := <map-with-index(match-to-str(|replace*, bound*, rule*, t2, r, bvar*, bvar'*, n))> var*
      end
  
   match-to-str(|replace*, bound*, rule*, term, res, bvar*, bvar'*, n):
  	(i, Var(v)) -> MATCH_TASK(r, mn, bvar'*, res)
    where
    	mn     := NoAnnoList(Str(<newname; double-quote> "match"));
    	n'     := <addi> (n, i);
    	r      := Var($[r[n']]);
    	<hashtable-put(|Var(v), r)> replace*;
    	<iset-add(|Var(v))> bound*;
    	<iset-add(|MATCH_RULE(mn, term, bvar*, Var(v)))> rule*
      
overlays
    
  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("task-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))

  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
  
  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
  
  NEW_TASK(t) =
  App(
    CallT(SVar("new-task"), [], [Var("partition")])
  , t
  )