module generation/sections

imports
  
  libstrc
  include/NameBindingLanguage
  lib/editor-common.generated
  
  generation/-
    
rules // namespaces 
      
  nabl-to-str:
    Namespaces(namespaces) -> [Signature([Constructors(<map(ns-to-constructor)> namespaces)])]
    
  ns-to-constructor: // generates constructors for namespaces
    NamespaceDef(ns) -> CONS_DECL(<ns-name> ns, "Namespace")
  
  ns-to-term: NamespaceRef(ns) -> TERM(<ns-name> ns)

  ns-name: ns -> $[NablNs[ns]]
  
rules // properties
        
  nabl-to-str:
    Properties(prop*) -> [Signature([Constructors(cons*)]), Rules([rule, rule*])]
    where
    	cons* := <map(nabl-to-str)> prop*
    ; rule  := SDef("nabl-custom-properties", [DefaultVarDec("add-properties")], Seq(Build(LIST(<map(?PropertyDef(<id>, _, _); ns-prop-name-to-str; !TERM(<id>))> prop*)), CallNoArgs(SVar("add-properties"))))
    ; rule* := <mapconcat(prop-to-rules)> prop*
  
  nabl-to-str: // generate constructors for properties
    PropertyDef(p, _, _) -> CONS_DECL(<ns-prop-name-to-str> p, "Property") 

  nabl-to-str: PropertyRef(p) -> TERM(<ns-prop-name-to-str> p)
  nabl-to-str: TypeProp()     -> TERM("Type")

  ns-prop-name-to-str: p -> $[NablProp_[p]]

  prop-to-rules:
  	PropertyDef(p, _, _) -> PROP_RULES(p, TERM(<ns-prop-name-to-str> p), $[[p]-is], $[[p]-list], $[[p]-lookup], $[[p]-match], $[[p]-of], $[store-[p]])
  	
overlays
	
	PROP_RULES(p, pt, p-is, p-list, p-lookup, p-match, p-of, store-p) =
	[ SDefT(
	    p-is
	  , []
	  , [DefaultVarDec("task*")]
	  , CallT(
	      SVar("nabl-prop-calc")
	    , []
	    , [Var("task*"), NoAnnoList(List([]))]
	    )
	  )
	, SDefT(
      p-is
    , []
    , [DefaultVarDec("task*"), DefaultVarDec("dep*")]
    , CallT(
        SVar("nabl-prop-calc")
      , []
      , [Var("task*"), Var("dep*")]
      )
    )
  , SDefT(
      p-list
    , []
    , [DefaultVarDec("task*")]
    , CallT(
        SVar("nabl-prop-list")
      , []
      , [Var("task*"), NoAnnoList(List([]))]
      )
    )
  , SDefT(
      p-list
    , []
    , [DefaultVarDec("task*"), DefaultVarDec("dep*")]
    , CallT(
        SVar("nabl-prop-list")
      , []
      , [Var("task*"), Var("dep*")]
      )
    )
  , SDefT(
	    p-lookup
	  , []
	  , [DefaultVarDec("task*")]
	  , CallT(
	      SVar("nabl-prop-lookup")
	    , []
	    , [ pt
	      , Var("task*")
	      , NoAnnoList(List([]))
	      ]
	    )
	  )
	, SDefT(
	    p-lookup
	  , []
	  , [DefaultVarDec("task*"), DefaultVarDec("dep*")]
	  , CallT(
	      SVar("nabl-prop-lookup")
	    , []
	    , [ pt
	      , Var("task*")
	      , Var("dep*")
	      ]
	    )
	  )
	, SDefT(
      p-match
    , []
    , [DefaultVarDec("task*"), DefaultVarDec("expected")]
    , CallT(
        SVar("nabl-prop-match")
      , []
      , [pt, Var("task*"), TERM("Eq"), Var("expected")]
      )
    )
  , SDefT(
      p-match
    , []
    , [DefaultVarDec("task*"), DefaultVarDec("relation"), DefaultVarDec("expected")]
    , CallT(
        SVar("nabl-prop-match")
      , []
      , [pt, Var("task*"), Var("relation"), Var("expected")]
      )
    )
  , SDefT(
      p-of
    , []
    , [DefaultVarDec("task*")]
    , Fail()
    )
  , SDefNoArgs(
	    p-of
	  , CallT(
	      SVar("get-property")
	    , []
	    , [pt]
	    )
	  )
	, SDefT(
		  store-p
		, []
		, [DefaultVarDec("partition"), DefaultVarDec("prop")]
		, CallT(
		    SVar("nabl-store-prop")
		  , []
		  , [ Var("partition")
		    , TERM("Prop", [pt, Var("prop"), LIST([])])
		    ]
		  )
		)
  , RDefT(
		  "create-property-task"
		, []
		, [DefaultVarDec("partition")]
		, RuleNoCond(
		    NoAnnoList(
		      Tuple([pt, Var("term")])
		    )
		  , App(
		      CallT(SVar(p-of), [], [Var(ListVar("partition"))])
		    , Var("term")
		    )
		  )
	  )
	]

rules // imports
    
  nabl-to-str:
  	Imports(import*) -> <MkSingleton> Imports(import'*)
  	with
			if nabl-uses-custom-library(|<project-path>) then
				![ ImportWildcard("lib/nabl")
				 , ImportWildcard("lib/task")
				 , ImportWildcard("lib/properties")
				 , ImportWildcard("lib/types")
				 , ImportWildcard("lib/editor")
				 | import*
				 ]
			else
				![ ImportWildcard("lib/runtime/nabl")
				 , ImportWildcard("lib/runtime/task")
				 , ImportWildcard("lib/runtime/properties")
				 , ImportWildcard("lib/runtime/types")
				 , ImportWildcard("lib/runtime/editor")
				 | import*
				 ]
			end => import'*
    
    nabl-uses-custom-library(|project-path) = <file-exists> $[[project-path]/lib/nabl/collect.str]
    nabl-uses-custom-library(|project-path) = <file-exists> $[[project-path]/lib/task/core.str]
    nabl-uses-custom-library(|project-path) = <file-exists> $[[project-path]/lib/analysis/core.str]
    
rules // binding rules

  nabl-to-str:
    BindingRules(rs) -> [Rules(<map-with-index(to-rules); concat; nonempty> rs)]
    
  to-rules:
    (i, rule@BindingRule(pattern, constr*, clause*)) -> [b*, n*, d*, p*, u*, i*, m1*, m2*, msg*]
    with 
       b* := <binding-to-scope-rules> rule 
    <+ b* := [] 
    with 
       n* := [<binding-to-name-rule> rule] 
    <+ n* := [] 
    with
       d* := <binding-to-def-rules> rule 
    <+ d* := [] 
    with
       bound*         := <bound-vars> pattern
     ; (task*, repl*) := <constraints-to-tasks(|bound*, i, 0)> (constr*, [])
    with 
       p* := [<binding-to-prop-rule(|bound*, task*, repl*)>]
    <+ p* := []
    with 
       u* := [<binding-to-use-rule(|bound*, task*, repl*)>]
    <+ u* := []
    with 
       i* := [<binding-to-import-rule(|bound*, task*, repl*)>]
    <+ i* := []
    with
       m1* := <constraints-to-match-rules(|bound*, i, 0)> constr*
     ; m2* := <filter-with-index(to-match-rules(|bound*, i)); concat> clause*
    with 
       msg* := [<binding-to-msg-rule(|bound*, task*, repl*)>]
    <+ msg* := []
    