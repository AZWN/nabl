module generation/def-sites

imports
  
  libstrc
  include/NameBindingLanguage
  
  generation/-
  
rules
  
  def-to-name = ?DefClause(Explicit(), _, _, <id>, _, _, _)
    
rules
  
  binding-to-name-rule: 
    BindingRule(pattern, constr*, clause*) -> NAME_RULE(pattern, name)
    where
      [name] := <filter(def-to-name + use-to-name)> clause*
    where
      <not(eq)> (name, pattern)
      
  binding-to-apply-rule:
  	BindingRule(pattern, constr*, clause*) -> APPLY_RULE(body)
  	where
      [name]          := <filter(def-to-name + use-to-name)> clause*;
  		Var(inner-name) := name;
  		body            := <op-to-call(|inner-name)> pattern
  		
	op-to-call(|name) =
		switch id
		  case ?NoAnnoList(ops)                 : <op-to-call(|name)> ops
		  case ?Op(aname, args)                 : !Call(SVar(aname), <map(op-to-call(|name))> args)
		  case ?Var(name) + ?Var(ListVar(name)) : !CallNoArgs(SVar("s"))
		  otherwise                             : !Id()
		end
      
  binding-to-def-rules:
    BindingRule(pattern, constr*, clause*) -> [DEF_RULE(pattern, seq), ext*]
    where
      def-clause* := <filter-def-clauses; nonempty> clause*
    ; implicit*   := <implicit-def-vars> def-clause*
    ; ns-term*    := <filterconcat(?ScopeClause(<map(ns-to-term)>))> clause*
    ; nt-ns-term* := <filterconcat(?NonTransitiveScopeClause(<map(ns-to-term)>))> clause*    
    ; cong*       := <filter-with-index(to-def-cong(|pattern, ns-term*, nt-ns-term*))> def-clause*
    ; m           := <length> def-clause*
    ; uri-cvar    := <uri-child-var> m
    ; uri-svar    := <uri-sibl-var> m
    ; seq         := <to-seq> [ cong*
                              , MATCH(CALL("child-uris__"), uri-cvar)
                              , MATCH(CALL("sibl-uris__"), uri-svar)
                              , MATCH(CALL("implicits__"), LIST(implicit*))
                              ] 
    ; ext*        := <filter(to-external-rule(|pattern))> def-clause*  
                             
  to-external-rule(|pattern):
  	DefClause(_, _, _, term, _, DefScopes(scope*), _) -> EXTERNAL_DEF_RULE(pattern, cong)
  	where
  		repl* := <filter(?DefScope(<!(<id>, ALIAS_CALL)>)); nonempty> scope*
    ; cong  := <add-force-origins; replace-all-id(|[(term, EXTERNAL_DEF_CALL), repl*])> pattern
  
  to-def-cong(|pattern, scope*, nt-scope*):
    (o, clause) -> def-cong
    where
      DefClause(Explicit(), unique, ns, term, _, scope, _) := clause
    ; scope'*    := scope*
    ; nt-scope'* := nt-scope*
    + DefClause(Implicit(), unique, ns, term, _, scope, _) := clause
    ; scope'*     := []
    ; nt-scope'*  := []
    ; impl-var    := <implicit-def-var> o 
    + SingleImport(_, ns, _, _, _, Alias(term), scope, _)  := clause
    ; unique     := Unique()
    ; scope'*    := [] // TODO is this correct?
    ; nt-scope'* := [] // TODO is this correct?
    where
      ns-term     := <ns-to-term> ns
    ; unique-term := <nabl-to-str> unique
    ; scope-term  := <scope-to-term> scope
    ; i           := <dec> o
    ; uri-cvar1   := <uri-child-var> i
    ; uri-cvar2   := <uri-child-var> o
    ; uri-svar1   := <uri-sibl-var> i
    ; uri-svar2   := <uri-sibl-var> o
    ; def-call    := DEF_CALL(ns-term, unique-term, scope-term, scope'*, nt-scope'*, uri-cvar1, uri-svar1, uri-cvar2, uri-svar2)
    where
       def-cong := Where(Assign(impl-var, App(def-call, term)))
    <+ def-cong := <add-force-origins; replace-all-id(|[(term, def-call)])> pattern
  
rules
  
  filter-def-clauses =
    filter(
      ?DefClause(_, _, _, _, _, _, _) 
    + ?Import(<fetch-elem(?SingleImport(_, _, _, _, _, Alias(_), _, _))>)
    )
      
  implicit-def-vars = 
    filter-with-index(
      ?(<implicit-def-var>, DefClause(Implicit(), _, _, _, _, _, _))
    )
    
  implicit-def-var = !Var($[i-[<id>]__])
  
  nabl-to-str: NonUnique() -> TERM("NonUnique")
  nabl-to-str: Unique()    -> TERM("Unique")
  
  uri-var(|kind): 0 -> Var($[uri__])
  uri-var(|kind): i -> Var($[[kind]-uri[i]__]) where not(?0)
   
  uri-child-var = uri-var(|"c")
  uri-sibl-var  = uri-var(|"s")

			  
overlays
  
  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
  
  APPLY_RULE(body) = SDef("nabl-name-apply", [DefaultVarDec("s")], body)
  
overlays
  
	DEF_RULE(pattern, body) =
  SDefT(
    "nabl-def-site"
  , [ DefaultVarDec("child-uris__")
    , DefaultVarDec("sibl-uris__")
    , DefaultVarDec("implicits__")
    ]
  , [ DefaultVarDec("lang__")
    , DefaultVarDec("partition__")
    , DefaultVarDec("uniques__")
    , DefaultVarDec("uri__")
    , DefaultVarDec("states__")]
  , Seq(Match(pattern), body)
  )  
	
	EXTERNAL_DEF_RULE(pattern, body) =
  SDefT(
    "nabl-external-def-site"
  , []
  , [ DefaultVarDec("lang__")
    , DefaultVarDec("partition__")
    , DefaultVarDec("uniques__")
    , DefaultVarDec("uri__")
    , DefaultVarDec("states__")]
  , Seq(Match(pattern), body)
  ) 
  
  DEF_CALL(ns, u, ds, s, nt-s, in-child-uris, in-sibl-uris, out-child-uris, out-sibl-uris) = 
  CallT(
    SVar("nabl-def")
  , [Match(out-child-uris), Match(out-sibl-uris)]
  , [ Var("lang__")
    , Var("partition__")
    , Var("uniques__")
    , in-child-uris
    , in-sibl-uris
    , ns, u, ds, LIST(s), LIST(nt-s)]
  )
  
  ALIAS_CALL() = 
  CallT(
    SVar("nabl-def-alias")
  , []
  , [ Var("partition__")
    , Var("def-uri__")
    ]
  )
  
  EXTERNAL_DEF_CALL() = 
	Where(Assign(Var("def-uri__"), RootApp(CallNoArgs(SVar("nabl-uri")))))
  	
  MATCH(s, v) =
  CALL("match", [s], [v])
