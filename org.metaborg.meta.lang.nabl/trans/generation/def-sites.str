module generation/def-sites

imports
  
  libstrc
  include/NameBindingLanguage
  
  generation/-
  
rules
  
  def-to-name = ?DefClause(Explicit(), _, _, <id>, _, _, _)
    
rules
  
  binding-to-name-rule: 
    BindingRule(pattern, constr*, clause*) -> NAME_RULE(pattern, name)
    where
      [name] := <filter(def-to-name + use-to-name)> clause*
    where
      <not(eq)> (name, pattern)
      
  binding-to-apply-rule:
  	BindingRule(pattern, constr*, clause*) -> APPLY_RULE(body)
  	where
      [name]          := <filter(def-to-name + use-to-name)> clause*;
  		Var(inner-name) := name;
  		body            := <op-to-call(|inner-name)> pattern
  		
	op-to-call(|name) =
		switch id
		  case ?NoAnnoList(ops)                 : <op-to-call(|name)> ops
		  case ?Op(aname, args)                 : !Call(SVar(aname), <map(op-to-call(|name))> args)
		  case ?Var(name) + ?Var(ListVar(name)) : !CallNoArgs(SVar("s"))
		  otherwise                             : !Id()
		end
      
  binding-to-def-rules:
    BindingRule(pattern, constr*, clause*) -> [DEF_RULE(pattern, seq), ext*]
    where
      def-clause* := <filter-def-clauses; nonempty> clause*
    ; implicit*   := <implicit-def-vars> def-clause*
    ; ns-term*    := <filterconcat(?ScopeClause(<map(ns-to-term)>))> clause*
    ; nt-ns-term* := <filterconcat(?NonTransitiveScopeClause(<map(ns-to-term)>))> clause*    
    ; cong*       := <filter-with-index(to-def-cong(|pattern, ns-term*, nt-ns-term*))> def-clause*
    ; m           := <length> def-clause*
    ; uri-cvar    := <uri-child-var> m
    ; uri-svar    := <uri-sibl-var> m
    ; seq         := <to-seq> [ cong*
                              , MATCH(CALL("child-uris__"), uri-cvar)
                              , MATCH(CALL("sibl-uris__"), uri-svar)
                              , MATCH(CALL("implicits__"), LIST(implicit*))
                              ] 
    where
       extseq := <filter-with-index(clause-to-assigns(|pattern, implicit*)); concat; nonempty; to-seq> def-clause*  
     ; ext*   := [EXTERNAL_DEF_RULE(pattern, extseq)]
    <+ ext*   := []
                               
  clause-to-assigns(|pattern, implicit*):
  	(i, DefClause(kind, _, _, term, _, DefScopes(scope*), _)) -> [match*, EXTERNAL_URI_CALL(u, named), assign*, cong]
  	where
  		u := <uri-var> i
    ; (alias*, assign*) := <filter-with-index(scope-to-assign(|u, i)); nonempty; unzip> scope*
    ; anno := EXTERNAL_ALIAS_CALL(LIST(alias*))
    where
       Implicit() := kind
     ; match*     := [ Where(Assign(LIST(implicit*), Var("implicits__"))) ]
     ; named      := <implicit-def-var> i        
     ; cong       := Where(App(anno, named))
    <+ match* := []
     ; named  := term
     ; cong := <add-force-origins; replace-all-id(|[(term, anno)])> pattern
      
  scope-to-assign(|uri, i):
    (j, DefScope(scope)) -> (a, ASSIGN_ALIAS(a, uri, scope))
    where
      k := <extend-index(|i)> j
    ; a := <alias-var> k
    
  uri-var: i-> Var($[uri[i]__])
  alias-var: i-> Var($[alias[i]__])
  
  to-def-cong(|pattern, scope*, nt-scope*):
    (o, clause) -> def-cong
    where
      DefClause(Explicit(), unique, ns, term, _, scope, _) := clause
    ; scope'*    := scope*
    ; nt-scope'* := nt-scope*
    + DefClause(Implicit(), unique, ns, term, _, scope, _) := clause
    ; scope'*     := []
    ; nt-scope'*  := []
    ; impl-var    := <implicit-def-var> o 
    + SingleImport(_, ns, _, _, _, Alias(term), scope, _)  := clause
    ; unique     := Unique()
    ; scope'*    := [] // TODO is this correct?
    ; nt-scope'* := [] // TODO is this correct?
    where
      ns-term     := <ns-to-term> ns
    ; unique-term := <nabl-to-str> unique
    ; scope-term  := <scope-to-term> scope
    ; i           := <dec> o
    ; uri-cvar1   := <uri-child-var> i
    ; uri-cvar2   := <uri-child-var> o
    ; uri-svar1   := <uri-sibl-var> i
    ; uri-svar2   := <uri-sibl-var> o
    ; def-call    := DEF_CALL(ns-term, unique-term, scope-term, scope'*, nt-scope'*, uri-cvar1, uri-svar1, uri-cvar2, uri-svar2)
    where
       def-cong := Where(Assign(impl-var, App(def-call, term)))
    <+ def-cong := <add-force-origins; replace-all-id(|[(term, def-call)])> pattern
  
rules
  
  filter-def-clauses =
    filter(
      ?DefClause(_, _, _, _, _, _, _) 
    + ?Import(<fetch-elem(?SingleImport(_, _, _, _, _, Alias(_), _, _))>)
    )
      
  implicit-def-vars = 
    filter-with-index(
      ?(<implicit-def-var>, DefClause(Implicit(), _, _, _, _, _, _))
    )
    
  implicit-def-var = !Var($[i-[<id>]__])
  
  nabl-to-str: NonUnique() -> TERM("NonUnique")
  nabl-to-str: Unique()    -> TERM("Unique")
  
  uri-var(|kind): 0 -> Var($[uri__])
  uri-var(|kind): i -> Var($[[kind]-uri[i]__]) where not(?0)
   
  uri-child-var = uri-var(|"c")
  uri-sibl-var  = uri-var(|"s")

			  
overlays
  
  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
  
  APPLY_RULE(body) = SDef("nabl-name-apply", [DefaultVarDec("s")], body)
  
overlays
  
	DEF_RULE(pattern, body) =
  SDefT(
    "nabl-def-site"
  , [ DefaultVarDec("child-uris__")
    , DefaultVarDec("sibl-uris__")
    , DefaultVarDec("implicits__")
    ]
  , [ DefaultVarDec("lang__")
    , DefaultVarDec("partition__")
    , DefaultVarDec("uniques__")
    , DefaultVarDec("uri__")
    , DefaultVarDec("states__")]
  , Seq(Match(pattern), body)
  )  
	
  DEF_CALL(ns, u, ds, s, nt-s, in-child-uris, in-sibl-uris, out-child-uris, out-sibl-uris) = 
  CallT(
    SVar("nabl-def")
  , [Match(out-child-uris), Match(out-sibl-uris)]
  , [ Var("lang__")
    , Var("partition__")
    , Var("uniques__")
    , in-child-uris
    , in-sibl-uris
    , ns, u, ds, LIST(s), LIST(nt-s)]
  )
  
  MATCH(s, v) =
  CALL("match", [s], [v])

  EXTERNAL_DEF_RULE(pattern, body) =
  SDefT(
    "nabl-external-def-site"
  , []
  , [ DefaultVarDec("lang__")
    , DefaultVarDec("partition__")
    , DefaultVarDec("uniques__")
    , DefaultVarDec("uri__")
    , DefaultVarDec("states__")
    , DefaultVarDec("implicits__")]
  , Seq(Match(pattern), body)
  ) 
  
  EXTERNAL_URI_CALL(v, named) = 
  Where(Assign(v, App(CallNoArgs(SVar("nabl-uri")), named)))
  
  ASSIGN_ALIAS(v, uri, scope) = 
  Where(
    Assign(
      v
	  , App(
		    CallT(
			    SVar("nabl-def-alias")
			  , []
			  , [ Var("partition__")
			    , uri
			    ]
			  )
	    , scope
	    )
	  )
	)

  EXTERNAL_ALIAS_CALL(alias) =
    CallT(
    SVar("nabl-external-def")
  , []
  , [alias]
  )