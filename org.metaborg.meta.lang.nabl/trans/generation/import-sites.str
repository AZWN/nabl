module generation/import-sites

imports
	
  libstrc
  include/NameBindingLanguage
  
  generation/util
  generation/sections
  generation/scoping-sites
  generation/constraints
  
rules
                     
	
  import-to-name = 
    ?RefClause(<fetch-elem(import-to-name)>)
  + ?ImportClause(<fetch-elem(import-to-name)>)
  + ?SingleImport(_, _, <id>, _, _, _, _, _)
  + ?WildcardImport(_, _, Context(_, _, <id>, _, _), _, _)
	    
  binding-to-import-rule(|bound*, task*, repl*):
    (i, BindingRule(pattern, constr*, clause*)) -> IMPORT_RULE(pattern, seq)
    where 
      cong* := <filter-with-index(to-import-clauses(|pattern, bound*, repl*, i)); concat; nonempty> clause*
    ; seq   := <to-seq> [task*, cong*]
  
  // should be handled at def-site instead
  // to-import-clauses(|pattern, bound*, repl*, i):
  //   (j, DefClause(_, _, _, term, _, DefScopes(ds*), _)) -> [IMPORT_CALL([SINGLE(term, scope, [])])]
  //   where
  //     ds'*  := <filter(?DefScope(_)); nonempty> ds*
  //   ; scope := <scope-to-term> DefScopes(ds'*)
    
  to-import-clauses(|pattern, bound*, repl*, i):
    (j, clause@ImportClause(part*)) -> [clause*, IMPORT_CALL(import*)]
    where
      k       := <extend-index(|i)> j
    ; (clause*, import*) 
              := <filter-with-index(to-import-candidate(|pattern, bound*, repl*, k)); unzip; (concat, id)> part*
    
  to-import-candidate(|pattern, bound*, glob-repl*, i):
    (j, SingleImport(_, _, term, _, _, alias, into, constr*)) -> result
    where
      into-term      := <scope-to-term> into
    ; k              := <extend-index(|i)> j
    ; (task*, repl*) := <constraints-to-tasks(|bound*, k, 1)> (constr*, glob-repl*)
    ; dep*           := <map(Snd)> repl*
    where
       Alias(a) := alias
     ; result   := (task*, ALIAS(term, a, []))
    <+ result   := (task*, SINGLE(term, into-term, dep*))
       
	to-import-candidate(|pattern, bound*, glob-repl*, i):
		(j, WildcardImport(ns*, _, from, into, constr*)) -> (task*, WILDCARD(ns-term*, from-term, into-term, dep*))
    where
      ns-term*  := <map(ns-to-term)> ns*
    ; from-term := <scope-to-term> from
    ; into-term := <scope-to-term> into
    ; k              := <extend-index(|i)> j
    ; (task*, repl*) := <constraints-to-tasks(|bound*, k, 1)> (constr*, glob-repl*)
    ; dep*           := <map(Snd)> repl*
      
	ns-to-term: Direct(ns)     -> DIRECT(<ns-to-term> ns)
	ns-to-term: Transitive(ns) -> TRANSITIVE(<ns-to-term> ns)	
    
overlays
     
  IMPORT_RULE(pattern, body) =
  SDefT(
    "nabl-import-site"
  , []
  , [ DefaultVarDec("lang__")
    , DefaultVarDec("partition__")
    , DefaultVarDec("uris__")
    , DefaultVarDec("states__") 
    ]
  , Seq(Match(pattern), body)
  )
  
  IMPORT_CALL(imports) =
  CallT(
    SVar("nabl-import")
  , []
  , [ Var("lang__")
    , Var("partition__")
    , Var("uris__")
    , LIST(imports)
    ] 
  )
  
  SINGLE(term, scope, deps)      = TERM("Single", [term, scope, LIST(deps)])
  ALIAS(term, alias, deps)       = TERM("Alias", [term, alias, LIST(deps)])
  WILDCARD(ns, from, into, deps) = TERM("Wildcard", [LIST(ns), from, into, LIST(deps)])

  DIRECT(ns)     = TERM("Import", [Var("lang__"), ns])
  TRANSITIVE(ns) = TERM("Import", [Var("lang__"), TERM("Imported", [ns])])
