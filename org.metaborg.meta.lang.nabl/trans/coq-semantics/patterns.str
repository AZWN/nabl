module coq-semantics/patterns

imports
  include/NameBindingLanguage
  generation/util
  include/Coq/pp/-
  include/Coq/signatures/-
  coq-semantics/-

rules
  
  pattern-to-cons =
    ?(Op(<id>, _))

  patterns-to-term(|i, x): [] -> (Ref("nil"), [], i, None())
  
  patterns-to-term(|i, x):
    [c|cs] -> (T|[cons ct cts]|, [cbind*, csbind*], k, ret)
    with
      (ct, cbind*, j, hd) := <pattern-to-term(|i, x)> c
    ; (cts, csbind*, k, tl) := <patterns-to-term(|<inc> j, x)> cs
    ; ret := <?Some(_) <+ !tl> hd

  // (Co cC [c1; c2; c3] k)
  pattern-to-term(|i, x):
    Op(c, term*) -> (T|[Co ident x k]|, binder*, j, maybe)
    with
      ident := $[[c]C]
    ; k := $[k[i]]
    ; (x, cbinder*, j, maybe) := <patterns-to-term(|<inc> i, x)> term*
    ; binder* := [cbinder*, Bind(k)]
      
  pattern-to-term(|i, x):
    Var(n) -> (Ref(n), [Bind(n)], i, None())
    where not(<eq> (x,Some(n)))
  
  pattern-to-term(|i, x):
    Var(ident1) -> (T|[Id ident1 ident2]|, [Bind(ident2)], <inc> i, Some(ident2))
    where
      <eq> (x,Some(ident1))
    ; ident2 := $[k[i]]  

  pattern-to-term(|i, x):
    ListVar(n) -> (Ref(n'), [Bind(n')], i, None())
    where
      n' := <string-as-chars(filter(not(equal(|'*'))))> n

  pattern-to-term(|i, x):
    Wld() -> (Ref(n), [Bind(n)], <inc> i, None())
    with
      n := $[wld[i]]
