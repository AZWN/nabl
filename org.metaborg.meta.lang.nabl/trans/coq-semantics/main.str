module coq-semantics/main

imports
  include/NameBindingLanguage
  generation/util
  libstratego-gpp
  coq-semantics/-
  lib/Coq/pp/-
  lib/Coq/signatures/-
  lib/Coq/Coq-parenthesize
  
rules
  
  generate-coq-semantics:
    (selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
    with
      filename := "src-gen/verification/names.v"
    ; coq-file := <strip-annos; module-to-coq(|"names")> ast
    with
       result := <parenthesize-Coq; prettyprintCoq-CoqFile; box2text-string(|100)> coq-file
    <+ <bottomup(try(not(is-string) ; not(is-list) ; not(prettyprintCoq-example) ; debug(!"cannot pp ")))> coq-file
    ;  result := ""
 
rules
  
  module-to-coq(|filename):
    Module(name, section*) -> output
    where
       ns := <fetch-elem(?Namespaces(_)); namespaces-to-coq> section*
     ; binding* := <fetch-elem(?Bindings(<id>))> section*
     ; scopes  := <binding-rules-to-coq(scope-to-coq        |"scopes",        T|[term -> NS -> Prop]|)> binding*
     ; defines := <binding-rules-to-coq(defines-to-coq      |"defines",       T|[term -> Ident -> NS -> key -> Prop]|)> binding*
     ; refers  := <binding-rules-to-coq(refers-to-to-coq    |"refers_to",     T|[term -> Ident -> NS -> key -> Prop]|)> binding*
     ; ty-def  := <binding-rules-to-coq(typed-defines-to-coq|"typed_defines", T|[term -> Ident -> NS -> term -> key -> Prop]|)> binding*
     ; output  := <build-module(|filename)> (ns, scopes, defines, refers, ty-def)
    
rules // namespaces
  
  namespaces-to-coq:
  	Namespaces(ns*) -> (S|[Inductive ID_NS : Set := decls.]|,S|[Definition NS := ID_NS.]|)
  	with
  	  decls := <map(namespace-to-coq); listdecl> ns*
  	  
  namespace-to-coq:
  	NamespaceDef(ns) -> D|[ident_ns]|
  	where ident_ns := $[[ns]NS]

rules // binding rules
  
  binding-rules-to-coq(binding-to-coq|name, term_ty):
    r* -> (S|[Inductive ident1 : term_ty := decls.]|,S|[Definition ident2 := ident1.]|)
    with
      decls  := <collect-all(binding-rule-to-coq(binding-to-coq|)); concat; listdecl> r*;
      ident1 := $[[name]R];
      ident2 := $[[name]_R]
    
  binding-rule-to-coq(clause-to-coq|):
    BindingRule(pattern, _, clause*) -> <filter(clause-to-coq(|c, pattern))> clause*
    with
      c := <pattern-to-cons> pattern
      
rules
  
  listdecl: [] -> ListDecl([])
  listdecl: list@[_ | _] -> ListDeclBar(list)
