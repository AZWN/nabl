module coq-semantics/main

imports
  include/NameBindingLanguage
  generation/util
  coq-semantics/Coq
  coq-semantics/Vernacular.pp.generated
  coq-semantics/scopes
  coq-semantics/patterns
  coq-semantics/defines
  coq-semantics/refersto
  
rules
  
  generate-coq-semantics:
    (selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"v")> path
    ; coq-file := <strip-annos; module-to-coq> ast
    with
       result := <prettyprint-CoqFile> coq-file
    // <+ <bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module
    // ;  result := ""
 
rules
  
  module-to-coq:
    Module(name, section*) -> Sent(<filter(section-to-coq); concat> section*)
    
rules // namespaces
  
  section-to-coq:
  	Namespaces(ns*) -> [Ind([Induc("ID_NS", [], Set(), cdec*)]), Def("NS", [], None(), Ref("ID_NS"))]
  	with
  	  cdec* := <map(namespace-to-coq)> ns*
  	  
  namespace-to-coq:
  	NamespaceDef(ns) -> ConsDecl($[[ns]NS], [], None())
  
rules // 
  	
  section-to-coq:
    BindingRules(r*) ->
     [Ind([Induc("scopesR", [], Product(Ref("term"), Product(Ref("NS"), Prop())), scope-cdec*)]),
      Def("scopes_R", [], None(), Ref("scopesR")),
      Ind([Induc("definesR", [], Product(Ref("term"), Product(Ref("Ident"), Product(Ref("NS"), Product(Ref("key"), Prop())))), define-cdec*)]),
      Def("defines_R", [], None(), Ref("definesR")),
      Ind([Induc("refers_toR", [], Product(Ref("term"), Product(Ref("Ident"), Product(Ref("NS"), Product(Ref("key"), Prop())))), refers-to-cdec*)]),
      Def("refers_to_R", [], None(), Ref("refers_toR"))]
    with
      scope-cdec* := <collect-all(scope-to-coq); concat> r*
    ; define-cdec* := <collect-all(defines-to-coq); concat> r*
    ; refers-to-cdec* := <collect-all(refers-to-to-coq); concat> r*
  
rules // Helper function
  
  apply-apply = foldl(\(x,y) -> Apply(x,y)\)