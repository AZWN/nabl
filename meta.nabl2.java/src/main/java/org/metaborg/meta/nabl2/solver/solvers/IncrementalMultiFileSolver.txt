def analyze(Set<String> removed, Set<String> changed, Map<String,?> prev, Deps deps):

  remove all removed and changed resources from prev
  remove all removed and changed resources from deps,
    queue all dependent resources (transitively)

  for changed resources,
    collect constraints,
    solve graph
    solve local
    queue strong

  if no result for project,
    solve graph
    solve local
    solve inference

  solve graph for all changed resources
  merge all graphs into global graph
  
  while queued resources:
    pick one resource
    merge all pending merges, or queue again if not possible // try to prevent dumb guessing or cycles here
    solve resource inference
    if new dependency arrives,
      if dependency is done, merge (part of?) solution and continue solving inference
      if dependency is queued, queue with pending merge directive
    solve resource checks 

  merge (part of?) all solutions into global
  solve project checks
