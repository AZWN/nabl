module generation/rules/cgen

imports

  libstrc

  nabl2shared
 
  signatures/common/-
  signatures/rules/-

  generation/-
  util/stratego

rules

  section-to-str:
    Rules(rule*) -> Rules(rule-str*)
    with
      rule-str* := <map(rule-to-str)> rule*

  rule-to-str:
    CGenInitRule(params,type,constraint)
      -> RDefT(<rule-name> "init",[],[<source-var>],
           Rule(<term-var>, Tuple([<params-var>, <constraint-var>]), clause*))
    with
      new-scope-var* := <all-new-vars> constraint;
      new-scope-str := <new-scope-str> new-scope-var*;
      used-var* := <all-vars> (params,type,constraint);
      free-var* := <diff> (used-var*, [<term-var>,new-scope-var*]);
      new-var-str := <new-var-str> free-var*;
      params-term := <explode(injection-to-term)> params;
      if Type(type') := type then
        type-term := <explode(injection-to-term)> type';
        params-str := |[ ~<params-var> := (~params-term,~type-term) ]|;
        debug-str := Strat |[ try(<concat-strings;debug-generate-constraint> ["init ^(",<pp-Term> ~params-term,") : ",<pp-Term> ~type-term]) ]|
      else
        params-str := |[ ~<params-var> := ~params-term ]|;
        debug-str := Strat |[ try(<concat-strings;debug-generate-constraint> ["init ^ (",<pp-Term> ~params-term,")"]) ]|
      end;
      constraint-term := <constraint-to-term> constraint;
      constraint-str  := |[ ~<constraint-var> := ~constraint-term ]|;
      clause* := [
        With(new-scope-str),
        With(new-var-str),
        With(constraint-str),
        With(params-str),
        With(debug-str)
      ]
 
  rule-to-str:
    CGenMatchRule(Name(name),pattern,params,type,constraint)
      -> RDefT(<rule-name> name,[],[<source-var>,<params-var>],
           Rule(pattern, <constraint-var>, clause*))
    with
      if Type(type') := type then
        params-pattern := <explode(injection-to-pattern)> Tuple([params,type']);
        params-str := |[
          ~params-pattern := ~<params-var>
        ]|;
        metadata-str := |[
          <set-ast-params(|<Fst> ~<params-var>);
           set-ast-type(|<Snd> ~<params-var>)> ~<term-var>
        ]|;
        debug-str := |[ try( <concat-strings;debug-generate-constraint> [~Str(name)," [[ ",<pp-Term> ~<term-var>," ]] ^ (",<Fst;pp-Term> ~<params-var>,") : ",<Snd;pp-Term> ~<params-var>]) ]|
      else
        params-pattern := <explode(injection-to-pattern)> params;
        params-str := |[
          ~params-pattern := ~<params-var>
        ]|;
        metadata-str := |[
          <set-ast-params(|~<params-var>)> ~<term-var>
        ]|;
        debug-str := |[ try( <concat-strings;debug-generate-constraint> [~Str(name)," [[ ",<pp-Term> ~<term-var>," ]] ^ (",<pp-Term> ~<params-var>,")"]) ]|
      end;
      if <outermost-list-pattern> pattern then
        safe-metadata-str := |[ id ]|
      else
        safe-metadata-str := metadata-str
      end;
      params-string := Str(<pp-stratego-string> params-pattern);
      guarded-params-str := |[ ~params-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~params-string," with actual ",<pp-Term> ~<params-var>, "."]) ]|;
      new-scope-var* := <all-new-vars> constraint;
      new-scope-str := <new-scope-str> new-scope-var*;
      bound-var* := <all-vars> (pattern,params,type,new-scope-var*);
      used-var* := <all-vars> constraint;
      free-var* := <diff> (used-var*, bound-var*);
      new-var-str := <new-var-str> free-var*;
      constraint-term := <constraint-to-term> constraint;
      constraint-str  := |[ ~<constraint-var> := ~constraint-term ]|;
      clause* := [
        With(debug-str),
        With(guarded-params-str),
        With(new-scope-str),
        With(new-var-str),
        With(constraint-str),
        With(safe-metadata-str)
      ]
 
  rule-name =
    !$[generate-constraint-[<id>]-rule]
 
  all-new-vars =
    collect-all(\ New(v*) -> v* \) ; concat

  new-var-str =
    mapseq({\ v -> |[ ~v := <new-var(|~<source-var>)> ~n ]| with n := Str(<var-name> v) \})

  new-scope-str =
    mapseq({\ v -> |[ ~v := <new-scope(|~<source-var>)> ~n ]| with n := Str(<var-name> v) \})
 
  var-name:
    Var(name) -> name 
 
rules
 
  constraint-to-term = explode(explode-guard)
 
  explode-guard(e) = injection-to-term(e)
  explode-guard(e) = cgenrecurse-to-term(e)
  explode-guard(e) = new-to-term(e)

  cgenrecurse-to-term(e):
    CGenRecurse(Name(name),v,params,type) -> App(recurse-str,v)
    with
      params-term := <e> params;
      if Type(type') := type then
        type-term := <e> type';
        recurse-arg := Tuple([params-term,type-term])
      else
        recurse-arg := params-term
      end;
      recurse-str := CallT(SVar("generate-constraint"),
          [SVar(<rule-name> name)],[<source-var>,recurse-arg])

  new-to-term(e):
    New(_) -> <e> CTrue()
