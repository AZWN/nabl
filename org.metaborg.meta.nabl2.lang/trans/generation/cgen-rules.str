module generation/cgen-rules

imports

  libstrc

  nabl2shared
 
  signatures/common/-
  signatures/modules/-

  generation/-
  util/stratego

rules

  section-to-str:
    CGenRules(rule*) -> Rules(rule-str*)
    with
      rule-str* := <map(rule-to-str)> rule*

  rule-to-str:
    CGenRule(match,constraint,new) ->
    RDefT(rule-name,[],param-term*,
        Rule(pattern',constraint-term,clause*))
    with
      if CGenInit(pattern) := match then
        rule-name := "generate-constraint-init-rule";
        (param-term*,param-str) := ([], |[ id ]|)
      else
        pattern := <cgenmatch-to-pattern> match;
        (param-term*,param-str,rule-name) := <cgenmatch-to-param-term'str'name> match
      end;
      pattern' := As(<term-var>,pattern);
      bound-var* := <all-vars> (pattern',match,new);
      used-var* := <all-vars> constraint;
      free-var* := <diff> (used-var*, bound-var*);
      var-str := <mapseq(\ v -> |[ ~v := <new-var> ]|  \)> free-var*;
      new-str := <new-to-str> new;
      constraint-term := <constraint-to-term> constraint;
      clause* := [ With(|[ ~param-str ; ~new-str ; ~var-str ]|) ]
 
rules
 
  constraint-to-term = explode(explode-guard)
 
  explode-guard(e) = injection-to-term(e)
  explode-guard(e) = cgenrecurse-to-term(e)

rules

  cgenmatch-to-pattern:
    CGenMatch(_,pattern,_,_) -> pattern 
 
  cgenmatch-to-param-term'str'name: 
    CGenMatch(Name(name),_,params,type) -> (params-term*,pattern-str',rule-name)
    with
      if NoType() := type then
        params-term* := [<params-var>];
        rule-name    := $[generate-constraint-[name]-rule]
      else
        params-term* := [<params-var>,type];
        rule-name    := $[generate-constraint-with-type-[name]-rule]
      end;
      paramstr       := <explode(injection-to-pattern)> params;
      pattern-str    := |[ ~paramstr := ~<params-var> ]|;
      pattern-string := Str(<pp-stratego-string> paramstr);
      pattern-str'   := |[ ~pattern-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~pattern-string," with actual ",<pp-Term> ~<params-var>, "."]) ]|
 
  new-to-str:
    NoNew() -> |[ id ]|

  new-to-str:
    New(var*) -> str
    with str := <mapseq(\ v -> |[ ~v := <new-scope> ]| \)> var*

rules

  cgenrecurse-to-term(e):
    CGenRecurse(Name(name),v,params,type) -> App(CallT(SVar(wrapper-name),[SVar(rule-name)],param*),v)
    with
      paramstr       := <e> params;
      if NoType()    := type then
        param*       := [paramstr];
        wrapper-name := "generate-constraint";
        rule-name    := $[generate-constraint-[name]-rule]
      else
        param*       := [paramstr, type];
        wrapper-name := "generate-constraint-with-type";
        rule-name    := $[generate-constraint-with-type-[name]-rule]
      end

