module dynsem/signatures

imports

  libspoofax/core/language
  dynsem/-
  util/src-gen
  generation/defaults
  signatures/nabl2/shared/common/-
  signatures/common/-
  signatures/rules/-
  signatures/signatures/-

rules

  generate-dynsem-signatures(|path, project-path, langname):
    ast@Module(name,_) -> [(filename, source)]
    with filename := <create-src-gen(|project-path, "nabl2", ".ds")> name;
         ds-ast := <module-to-ds(|langname)> ast;
         source := <ds-pp-module> ds-ast

  module-to-ds(|langname):
    ast@Module(name,_) -> Module(name,[
      Imports([
        Import("nabl2/runtime/interpreter/scopegraph-api"),
        Import($[ds-signatures/[langname]-sig])
      ]),
      Signatures([
        NativeOperators([
          ast-params-op*,
          ast-type-op*,
          ns-type-op*,
          ns-prop-op*
        ]),
        ArrowDeclarations([
          ast-params-arrow*,
          ast-type-arrow*,
          ns-type-arrow*,
          ns-prop-arrow*
        ]),
        Constructors([
          type-con*
        ])
      ]),
      Rules([
        ast-params-rule*,
        ast-type-rule*,
        ns-type-rule*,
        ns-prop-rule*
      ])
    ])
    with (ast-params-op*, ast-params-arrow*, ast-params-rule*) := <collect-om(cgen-sig-to-params-ds);unzip3> ast;
         (ast-type-op*, ast-type-arrow*, ast-type-rule*) := <collect-om(cgen-sig-to-type-ds);unzip3> ast;
         (ns-type-op*, ns-type-arrow*, ns-type-rule*) := <collect-om(ns-to-type-ds);unzip3> ast;
         (ns-prop-op*, ns-prop-arrow*, ns-prop-rule*) := <collect-om(ns-to-prop-dss);concat;unzip3> ast;
         type-con* := <collect-om(opdecl-to-ds)> ast

  cgen-sig-to-params-ds:
    CGenSig(Name(name), sort, param*, _) ->
      <cgen-op-ds(|name)>  (<sort-to-ds> sort, "paramsOf", <param-sorts-to-ds> param*)

  cgen-sig-to-type-ds:
    CGenSig(Name(name), sort, _, Type(type-sort)) -> result
    with result := <cgen-op-ds(|name)> (<sort-to-ds> sort, "typeOf", <sort-to-ds> type-sort)

  ns-to-type-ds:
    NamespaceDef(Namespace(name), Type(type-sort), _) -> result
    with result := <ns-op-ds(|name)> (<sort-to-ds> OccurrenceSort(), "typeOf", <sort-to-ds> type-sort)

  ns-to-prop-dss:
    NamespaceDef(Namespace(name), _, prop*) -> result*
    with result* := <map(ns-to-prop-ds(|name))> prop*

  ns-to-prop-ds(|ns):
    PropertyDef(name, prop-sort) -> result
    with result := <ns-op-ds(|ns)> (<sort-to-ds> OccurrenceSort(), $[[name]Of], <sort-to-ds> prop-sort)

rules

  unzip3 = ?[(x,y,z)|xyz*] < <unzip3> xyz* => (x*,y*,z*); !([x|x*],[y|y*],[z|z*]) + !([],[],[])

  ns-op-ds(|namespace): (src-sort, base-name, target-sort) -> (op, arrow, rule)
    with op-name := $[nabl2_[base-name][namespace]];
         op := NativeOpDecl(op-name, [src-sort], target-sort);
         arrow-name := $[[base-name][namespace]];
         arrow := ArrowDecl(NoArrowROs(),src-sort,NoArrowRWs(),arrow-name,target-sort,NoArrowRWs());
         rule := Axiom(Relation(NoReads(),Source(Cast(VarRef("t"),src-sort)),NamedDynamic(arrow-name),Target(Con(op-name, [VarRef("t")]))))

  cgen-op-ds(|rule-name): (src-sort, base-name, target-sort) -> (op, arrow, rule)
    with op-name := <cgen-op-name(|rule-name, src-sort)> base-name;
         op := NativeOpDecl(op-name, [src-sort], target-sort);
         arrow-name := <cgen-arrow-name(|rule-name)> base-name;
         arrow := ArrowDecl(NoArrowROs(),src-sort,NoArrowRWs(),arrow-name,target-sort,NoArrowRWs());
         rule := Axiom(Relation(NoReads(),Source(Cast(VarRef("t"),src-sort)),NamedDynamic(arrow-name),Target(Con(op-name, [VarRef("t")]))))

  cgen-op-name(|rule-name,sort): base-name -> op-name
    with sort-name := <ds-sort-to-string> sort;
         if default-rule-name => rule-name then
           op-name := $[nabl2_[base-name][sort-name]]
         else
           op-name := $[nabl2_[rule-name]_[base-name][sort-name]]
         end

  cgen-arrow-name(|rule-name): base-name -> arrow-name
    with if default-rule-name => rule-name then
           arrow-name := $[[base-name]]
         else
           arrow-name := $[[rule-name]_[base-name]]
         end

  opdecl-to-ds:
    OpDecl(name, [], s) ->
      NullaryConsDecl(name, <sort-to-ds> s, NoAnnos())

  opdecl-to-ds:
    OpDecl(name, arg*, s) ->
      ConsDecl(name, <map(Snd;sort-to-ds)> arg*, <sort-to-ds> s, NoAnnos())

  param-sorts-to-ds: [sort] -> <sort-to-ds> sort
  param-sorts-to-ds: sort* -> <sort-to-ds> TupleSort(sort*)

  sort-to-ds: SortNoArgs(name) -> SimpleSort(name)
  sort-to-ds: ListSort(arg) -> ListSort(<sort-to-ds> arg)
  sort-to-ds: TupleSort(arg*) -> TupleSort(<map(sort-to-ds)> arg*)
  sort-to-ds: Var(_) -> <fatal-err(|"Not supported in DynSem")>

  sort-to-ds: TermSort() -> SimpleSort("AST")
  sort-to-ds: ScopeSort() -> SimpleSort("Scope")
  sort-to-ds: OccurrenceSort() -> SimpleSort("Occurrence")
  sort-to-ds: TypeSort() -> SimpleSort("Type")
