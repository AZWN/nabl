module dynsem/native-operators

imports

  libjava-front
  dynsem/-
  signatures/common/-
  signatures/modules/-
  signatures/rules/-
  signatures/signatures/-
  signatures/nabl2/shared/common/-
  signatures/nabl2/shared/constraints/-

rules

  generate-java-operators(|native-pkg,term-pkg,native-dir):
    ast@Module(name,_) -> result*
    with result* := <concat> [
      <collect-om(cgen-sig-to-params-java(|native-pkg,term-pkg,native-dir))> ast,
      <collect-om(cgen-sig-to-type-java(|native-pkg,term-pkg,native-dir))> ast,
      <collect-om(ns-to-type-java(|native-pkg,term-pkg,native-dir))> ast,
      <collect-om(ns-to-prop-javas(|native-pkg,term-pkg,native-dir));concat> ast,
      <collect-one(init-to-java(|native-pkg,term-pkg,native-dir))<+![]> ast
    ]

  cgen-sig-to-params-java(|native-pkg,term-pkg,native-dir):
    CGenSig(Name(name), sort, param*, _) -> result
    with src-sort := <sort-to-ds> sort;
         src-name := <ds-sort-to-string> src-sort;
         target-name := <param-sorts-to-ds;ds-sort-to-string> param*;
         op-name := <cgen-op-name(|name,src-sort)> "paramsOf";
         stmts := bstm* |[
           TermIndex index = term.getAttachments().getInstance(TermIndex.class);
           if (index == null) {
             throw new IllegalArgumentException("Primitive must be called on an AST node.");
           }
           Optional<ITerm> params = solution.getAstProperties().getValue(index, GenericTerms.newAppl("Params", Iterables2.empty()));
           if (!params.isPresent()) {
             throw new NoSuchElementException();
           }
           return params.get();
         ]|;
         result := <native-java(|native-pkg, native-dir, term-pkg, op-name, src-name, target-name)> stmts

  cgen-sig-to-type-java(|native-pkg,term-pkg,native-dir):
    CGenSig(Name(name), sort, _, Type(tsort)) -> result
    with type-sort := <sort-to-ds> tsort;
         src-sort := <sort-to-ds> sort;
         src-name := <ds-sort-to-string> src-sort;
         target-name := <ds-sort-to-string> type-sort;
         op-name := <cgen-op-name(|name,src-sort)> "typeOf";
         stmts := bstm* |[
           TermIndex index = term.getAttachments().getInstance(TermIndex.class);
           if (index == null) {
             throw new IllegalArgumentException("Primitive must be called on an AST node.");
           }
           Optional<ITerm> type = solution.getAstProperties().getValue(index, GenericTerms.newAppl("Type", Iterables2.empty()));
           if (!type.isPresent()) {
             throw new NoSuchElementException();
           }
           return type.get();
         ]|;
         result := <native-java(|native-pkg, native-dir, term-pkg, op-name, src-name, target-name)> stmts

  ns-to-type-java(|native-pkg,term-pkg,native-dir):
    NamespaceDef(Namespace(name), Type(type-sort), _) -> result
    with source-name := <sort-to-ds;ds-sort-to-string> OccurrenceSort();
         target-name := <sort-to-ds;ds-sort-to-string> type-sort;
         op-name := $[nabl2_typeOf[name]];
         stmts := bstm* |[
           Optional<Occurrence> decl = Occurrence.matcher().match(term);
           if (!decl.isPresent()) {
             throw new IllegalArgumentException("Declaration occurrence expected."); 
           }
           Optional<ITerm> type = solution.getDeclProperties().getValue(decl.get(), GenericTerms.newAppl("Type", Iterables2.empty()));
           if (!type.isPresent()) {
             throw new NoSuchElementException();
           }
           return type.get();
         ]|;
         result := <native-java(|native-pkg, native-dir, term-pkg, op-name, source-name, target-name)> stmts

  ns-to-prop-javas(|native-pkg,term-pkg,native-dir):
    NamespaceDef(Namespace(name), _, prop*) -> result*
    with result* := <map(ns-to-prop-java(|native-pkg,term-pkg,native-dir,name))> prop*

  ns-to-prop-java(|native-pkg,term-pkg,native-dir,ns):
    PropertyDef(name, prop-sort) -> result
    with source-name := <sort-to-ds;ds-sort-to-string> OccurrenceSort();
         target-name := <sort-to-ds;ds-sort-to-string> prop-sort;
         op-name := $[nabl2_[name]Of[ns]];
         stmts := bstm* |[
           Optional<Occurrence> decl = Occurrence.matcher().match(term);
           if (!decl.isPresent()) {
             throw new IllegalArgumentException("Declaration occurrence expected."); 
           }
           Optional<ITerm> prop = solution.getDeclProperties().getValue(decl.get(),
               GenericTerms.newAppl("Property", Iterables2.empty(GenericTerms.newString(~x:name))));
           if (!prop.isPresent()) {
             throw new NoSuchElementException();
           }
           return prop.get();
         ]|;
         result := <native-java(|native-pkg, native-dir, term-pkg, op-name, source-name, target-name)> stmts

  init-to-java(|native-pkg,term-pkg,native-dir):
    CGenInitRule(_, _, _) -> result*
    with result* := [
      <termindex-java(|native-pkg,term-pkg,native-dir)>
    ]
 
  termindex-java(|native-pkg,term-pkg,native-dir):
    _ -> result
    with source-name := <sort-to-ds;ds-sort-to-string> TermSort();
         target-name := <sort-to-ds;ds-sort-to-string> SortNoArgs("TermIndex");
         op-name := "nabl2_indexOf";
         stmts := bstm* |[
           TermIndex index = term.getAttachments().getInstance(TermIndex.class);
           if (index == null) {
             throw new IllegalArgumentException("Primitive must be called on an AST node.");
           }
           return index;
         ]|;
         result := <native-java(|native-pkg, native-dir, term-pkg, op-name, source-name, target-name)> stmts

  native-java(|pkg, pkg-dir, term-pkg, op-name, source-name, target-name): stmts -> (file-name, <pp-java-string> compilation-unit |[
    package ~x:pkg;

    import java.util.NoSuchElementException;
    import java.util.Optional;
    import java.util.function.Supplier;

    import ~x:term-pkg.*;
    import org.metaborg.meta.lang.dynsem.interpreter.nabl2.NaBL2TermBuild;
    import org.metaborg.meta.lang.dynsem.interpreter.nodes.building.TermBuild;
    import org.metaborg.meta.nabl2.scopegraph.terms.*;
    import org.metaborg.meta.nabl2.solver.ISolution;
    import org.metaborg.meta.nabl2.terms.*;
    import org.metaborg.meta.nabl2.terms.generic.*;
    import org.metaborg.util.iterators.Iterables2;
    import org.spoofax.interpreter.terms.IStrategoTerm;

    import com.oracle.truffle.api.dsl.NodeChild;
    import com.oracle.truffle.api.dsl.Specialization;
    import com.oracle.truffle.api.source.SourceSection;

    @SuppressWarnings("unused")
    @NodeChild(value = "term", type = TermBuild.class)
    public abstract class ~x:class-name extends NaBL2TermBuild<~x:source-name,~x:target-name> {

      public ~x:class-name(SourceSection source) {
        super(source);
      }

      @Specialization public ~x:target-name doGet(~x:source-name term) { 
        return super.doGet(term);
      }

      @Override protected ITerm eval(ITerm term, ISolution solution) {
        ~bstm*:stmts
      }

      @Override
      protected ~x:target-name build(IStrategoTerm term) {
        return ~x:target-name.create(term);
      }

      public static TermBuild create(SourceSection source, TermBuild term) {
        return ~x:nodegen-name.create(source, term);
      }

    }
  ]|)
  with
    class-name   := $[[op-name]_1];
    nodegen-name := $[[class-name]NodeGen];
    file-name    := $[[pkg-dir]/[class-name].java]
