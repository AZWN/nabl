module coq/main

imports
	libstrc
	libstratego-gpp
  util/src-gen
  analysis/normalize
  analysis/signatures
    
  // NaBL2 imports:
  signatures/signatures/CGen-sig
  signatures/signatures/Types-sig
  signatures/common/Sorts-sig
  signatures/rules/CGen-sig
  signatures/rules/Rules-sig
  signatures/rules/Normalization-sig
  signatures/nabl2/shared/constraints/Equality-sig
  
  // Coq imports:
  coq/analysis/explicate-wildcards
  coq/analysis/dependencies
  coq/util/maybe-list
  coq/util/mbind-err
  coq/query
  signatures/Vernacular-sig
  signatures/Gallina-sig
  signatures/Options-sig
  
  // Coq pp
	pp/Coq-parenthesize
	pp/Coq-pp

rules // Constant(s)

	coq-type-name = !"T"
	coq-list-name = !"list"

rules

  generate-coq:
    (_, _, ast, path, project-path) -> (filename, result)
    with
    	Module(name, decls) := ast;
      filename := <create-src-gen(|project-path, "nabl2", ".v")> name;
      // Pre-processing
      decls' := <explicate-wildcards> decls;
      imps := <filter(?Imports(<id>)); concat> decls';
      sigs := <filter(?Signature(<id>)); concat> decls';
      ruls := <filter(?Rules(<id>)); concat> decls';
      result :=
      	//  Calculate dependencies between constraint generation rules
      	<mdeps;
      	mbind(\ deps ->
	      // Generate syntax and rule types based on signatures
	     	<sigs-to-coq;
	      mbind(\ coq_defs ->
	     	// Augment definitions with generated rules
	     	<rules-to-coq;
	     	mbind(\ coq_defs' ->
	    	// Transform based on dependencies between rules (definition-before-use)
	     	<foldl(\
	    		((x, y), coq2) ->
	    			<join-induc-defs> (x, y, coq2) \);
	    	mbind(\ coq1 ->
	    	// Pretty-print
	    	<parenthesize-Coq; prettyprint-Coq; box2text-string(|100)> coq1
	    	\)> (<concat> deps, coq_defs')
	     	\)> (ruls, coq_defs) \)> sigs \)> ruls

rules // Joining inductive definitions

	join-induc-defs:
		(name1, name2, coq) ->
			coq'
		with
			// Hoist dependent definition of Coq definition
			(inducs1, coq1) := <get-def> (name2, coq);
			name1' := <cgen-rename> name1;
			// Insert dependent definition in definition for dependee
			(
				coq' :=
					<oncetd(\
						Inductive(inducs) ->
							Inductive(<conc> (inducs, inducs1))
							where <fetch(?Induc(name1', _, _, _))> inducs \)> coq1
				<+
				coq' := <conc> (coq1, [Inductive(inducs1)])
			)
	
	get-def:
		(name1, coqdefs) -> (inducs', coqdefs')
		with
			name1' := <cgen-rename> name1;
			// Coq definitions after removing the definition for name1
			coqdefs' := 
				<filter({ inducs:
					not(?Inductive(inducs);
						<fetch(?Induc(name1', _, _, _))> inducs) })> coqdefs;
			// Binds inducs' to the definition for name1
			<alltd({ inducs:
				?Inductive(inducs);
				<fetch({x,y,z: ?Induc(name1', x, y, z) })> inducs;
				inducs' := inducs })> coqdefs

rules // Signatures

	sigs-to-coq:
		sigs -> <sigs-to-coql; concat> sigs

	sigs-to-coql:
 		[x|xs] ->
 			<sig-to-coq;
 			mbind(\ y ->
 			<sigs-to-coql;
 			mbind(\ xs' ->
 			<cons-if-some> (y, xs') \)> xs \)> x
 	
 	sigs-to-coql:
 		[] -> []
 	
 	sig-to-coq:
 		CGen(cs) ->
 			<cgen-sigs-to-coq> cs
 	
 	sig-to-coq:
 		Types(ts) ->
 			<type-sigs-to-coq;
 			mbind(\ ts' ->
 			[Inductive([Induc(<coq-type-name>, None(), Type(),
 				ListDeclBar(ts'))])] \)> ts

 	sig-to-coq(|deps):
 		x ->
 			<concat-strings; err> ["Encountered an unexpected declaration: ",
 				<write-to-string> x, ". Please report."]
 		where
 			not(?CGen(_) <+ ?Types(_))

rules	// Constraint generation signatures

	cgen-sigs-to-coq:
		[csig|csigs] ->
			<cgen-sig-to-coq;
			mbind(\ coqsig' ->
			<cgen-sigs-to-coq;
			mbind(\ coqsigs' ->
			<cons-if-some> (coqsig', coqsigs')
			\)> csigs \)> csig
			
	cgen-sigs-to-coq:
		[] -> []
	
	cgen-sig-to-coq:
		CGenSig(name, trsort, ssorts, tysort) ->
			x''
			with
			x'':=
			<get-name;
				mbind(\ name' ->
				<term-sort-to-coq;
				mbind(\ trsort' ->
				<append-if-some; foldr(!Prop(),
					\ (x, y) ->
						<mbind(\ y' ->
						<type-sort-to-coq;
						mbind(\ x' ->
						Arrow(x', y')
						\)> x \)> y \);
				mbind(\ srts' ->
				Inductive([Induc(<cgen-rename> name', None(),
					Arrow(trsort', srts'), None())]) \)> (ssorts, tysort) \)> trsort \)> name
			
	cgen-sig-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected constraint generation signature: ",
				<write-to-string> x, ". Please report."]
		where
			not(?CGenSig(_, _, _, _))

rules // Type signatures

	type-sigs-to-coq:
		[tsig|tsigs] ->
			<type-sig-to-coq;
				mbind(\ y ->
				<type-sigs-to-coq;
				mbind(\ tsigs' ->
				<cons-if-some> (y, tsigs') \)> tsigs \)> tsig

	type-sigs-to-coq:
		[] -> []

	type-sig-to-coq:
		TypeSig(tname, tparams) ->
			<foldr(!Ref(<coq-type-name>),
					\ (x, y) ->
						<mbind(\ z ->
						<type-sort-to-coq;
						mbind(\ x' ->
						Arrow(x', z)
						\)> x \)> y \);
			mbind(\ t ->
			ConsDecl(tname, None(),
				OptType(t)) \)> tparams

rules // NaBL2 sorts

	type-sort-to-coq:
		TypeSort() -> Ref(<coq-type-name>)
	
	type-sort-to-coq:
		Type() -> Ref(<coq-type-name>)

	type-sort-to-coq:
		"s" -> Ref("ScopeId")

	type-sort-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected type sort: ", <write-to-string> x, ". Please report."]
	where
		not(?TypeSort() <+ ?Type() <+ ?"s")
	
	term-sort-to-coq:
		SortNoArgs(name) ->
			Ref(name)
	
	term-sort-to-coq:
		Sort("List", [sort]) ->
			Apply(Ref(<coq-list-name>), <term-sort-to-coq> sort)
	
	term-sort-to-coq:
		x ->
			<concat-strings; err> ["Encountered an unexpected term sort: ", <write-to-string> x, ". Please report."]
		where
			not(?SortNoArgs(_) <+ ?Sort("List", [_]))

rules // Rules

	rules-to-coq:
		([r|rs], coq) ->
			<rule-to-coq;
			mbind(\ coq' ->
			<rules-to-coq> (rs, coq') \)> (r, coq)
	
	rules-to-coq:
		([], coq) -> coq

	// Ignored, for now...
	rule-to-coq:
		(CGenInitRule(spattern, tpattern, body), coq) ->
			coq
		
	rule-to-coq:
		(CGenMatchRule(name, trpattern, spattern, typattern, body), coq) ->
			<rule-name-from-term-pattern;
			mbind(\ rname ->
			<term-pattern-to-coq;
			mbind(\ trpattern' ->
			<get-name;
			mbind(\ cgen_name ->
			<scope-pattern-to-coq;
			mbind(\ spattern' ->
			<alltd(\
			Induc(coq_name, x, ty, cs) ->
				Induc(coq_name, x, ty,
					<append-constructor>
						(cs, ConsDecl(rname,
							None(), // Binders -- FIXME
							OptType(trpattern'))))
				where
					<equal> (<cgen-rename> cgen_name, coq_name)
				 \)> coq
			\)> spattern
			\)> name
			\)> trpattern
			\)> (name, trpattern)
	
	rule-to-coq(|sigs):
		(r, _) -> 
			<concat-strings; err>
				["Encountered an unexpected rule kind: ",
					<write-to-string> r, ". Please report."]
		where
			not(!r; ?CGenInitRule(_, _, _) <+
				?CGenMatchRule(_, _, _, _, _))

	// Converts a None() to a ListDeclBar if necessary,
	// and appends the constructor
	append-constructor:
		(None(), c) ->
			ListDeclBar([c])

	append-constructor:
		(ListDeclBar(cs), c) ->
			ListDeclBar(<conc> (cs, [c]))

rules // Rule naming

	rule-name-from-term-pattern:
		(rname, Op(cname, _)) ->
			<get-name;
			mbind(\ name -> 
			<conc-strings> (name, cname)
			\)> rname
			
	rule-name-from-term-pattern:
		(rname, List([])) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Nil")
			\)> rname
			
	rule-name-from-term-pattern:
		(rname, List([_|_])) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Cons")
			\)> rname
	
	rule-name-from-term-pattern:
		(rname, ListTail(_, _)) ->
			<get-name;
			mbind(\ name ->
			<conc-strings> (name, "Cons")
			\)> rname
	
	rule-name-from-term-pattern:
		(rname, x) ->
			<concat-strings; err>
				["Encountered an unexpected term kind during rule name generation: ",
					<write-to-string> x, ". Please report."]
		where
			not(!x;
				?Op(_, _) <+
				?List([]) <+
				?List([_|_]) <+
				?ListTail)

rules // Term patterns

	term-pattern-to-coq:
		Op(cname, params) ->
			<foldr(!Ref(cname),
				\ (param, coq_term) ->
					Apply(coq_term, <term-pattern-to-coq> param) \)> params
	
	term-pattern-to-coq:
		List(lst) ->
			<list-pattern-to-coq> lst
			
	term-pattern-to-coq:
		ListTail(heads, tail) ->
			<conc; list-pattern-to-coq> (heads, [tail])
	
	term-pattern-to-coq:
		Var(x) -> Ref(x)
	
	term-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected term: ",
					<write-to-string> x, ". Please report."]
		where
			not(?Op(_, _) <+
				?List(_) <+
				?ListTail(_, _) <+
				?Var(_))

rules // Scope patterns

	scope-patterns-to-coq:
		[sp|sps] ->
			<scope-pattern-to-coq;
			mbind(\ sp' ->
			<scope-patterns-to-coq;
			mbind(\ sps' ->
			[sp'|sps']
			\)> sps
			\)> sp
	
	scope-patterns-to-coq:
		[] -> []

	scope-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered an unexpected scope annotation: ",
					<write-to-string> x, ". Please report."]

rules // Lists

	list-pattern-to-coq:
		[] -> Ref("nil")
	
	list-pattern-to-coq:
		[x|xs] ->
			<term-pattern-to-coq;
			mbind(\ x' ->
			<list-pattern-to-coq;
			mbind(\ xs' ->
			Apply(Apply(Ref("cons"), x'), xs')
			\)> xs
			\)> x

	list-pattern-to-coq:
		x ->
			<concat-strings; err>
				["Encountered term where a list was expected during",
					" list pattern generation: ", <write-to-string> x]
		where
			not(?[] <+ ?[_|_])

rules // Naming conventions

	cgen-rename:
		x -> <conc-strings> ("CG", x)
