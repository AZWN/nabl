module nabl2/lang/generation/cgen/rules/cgen

imports

  libstrc

  signatures/nabl2/shared/constraints/-
 
  signatures/nabl2/lang/common/-
  signatures/nabl2/lang/rules/-

  nabl2/lang/generation/cgen/-
  nabl2/lang/generation/-
  nabl2/lang/util/stratego

rules

  section-to-str:
    Rules(rule*) -> Rules(rule-str*)
    with
      rule-str* := <map(rule-to-str)> rule*

  rule-to-str:
    CGenInitRule(params,type,clause*)
      -> RDefT(<init-strategy-name>, [], trmargs,
           Rule(<term-var>, Tuple([<args-var>, <constraint-var>]), strclause*))
    with
      trmargs := [<source-var>];
      (str*,constraint*) := <clauses-to-str> clause*;
      params-term := <explode(injection-to-term)> params;
      if Type(type') := type then
        type-term := <explode(injection-to-term)> type';
        args-str := |[ ~<args-var> := ParamsAndType(~params-term,~type-term) ]|;
        debug-str := Strat |[ if nabl2-debug-constraint-generation-hook then <concat-strings;debug> ["init ^ ",<pp-NaBL2-CTerm> ~params-term," : ",<pp-NaBL2-Type> ~type-term] end ]|
      else
        args-str := |[ ~<args-var> := Params(~params-term) ]|;
        debug-str := Strat |[ if nabl2-debug-constraint-generation-hook then <concat-strings;debug> ["init ^ ",<pp-NaBL2-CTerm> ~params-term] end ]|
      end;
      constraint-list := List(<constraints-to-terms> constraint*);
      constraint-str  := |[ ~<constraint-var> := <nabl2--flatten-list> ~constraint-list ]|;
      strclause* := [
        str*,
        With(args-str),
        With(constraint-str),
        With(debug-str)
      ]
 
  rule-to-str:
    CGenMatchRule(name,defs,pattern,params,type,clause*)
      -> RDefT(<strategy-name> name,strargs,trmargs,
           Rule(As(<term-var>,pattern), <constraint-var>, strclause*))
    with
      strargs := <map(\ r -> SVar(<strategy-name> r) \)> defs;
      trmargs := [<source-var>,<args-var>];
      pattern-string := Str(<strip-as-pattern;pp-stratego-string> pattern);
      (str*,constraint*) := <clauses-to-str> clause*;
      params-pattern := As(<params-var>,<explode(injection-to-pattern)> params);
      params-string := <strip-as-pattern;pp-stratego-string> params-pattern;
      if Type(type') := type then
        type-pattern := As(<type-var>,<explode(injection-to-pattern)> type');
        type-string :=  <strip-as-pattern;pp-stratego-string> type-pattern;
        args-pattern := Term |[ ParamsAndType(~params-pattern,~type-pattern) ]|;
        args-string := Str($[^ [params-string] : [type-string]]);
        args-str := |[
          ~args-pattern := ~<args-var>
        ]|;
        metadata-str := |[
          ~<index-var> := <nabl2--get-ast-index> ~<term-var>;
          ~<metadata-var> := [
            CAstProperty(~<index-var>, Params(), ~<params-var>),
            CAstProperty(~<index-var>, Type(), ~<type-var>)
          ]
        ]|;
        debug-str := |[ if nabl2-debug-constraint-generation-hook then <concat-strings;debug> [~Str(<rule-name> name)," [[ ",<pp-NaBL2-Term> ~<term-var>," ^ ",<pp-NaBL2-CTerm> ~<params-var>," : ",<pp-NaBL2-Type> ~<type-var>," ]]"] end ]|
      else
        args-pattern := Term |[ Params(~params-pattern) ]|;
        args-string := Str($[^ [params-string]]);
        args-str := |[
          ~args-pattern := ~<args-var>
        ]|;
        metadata-str := |[
          ~<index-var> := <nabl2--get-ast-index> ~<term-var>;
          ~<metadata-var> := [
            CAstProperty(~<index-var>, Params(), ~<params-var>)
          ]
        ]|;
        debug-str := |[ if nabl2-debug-constraint-generation-hook then <concat-strings;debug> [~Str(<rule-name> name)," [[ ",<pp-NaBL2-Term> ~<term-var>," ^ ",<pp-NaBL2-CTerm> ~<params-var>," ]]"] end ]|
      end;
      guarded-args-str := |[
        ~args-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~args-string," with actual ",<nabl2--pp-flat-args> ~<args-var>,
                                                  " when matching ",~pattern-string, " with ",<pp-NaBL2-Term> ~<term-var>,"."])
      ]|;
      constraint-list := List(<constraints-to-terms> constraint*);
      constraint-str  := |[ ~<constraint-var> := <conc;nabl2--flatten-list> (~<metadata-var>, ~constraint-list) ]|;
      strclause* := [
        With(guarded-args-str),
        With(debug-str),
        str*,
        With(metadata-str),
        With(constraint-str)
      ]

  rule-name: NoName()   -> <default-rule-name>
  rule-name: Name(name) -> name

  init-strategy-name = !$[nabl2--generate-constraint-init-rule]
  strategy-name      = !$[nabl2--generate-constraint-[<rule-name>]-rule]
 
rules

  rule-to-str:
    FunDef(name,arg*,clause*)
      -> RDefT(<fun-name> name,[],trmargs,
           Rule(<args-var>, <constraint-var>, strclause*))
    with
      trmargs := [<source-var>,<term-var>];
      args-pattern := <explode(injection-to-pattern)> Tuple([arg*]);
      args-string := Str(<pp-stratego-string> args-pattern);
      args-str := |[ ~args-pattern := ~<args-var> ]|;
      guarded-args-str := |[
        ~args-str <+ fatal-err(|<concat-strings> ["Cannot match expected ",~args-string," with actual ",<nabl2--pp-flat-term> ~<args-var>," in call to ",~Str(name)])
      ]|;
      debug-str := |[
        if nabl2-debug-constraint-generation-hook then <concat-strings;debug> [" << ",~Str(name),"(",<nabl2--pp-flat-term> ~<args-var>,") >>"] end
      ]|;
      (str*,constraint*) := <clauses-to-str> clause*;
      constraint-list := List(<constraints-to-terms> constraint*);
      constraint-str  := |[ ~<constraint-var> := <nabl2--flatten-list> ~constraint-list ]|;
      strclause* := [
        With(guarded-args-str),
        With(debug-str),
        str*,
        With(constraint-str)
      ]
 
  fun-name =
    !$[nabl2--constraint-function-[<id>]]
 

rules

  clauses-to-str =
    partition(clause-to-str);
    (map(!With(<id>)),id)

  clause-to-str:
    NewVars(v*) -> str
    with str := <mapseq({\
                   v -> |[ ~v := <nabl2--new-var(|~<source-var>);try(nabl2--copy-origin(|~<term-var>))> ~n ]|
                   with n := Str(<var-name> v)
                 \})> v*

rules
 
  constraints-to-terms =
    map(explode(explode-guard))
 
  explode-guard(e) = injection-to-term(e)
  explode-guard(e) = cgenrecurse-to-term(e)
  explode-guard(e) = funcall-to-term(e)

  cgenrecurse-to-term(e):
    CGenRecurse(name,refs,v,params,type) -> App(recurse-str,v)
    with
      strrefs := <map(\ r -> CallNoArgs(SVar(<strategy-name> r)) \)> refs;
      params-term := <e> params;
      if Type(type') := type then
        type-term := <e> type';
        recurse-arg := Term |[ ParamsAndType(~params-term,~type-term) ]|
      else
        recurse-arg := Term |[ Params(~params-term) ]|
      end;
      rule-str := CallT(SVar(<strategy-name> name),strrefs,[<source-var>,recurse-arg]);
      recurse-str := CallT(SVar("nabl2--generate-constraint"),[rule-str],[Str(<rule-name> name),<source-var>,<args-var>])

  funcall-to-term(e):
    FunCall(name,arg*) -> App(fun-str,args-term)
    with
      args-term := Tuple(<map(e)> arg*);
      fun-str := CallT(SVar(<fun-name> name),
          [],[<source-var>,<term-var>])

