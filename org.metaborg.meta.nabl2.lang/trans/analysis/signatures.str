module analysis/signatures

imports

  signatures/-
  signatures/modules/-
  signatures/signatures/-
  signatures/rules/-
  signatures/common/-
  
rules

	module-extract-signatures:
		Module(_, ds) -> (type_sigs, rule_sigs, subterm_sigs)
		with
			// Signatures and rules
			sigs := <filter(?Signature(<id>)); concat> ds;
			rs := <filter(?Rules(<id>)); concat> ds;
			// Extract signature information
			type_sigs := <filter(?Types(<id>)); concat> sigs;
			rule_sigs := <filter(?CGen(<id>)); concat> sigs;
			// Iterate over all rules, extract sub-term annotation signatures
			subterm_sigs := 
				<map(extract-rule-sigs); concat; nub> rs

	extract-rule-sigs:
		CGenInitRule(_, _, _) -> []
		
//	extract-rule-sigs:
//		CGenMatchRule(Name(name), As(_, Op(c, args)), scopes, types, body) ->
//			[((c, arity), sigs)]
//		with
//			arity := <length> args;
//			// FIXME: traverse argument list to extract deep match subterm signatures
//			sigs := <map(extract-body-sigs(|args)); concat> body
	
	extract-rule-sigs:
		CGenMatchRule(Name(name), match, scopes, types, body) ->
			term_sigs
		with
			term_sigs := <extract-term-sigs(|body)> match
	
	// FIXME
	extract-rule-sigs:
		x ->
			[]
		where
			not(!x; ?CGenMatchRule(Name(_), As(_, Op(_, _)), _, _, _))
	
	// Term signature extraction
	
	extract-term-sigs(|body):
		As(_, x) -> <extract-term-sigs(|body)> x
	
	extract-term-sigs(|body):
		Var(x) -> []
		with
			<conc-strings; debug> ("WARNING: Rule matches on naked variable: ", x)
	
	extract-term-sigs(|body):
		Wld() -> []
		with
			<debug> "WARNING: Rule matches on naked wilcard!"
	
	extract-term-sigs(|body):
		Op(c, args) -> <conc> ([((c, arity), sigs)], ts')
		with
			arity := <length> args;
			sigs := <map(extract-body-sigs(|args)); concat> body;
			ts' := <map(extract-subterm-sigs(|body)); concat> args
	
	extract-term-sigs(|body):
		ListTail(hd, tl) -> <map(extract-subterm-sigs(|body)); concat> hd
	
	extract-term-sigs(|body):
		List(l) -> <map(extract-subterm-sigs(|body)); concat> l
	
	// Sub-term signature extraction:
	extract-subterm-sigs(|body):
		As(_, _) -> []
		
	extract-subterm-sigs(|body):
		Var(_) -> []
		
	extract-subterm-sigs(|body):
		t@Op(c, args) -> <extract-term-sigs(|body)> t
	
	extract-subterm-sigs(|body):
		Wld() -> []
	
	extract-subterm-sigs(|body):
		ListTail(hd, tl) -> <map(extract-subterm-sigs(|body)); concat> hd
	
	extract-subterm-sigs(|body):
		List(l) -> <map(extract-subterm-sigs(|body)); concat> l

	// Body signature extraction
		
	extract-body-sigs(|args):
		CGenRecurse(Name(name), x, _, _) -> r
		with
			(i := <get-index0(my-match(|x))> args; r := [(name, i)]) <+
				(r := [])
	
	extract-body-sigs(|args):
		x -> []
		with
			not(!x; ?CGenRecurse(_, Var(_), _, _))

	// If the term is syntactically equal
	my-match(|x):
		x -> 1
		
	// If the term is an "as" abstraction
	my-match(|x):
		As(x, _) -> 1
			
		

/*

Rough plan:

*** Step 1: 

Extract named relation signatures and type signatures; serialize to file

*** Step 2: Extract NaBL2 subterm signatures

Extract and infer relationship between named relations and sub-term
positions; serialize to file.

Approach:

- for each NaBL2 rule that matches on a particular constructor, record
  which sub-terms are invoked with which NaBL2 relations (map from
  constructor declaration to a map from sub-terms to NaBL2 relations);

- Support deep matching in left-hand sides of NaBL2 rules; we should
  only ever recurse on variables on the right hand sides (warn if rules
  do otherwise);
  
- well-formedness check: check that the same term constructor does not
  associate different annotations with the same sub-term.

*** Step 3:

Based on serialized information from Step 1 and 2, transform DynSem:

- For each signature for term sort X, generate a sort PostX which has
  the annotations indicated in the NaBL2 signature;

- Store each sort in a map from each named NaBL2 relation to its
  PostX sort, and add each PostX sort to the list of declared sorts in
  DynSem.

- specialize term constructor declarations based on subterm signatures:

  + For each term constructor, look in the NaBL2 relation map; replace
    each sub-term occurrence with its annotated term counter-part
    (PostX)

*/