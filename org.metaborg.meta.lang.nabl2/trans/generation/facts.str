module generation/facts

imports
  
  libstrc
  src-gen/signatures/rules/core/-
  
rules
  
  fact-to-strategies:
    NewScope(scope, _) -> [ |[ ~scope := Scope(<NewScope>) ]| ]

  fact-to-strategies:
    HasType(_, type) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> type
       ; str* := <map(!|[ ~<id> := TVar(<NewTVar>) ]|)> var*

rules
    
  fact-to-terms:
    Declaration(term, scope, assoc-scope) -> [ Term |[ FDecl(~decl, ~scope) ]| , aconstr* ]
    with
      decl     := <binder-to-decl> term
    ; aconstr* := <assoc-scope-to-terms(|decl)> assoc-scope
  
  fact-to-terms:
    Reference(term, scope) -> [ Term |[ FRef(~ref, ~scope) ]| ]
    with
      ref := <binder-to-ref> term
  
  fact-to-terms:
    NamedImport(term, scope, subst) -> [ Term |[ FImportR(~ref, ~label, ~scope) ]| ]
    with
      ref   := <binder-to-ref> term
    ; label := <substitution-to-term> subst
  
  fact-to-terms:
    DirectImport(v, scope, subst) -> [ Term |[ FImportS(~v, ~label, ~scope) ]| ]
    with
      label := <substitution-to-term> subst
  
  fact-to-terms:
    NewScope(scope, Global()) -> [ Term |[ FParent(~scope, NoneScope()) ]| ]
  
  fact-to-terms:
    NewScope(scope, parent) -> [ Term |[ FParent(~scope, SomeScope(~parent)) ]| ]
    where not(Global() := parent)

  // dynamic check could be avoided with proper static analysis
  fact-to-terms:
    HasType(v, t) -> [ Term |[ <get-type-constraint(|tvars, ~tp, position)> ~v ]| ]
    with tp := <try(type-pattern)> t
    
  fact-to-terms:
  	SubType(ty1, ty2) -> [ Term |[ FSubType(~ty1', ~ty2', position) ]| ]
  	with
  	  ty1' := <type-pattern> ty1
  	; ty2' := <type-pattern> ty2

rules

  binder-to-decl: 
    Bind(ns, term) -> Term |[ DeclId(~nst, ~term, <get-position> ~term) ]|
    with nst := <namespace-to-term> ns
    
  binder-to-ref: 
    Bind(ns, term) -> Term |[ RefId(~nst, ~term, <get-position> ~term) ]|   
    with nst := <namespace-to-term> ns

  namespace-to-term: Name()        -> Term |[ None() ]|
  namespace-to-term: Namespace(ns) -> Term |[ Namespace(~ns) ]|

rules
	      
  assoc-scope-to-terms(|decl):
    None() -> []
    
  assoc-scope-to-terms(|decl):
    Assoc(scope) -> [ Term |[ FAssoc(~decl, ~scope) ]| ]

rules
	
	substitution-to-term: None()   -> Term |[ None() ]|
	substitution-to-term: Subst(t) -> t
	
rules
   
  type-pattern:
    TApp(tc, cp*, t*) -> Term |[ TApp(~tc', [~tp*]) ]|
    with 
      tc' := Op(tc, cp*)
    ; tp* := <alltd(try(wld-var))> t*
       
  wld-var:
    Wld() -> Term |[ TVar(<NewTVar>) ]|
    
