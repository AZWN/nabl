module generation/facts

imports
  
  libstrc
  signatures/rules/core/-
  signatures/terms/-
  generation/messages
  
rules
  
  collect-fact-vars =
    ?Declaration(_, <MkSingleton>, _, _)
    
  fact-to-strategies:
    Declaration(term, v, scope, assoc-scope) -> [ |[ ~v := ~decl ]| ]
    where <not(?Wld())> v
    with
      decl := <binder-to-decl> term
 
  fact-to-strategies:
    NewScope(scope, _) -> [ |[ ~scope := Scope(<NewScope>) ]| ]

rules
    
  fact-to-terms:
    Declaration(term, v, scope, assoc-scope) -> [ Term |[ FDecl(~decl, ~scope) ]| , aconstr* ]
    with
      if Wld() := v then
      	decl := <binder-to-decl> term
      else 
      	decl := v
      end
    ; aconstr* := <assoc-scope-to-terms(|decl)> assoc-scope
  
  fact-to-terms:
    Reference(term, scope) -> [ Term |[ FRef(~ref, ~scope) ]| ]
    with
      ref := <binder-to-ref> term
  
  fact-to-terms:
    NamedImport(term, scope, subst) -> [ Term |[ FImportR(~ref, ~label, ~scope) ]| ]
    with
      ref   := <binder-to-ref> term
    ; label := <substitution-to-term> subst
  
  fact-to-terms:
    DirectImport(v, scope, subst) -> [ Term |[ FImportS(~v, ~label, ~scope) ]| ]
    with
      label := <substitution-to-term> subst
  
  fact-to-terms:
    NewScope(scope, Global()) -> [ Term |[ FParent(~scope, None()) ]| ]
  
  fact-to-terms:
    NewScope(scope, parent) -> [ Term |[ FParent(~scope, ~parent) ]| ]
    where not(Global() := parent)

  // dynamic check could be avoided with proper static analysis
  fact-to-terms:
    HasType(v, t) -> [ Term |[ CTypeOf(<get-position> ~v, ~tp, ~msg) ]| ]
    with tp := <type-pattern> t
       ; msg := <default-message>
 
  fact-to-terms:
  	SubType(ty1, ty2) -> [ Term |[ FSubType(~ty1', ~ty2', ~msg) ]| ]
  	with
  	  ty1' := <type-def-pattern> ty1
  	; ty2' := <type-pattern> ty2
    ; msg := <default-message>

rules

  binder-to-decl: 
    Bind(ns, term) -> Term |[ DeclId(~nst, ~term, ~pos) ]|
    with 
      nst := <namespace-to-term> ns
    ; if <?VarRef(_) + ?ListVarRef(_)> term then
        pos := Term |[ <get-position> ~term ]|
      else
	      pos := Term |[ <get-implicit-decl-position(|~term)> position__ ]|
      end
    
  binder-to-ref: 
    Bind(ns, term) -> Term |[ RefId(~nst, ~term, ~pos) ]|   
    with 
      nst := <namespace-to-term> ns
    ; if <?Var(_) + ?ListVar(_) + ?VarRef(_) + ?ListVarRef(_)> term then
        pos := Term |[ <get-position> ~term ]|
      else
        pos := Term |[ <get-implicit-ref-position(|~term)> position__ ]|
      end
    
  namespace-to-term: Name()        -> Term |[ None() ]|
  namespace-to-term: Namespace(ns) -> Term |[ Namespace(~str:ns) ]|
rules
	      
  assoc-scope-to-terms(|decl):
    None() -> []
    
  assoc-scope-to-terms(|decl):
    Assoc(scope) -> [ Term |[ FAssoc(~decl, ~scope) ]| ]

rules
	
	substitution-to-term: None()   -> Term |[ None() ]|
	substitution-to-term: Subst(t) -> t
	
rules
   
  type-def-pattern = ! Term |[ <type-def> ~<alltd(wld-var)> ]|
  type-pattern     = ! Term |[ <type-app> ~<alltd(wld-var)> ]|
         
  wld-var:
    Wld() -> Term |[ Var(<NewVar>) ]|
    
