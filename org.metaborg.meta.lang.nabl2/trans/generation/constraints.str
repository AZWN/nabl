module generation/constraints

imports

  libstrc
  signatures/rules/core/-
  signatures/terms/-
  generation/facts
  generation/messages

rules

  collect-vars = collect-all(?Var(_) + ?ListVar(_))

  collect-bound-vars =
  	?Declares(_, <MkSingleton>)

  constraint-to-strategies:
    Declares(v, dv) -> [ |[ ~dv := ~decl ]| ]
    where <not(?Wld())> v
    with
      decl := <binder-to-decl> v

rules

  constraint-to-terms(|msg'):
    Failure(c, msg) -> t*
    with t* := <constraint-to-terms(|<message-to-term> msg)> c

  // dynamic check could be avoided with proper static analysis
  constraint-to-terms(|msg):
    HasType(v, t) -> [ Term |[ CTypeOf(<get-position> ~v, ~tp, ~msg) ]| ]
    where not (ListVarRef(_) := v)
    with tp := <type-pattern> t

  constraint-to-terms(|msg):
    HasType(v@ListVarRef(_), t) -> [ Term |[ <type-of-constraints(|~tp, ~msg)> ~v ]| ]
    with tp := <type-pattern> t

  constraint-to-terms(|msg):
    LubType(t1, t2, t3) -> [ Term |[ CEqual(~tp1, Lub(~tp2,~tp3), ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
       ; tp3 := <type-pattern> t3

  constraint-to-terms(|msg):
    SubType(t1, t2) -> [ Term |[ CSubType(~tp1, ~tp2, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2

  constraint-to-terms(|msg):
    MakeSub(t1, t2, t3) -> [ Term |[ CMkSub(~tp1, ~tp2, ~tp3, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
       ; tp3 := <type-pattern> t3

  constraint-to-terms(|msg):
    ExtractSub(t, p) -> [ Term |[ CComposeSub(~tp, ~p, ~msg) ]| ]
    with tp := <type-pattern> t

  constraint-to-terms(|msg):
    ApplySub(t1, s, t2) -> [ Term |[ CApplySub(~tp1, ~s, ~tp2, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2

  constraint-to-terms(|msg):
    Resolves(v, BindV(ns, dv), pv) -> [ Term |[ CResolves(~ref, ~pv', ~dv, ~msg) ]| ]
    with
      ref := <binder-to-ref> Bind(ns, v)
    ; pv' := <try(wld-var)> pv

  constraint-to-terms(|msg):
    Distinct(n) -> [ Term |[ CDistinct(~n',~msg) ]| ]
    with n' := <names-to-term> n

  constraint-to-terms(|msg):
    Subset(n1,n2) -> [ Term |[ CSubset(~n1',~n2',~msg) ]| ]
    with n1' := <names-to-term> n1
       ; n2' := <names-to-term> n2

  constraint-to-terms(|msg):
    Disjoint(n1,n2) -> [ Term |[ CDisjoint(~n1',~n2',~msg) ]| ]
    with n1' := <names-to-term> n1
       ; n2' := <names-to-term> n2

  names-to-term:
    Declarations(ns,s) -> Term |[ Declarations(~ns',~s)  ]|
    with ns' := <namespace-to-term> ns

  names-to-term:
    References(ns,s) -> Term |[ References(~ns',~s)  ]|
    with ns' := <namespace-to-term> ns

  names-to-term:
    Visibles(ns,s) -> Term |[ Visibles(~ns',~s)  ]|
    with ns' := <namespace-to-term> ns

  names-to-term:
    Reachables(ns,s) -> Term |[ Reachables(~ns',~s)  ]|
    with ns' := <namespace-to-term> ns

  constraint-to-terms(|msg):
    Declares(_, _) -> []

  constraint-to-terms(|msg):
    HasScope(v, sv) -> [ Term |[ CAssoc(~v, ~sv, ~msg) ]| ]

  constraint-to-terms(|msg):
  	Match(pattern1, pattern2) -> [ Term |[ CEqual(~tp1, ~tp2, ~msg) ]| ]
  	with tp1 := <type-pattern> pattern1
  	   ; tp2 := <type-pattern> pattern2
