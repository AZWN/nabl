module generation/constraints

imports
  
  libstrc
  src-gen/signatures/rules/core/-
  src-gen/signatures/terms/-
  generation/facts
  
rules
  
  constraint-to-strategies:
    HasType(_, type) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> type
       ; str* := <map(!|[ ~<id> := Var(<NewVar>) ]|)> var*
         
  constraint-to-strategies:
    c@LubType(type1, type2, type3) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> c
       ; str* := <map(!|[ ~<id> := Var(<NewVar>) ]|)> var*
  
  constraint-to-strategies:
    c@SubType(type1, type2) -> []
    
  var-to-strategy:
    VarRef(v) -> |[ ~v := Var(<NewVar>) ]|
      
  constraint-to-strategies:
    Declares(_, v) -> [ |[ ~v := Var(<NewVar>) ]| ]
 
  constraint-to-strategies:
    Resolves(_, _, v, Wld()) -> [ |[ ~v := Var(<NewVar>) ]| ]
  
  constraint-to-strategies:
    Resolves(_, _, v, p) -> [ |[ ~v := Var(<NewVar>) ]|, |[ ~p := Var(<NewVar>) ]| ]
    where not(Wld() := p)
     
  constraint-to-strategies:
    HasScope(_, v) -> [ |[ ~v := Var(<NewVar>) ]| ]
  
  constraint-to-strategies:
    Match(pattern1, pattern2) -> str* 
    with var1* := <collect-all(?Var(_) + ?ListVar(_))> pattern1
       ; var2* := <collect-all(?Var(_) + ?ListVar(_))> pattern2
       ; str* := <map(!|[ ~<id> := Var(<NewVar>) ]|)> [var1*, var2*]
  
  constraint-to-strategies:
    Success(c, _) -> str*
    with str* := <constraint-to-strategies> c
  
  constraint-to-strategies:
    Failure(c, _) -> str*
    with str* := <constraint-to-strategies> c

  constraint-to-strategies:
    c@MakeSub(v, _, _) -> [ |[ ~v := Var(<NewVar>) ]| ]

  constraint-to-strategies:
    c@ExtractSub(v, _) -> [ |[ ~v := Var(<NewVar>) ]| ]

  constraint-to-strategies:
    c@ApplySub(v, _, _) -> [ |[ ~v := Var(<NewVar>) ]| ]
 
rules
      
  constraint-to-terms(|pos):
    Success(c, msg) -> t*
    with pos' := <message-to-term> msg
    with t*   := <constraint-to-terms(|pos')> c
    
  constraint-to-terms(|pos):
    Failure(c, msg) -> t*
    with pos' := <message-to-term> msg
    with t*   := <constraint-to-terms(|pos')> c
         
  message-to-term:
    Message(_, _, t) -> Term |[ <get-position> t ]|
  
  // dynamic check could be avoided with proper static analysis
  constraint-to-terms(|msg):
    HasType(v, t) -> [ Term |[ CTypeOf(<get-position> ~v, ~tp, ~msg) ]| ]
    where not (ListVarRef(_) := v)
    with tp := <type-pattern> t
  
  constraint-to-terms(|msg):
    HasType(v@ListVarRef(_), t) -> [ Term |[ <type-of-constraints(|~tp, ~msg)> ~v ]| ]
    with tp := <type-pattern> t
  
  constraint-to-terms(|msg):
    LubType(t1, t2, t3) -> [ Term |[ CLubType(~tp1, ~tp2, ~tp3, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
       ; tp3 := <type-pattern> t3
   
  constraint-to-terms(|msg):
    SubType(t1, t2) -> [ Term |[ CSubType(~tp1, ~tp2, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
  
  constraint-to-terms(|msg):
    MakeSub(t1, t2, t3) -> [ Term |[ CMkSub(~tp1, ~tp2, ~tp3, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
       ; tp3 := <type-pattern> t3
   
  constraint-to-terms(|msg):
    ExtractSub(t, p) -> [ Term |[ CComposeSub(~tp, ~p, ~msg) ]| ]
    with tp := <type-pattern> t
  
  constraint-to-terms(|msg):
    ApplySub(t1, s, t2) -> [ Term |[ CApplySub(~tp1, ~s, ~tp2, ~msg) ]| ]
    with tp1 := <type-pattern> t1
       ; tp2 := <type-pattern> t2
        
  constraint-to-terms(|msg):
    Resolves(v, ns, dv, pv) -> [ Term |[ CResolves(~ref, ~pv', ~dv, ~msg) ]| ]
    with
      ref := <binder-to-ref> Bind(ns, v)
    ; pv' := <try(wld-var)> pv
      
  constraint-to-terms(|msg):
    Declares(v, dv) -> [ Term |[CEqual(~dv, ~decl, ~msg)]| ]
    with
      decl := <binder-to-decl> v
      
  constraint-to-terms(|msg):
    HasScope(v, sv) -> [ Term |[ CAssoc(~v, ~sv, ~msg) ]| ]
   
  constraint-to-terms(|msg):
  	Match(pattern1, pattern2) -> [ Term |[ CEqual(~tp1, ~tp2, ~msg) ]| ]
  	with tp1 := <type-pattern> pattern1
  	   ; tp2 := <type-pattern> pattern2
