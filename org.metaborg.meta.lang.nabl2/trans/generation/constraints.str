module generation/constraints

imports
  
  libstrc
  src-gen/signatures/rules/core/-
  src-gen/signatures/terms/-
  
rules
  
  constraint-to-strategies:
    HasType(_, type) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> type
       ; str* := <map(!|[ ~<id> := TVar(<NewTVar>) ]|)> var*
         
  constraint-to-strategies:
    c@LubType(type1, type2, type3) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> c
       ; str* := <map(!|[ ~<id> := TVar(<NewTVar>) ]|)> var*
  
  constraint-to-strategies:
    c@SubType(type1, type2) -> []
    
  var-to-strategy:
    VarRef(v) -> |[ ~v := TVar(<NewTVar>) ]|
      
  // constraint-to-strategies:
  //   Resolves(_, v) -> [ |[ ~v := DeclVar(<NewDeclVar>) ]| ]
    
  constraint-to-strategies:
    HasScope(_, v) -> [ |[ ~v := ScopeVar(<NewScopeVar>) ]| ]
  
  constraint-to-strategies:
    Match(_, pattern) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> pattern
       ; str* := <map(!|[ ~<id> := TVar(<NewTVar>) ]|)> var*
  
  constraint-to-strategies:
    Success(c, _) -> str*
    with str* := <constraint-to-strategies> c
  
  constraint-to-strategies:
    Failure(c, _) -> str*
    with str* := <constraint-to-strategies> c
    
  constraint-to-term(|pos):
    Success(c, msg) -> t
    with pos' := <message-to-term> msg
    with t    := <constraint-to-term(|pos')> c
    
  constraint-to-term(|pos):
    Failure(c, msg) -> t
    with pos' := <message-to-term> msg
    with t    := <constraint-to-term(|pos')> c
         
  message-to-term:
    Message(_, _, t) -> Term |[ <get-position> t ]|
  
  // dynamic check could be avoided with proper static analysis
  constraint-to-term(|msg):
    HasType(v, t) -> Term |[ <get-type-constraint(|tvars, ~tp, ~msg)> ~v ]|
    with tp := <try(type-pattern)> t
  
  constraint-to-term(|msg):
    LubType(t1, t2, t3) -> Term |[ CLubType(~tp1, ~tp2, ~tp3, ~msg) ]|
    with tp1 := <try(type-pattern)> t1
       ; tp2 := <try(type-pattern)> t2
       ; tp3 := <try(type-pattern)> t3
   
  constraint-to-term(|msg):
    SubType(t1, t2) -> Term |[ CSubType(~t1, ~t2, ~msg) ]|
       
  // constraint-to-term(|msg):
  //   Resolves(v, dv) -> Term |[ CResolves(~ref, ~dv, ~msg) ]|
  //   with
  //     ref := <term-to-ref> v
   
  constraint-to-term(|msg):
    HasScope(v, sv) -> Term |[ CAssoc(~v, ~sv, ~msg) ]|
   
  constraint-to-term(|msg):
  	Match(v, pattern) -> Term |[ CEqType(~v, ~tp, ~msg) ]|
  	with tp := <try(type-pattern)> pattern
  	
  type-pattern:
    TApp(tc, cp*, t*) -> Term |[ TApp(~tc', [~tp*]) ]|
    with 
      tc' := Op(tc, cp*)
    ; tp* := <alltd(try(wld-var))> t*
       
  wld-var:
  	Wld() -> Term |[ TVar(<NewTVar>) ]|
  	
rules

  term-to-decl: term -> Term |[ DeclId(None(), ~term, <get-position> ~term) ]|

  term-to-ref: term -> Term |[ RefId(None(), ~term, <get-position> ~term) ]|