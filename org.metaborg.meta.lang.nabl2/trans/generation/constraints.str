module generation/constraints

imports
  
  libstrc
  include/NameBindingLanguage2

rules
  
  constraint-to-strategies:
    HasType(_, v) -> [ |[ ~v := TVar(<NewTVar>) ]| ]
  
  constraint-to-strategies:
    Resolves(_, v) -> [ |[ ~v := DeclVar(<NewDeclVar>) ]| ]
    
  constraint-to-strategies:
    HasScope(_, v) -> [ |[ ~v := ScopeVar(<NewScopeVar>) ]| ]
  
  constraint-to-strategies:
    Match(_, pattern) -> str*
    with var* := <collect-all(?Var(_) + ?ListVar(_))> pattern
       ; str* := <map(!|[ ~<id> := TVar(<NewTVar>) ]|)> var*
    
  constraint-to-term:
    HasType(v, tv) -> Term |[ CTypeOf(~v, ~tv, <get-position> ~v) ]|
   
  constraint-to-term:
    Resolves(v, dv) -> Term |[ CResolves(~v, ~dv, <get-position> ~v) ]|
   
  constraint-to-term:
    HasScope(v, sv) -> Term |[ CAssoc(~v, ~sv, <get-position> ~v) ]|
   
  constraint-to-term:
  	Match(v, pattern) -> Term |[ CEqType(~v, ~tp, <get-position> ~v)]|
  	with tp := <try(type-pattern)> pattern
  	
  type-pattern:
  	Op(tc, t*) -> Term |[ TApp(~tc', ~tp*) ]|
  	with tc' := Str(<double-quote> tc)
  	   ; tp* := <map(try(type-pattern))> t*
  	     
  type-pattern:
  	Wld() -> Term |[ TVar(<NewTVar>) ]|
  	