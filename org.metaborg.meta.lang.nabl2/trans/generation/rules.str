module generation/rules

imports
  
  libstrc
  include/NameBindingLanguage2
  generation/visits
  generation/constraints
  generation/facts
  generation/util
  
rules // binding rules

  rules-to-str:
    Rules(r*) -> Rules(<map(rule-to-strategy)> r*)
 
  rule-to-strategy:
    Rule(pattern, With(scope*), [Where(w*), Create(c*), Visit(v*)]) ->
    |[ nabl-ts-constraint(|constraints, ~scope*):
    	   ~pattern -> <id> //(~term'',[~scope-c, ~c, ~sub-c])
         with ~ccollect
         with ~fcollect
         with ~visit
         
        //  with ?~term
        //     ; ~scope-s
        //     ; (~term',~sub-c) := <nabl-ts-traverse-children(|~scope')> ~term
        //  where ~pattern := ~term'
        //  with ~s
        //     ; a* := [~scope-a,~a]
        //     ; ~term'' := <add-annotations(|a*)> ~term'
    ]|
    with ccollect*   := <filter(constraint-to-strategy)> w*
       ; constraint* := <filter(constraint-to-terms)> w* 
       ; ccollect  := <to-seq> [ccollect*, |[ <iset-addlist(|[~constraint*])> constraints ]| ]
    with fcollect* := <filter(fact-to-strategy)> c*
       ; fact*     := <filterconcat(fact-to-terms)> c* 
       ; fcollect  := <to-seq> [fcollect*, |[ <iset-addlist(|[~fact*])> constraints ]| ]
    with visit := <not([]); map(visit-to-appl); to-seq> v*
      <+ visit := |[ nabl-ts-traverse-children(|constraints, scope) ]|
            
      //  ; term := <newname;str-var> "term"
      //  ; term' := <newname;str-var> "term"
      //  ; term'' := <newname;str-var> "term"
      //  ; (scope-s,scope',scope-c,scope-a) := <clauses-to-scopes-strategy(|scope)> clause*
      //  ; sub-c := <newname;str-list-var> "sub-c"
    	 // ; (s,c,a) := <collect-strategies( ![ <clauses-to-defines-strategy(|term',scope)>
    	 //                                    , <clauses-to-refers-strategy(|term',scope)>
    	 //                                    , <clauses-to-imports-strategy(|term',scope')>
    	 //                                    ] )> clause*