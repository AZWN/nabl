module generation/rules

imports
  
  libstrc
  signatures/rules/core/-
  signatures/terms/-
  analysis/-
  util
  generation/visits
  generation/constraints
  generation/facts
  
rules // binding rules

  rules-to-str:
    Rules(r*) -> [Rules(<map(rule-to-strategy)> r*)]
 
  rule-to-strategy:
    ScopeRule(pattern, InScopes(scope*), fact*, visit*, constr*) ->
    |[ c(|facts, constraints, scopes, position):
         term@~pattern -> ~ret
         with [~scope* | _] := scopes <+ ( debug(!$[wrong scope count [<length> scopes] for ]) ; fail )
         with ~fvar
         with ~cvar
         with <iset-addlist(|[~fcoll*])> facts
            ;  <iset-addlist(|[~ccoll*])> constraints
         with ~visit
    ]|
    with pvar*  := <collect-vars> pattern
       ; fvar   := <filterconcat(fact-to-strategies); to-seq> fact*
       ; fvar*  := <filterconcat(collect-fact-vars)> fact*
       ; cvar*  := <mapconcat(collect-constraint-vars); make-set> constr*
       ; cvar   := <diff; vars-to-init> (cvar*, <conc> (pvar*,fvar*))
       ; fcoll* := <mapconcat(fact-to-terms)> fact* 
       ; ccoll* := <mapconcat(constraint-to-terms(|<default-message>))> constr* 
       ; visit  := <map(visit-to-appl); to-seq> visit*
       ; if []:= visit* then
           c   := "nabl2-constraint"
         ; ret := |[ <fail> ]|
         else
           c   := "nabl2-scope"
         ; ret := |[ <id> ]|
         end
   rule-to-strategy:
    TypeRule(pattern, type, constr*) ->
    |[ nabl2-constraint(|facts, constraints, scopes, position):
         term@~pattern -> <fail>
         with ~var
         with <iset-addlist(|[CTypeOf(position, ~tp, ~msg), ~ccoll*])> constraints
    ]|
    with 
    	var*   := <mapconcat(collect-constraint-vars); make-set> constr*
    ; var    := <vars-to-init> var* 
    ; ccoll* := <mapconcat(constraint-to-terms(|<default-message>))> constr*
    ; tp     := <type-pattern> type
    ; msg := <default-message>
        
    vars-to-init = map(!|[ ~<id> := <new-var> ]|); to-seq
       
