module analysis/desugar

imports
  signatures/terms/-
  signatures/rules/core/-
  signatures/rules/sugar/-
  pp/rules/core/-
  util

signature constructors
  
  ScopeRule: Pattern * Context * List(Fact) * List(Scope) * Constraints -> Rule

strategies
  
  desugar-all =
    bottomup(try(desugar-nabl))
  ; alltd(inline-current-scope)
  ; alltd(explicit-new-scope)
  ; alltd(split-rules)
     
rules // rules
  
  desugar-nabl:
    ScopeRule(pattern, context, fact-scope*, constraint*) -> 
    ScopeRule(pattern, context, fact'*, scope'*, constraint'*)
    with
      (fact*, scope*) := <partition(is-Fact)> fact-scope*
    ; fact'*          := <mapconcat(explicit-decl <+ MkSingleton)> fact*
    ; scope'*         := <mapconcat(split-scoped-terms <+ MkSingleton)> scope*
    ; constraint'*    := <mapconcat(explicit-resolution <+ explicit-subset <+ MkSingleton)> constraint* 
 
  desugar-nabl:
  	TypeRule(pattern, type, constraint*) ->
    TypeRule(pattern, type, constraint'*)
  with 
  	constraint'* := <mapconcat(explicit-resolution <+ MkSingleton)> constraint* 
      
  split-scoped-terms:
  	Scope(s*, t*) -> <map(!Scope(s*, <id>))> t*
  
  split-scoped-terms:
    ImplicitNew(t*) -> <map(!ImplicitNew(<id>))> t*
  
  explicit-resolution:
  	DeclHasType(BindV(ns, r), ty, p) -> [Resolves(r, BindV(ns, Var(d)), p), HasType(VarRef(d), ty)]
    with d := <newname_> "decl"
    
  explicit-subset:
    Equals(n1,n2) -> [Subset(n1,n2),Subset(n2,n1)]
    
  explicit-decl:
    DeclarationAssoc(b, v, s, a) -> [Declaration(b,v',s),WithAssoc(v',a)]
    with
      if Wld() := v then
        v' := VarRef(<newname_> "decl")
      else
        v' := v
      end
  
  explicit-new-scope:
    ScopeRule(pattern, ctx@InScopes([Var(svar)]), fact*, scope*, constraint*) ->
    ScopeRule(pattern, ctx, fact'*, scope'*, constraint*)
    where
      <fetch(?ImplicitNew(_))> scope*
    + <fetch(?WithAssoc(_, Assoc()))> fact*
    with
      if <fetch(?NewScope(Var(s), _))> fact* then
        new* := []
      else
        s    := "new"
      ; new* := [NewScope(Var(s), VarRef(svar))]
      end
    ; fact'*  := [new* | <map(try(explicit-assoc(|s)))> fact*]
    ; scope'* := <map(try(explicit-implicit(|s)))> scope*

  explicit-assoc(|as):
    WithAssoc(t, Assoc()) -> WithAssoc(t,Assoc(VarRef(as)))
 
  explicit-implicit(|s):
    ImplicitNew(t) -> Scope([VarRef(s)], t)
    
  inline-current-scope:
    ScopeRule(_, InScopes([Var(svar)]), _, _, _) ->
    <alltd(?Current(); !VarRef(svar))>
  
  split-rules =
    Rules(mapconcat(split-rule <+ MkSingleton))

  split-rule:
    ScopeRule(pattern*, ctx, fact*, scope*, constraint*) -> 
    <map(!ScopeRule(<id>, ctx, fact*, scope*, constraint*))> pattern*

  split-rule:
    TypeRule(pattern*, type, constraint*) -> 
    <map(!TypeRule(<id>, type, constraint*))> pattern*

rules // facts
	
	desugar-nabl: 
	  NewRootScope(svar) -> NewScope(svar, Global())
	
	desugar-nabl: 
	  NewSubScope(svar) -> NewScope(svar, Current())
	
	desugar-nabl: 
	  Declaration(b, v) -> Declaration(b, v, Current())
	
	desugar-nabl: 
	  DeclarationAssoc(b, v, a) -> DeclarationAssoc(b, v, Current(), a)
	
	desugar-nabl: 
	  Reference(ref) -> Reference(ref, Current())
	
	desugar-nabl: 
	  NamedImport(label, ref, subst) -> NamedImport(label, ref, Current(), subst)
	  
  desugar-nabl: 
    DirectImport(label, scope, subst) -> DirectImport(label, scope, Current(), subst)

rules // constraints
  
  desugar-nabl:
    Resolves(n, b) -> Resolves(n, b, Wld())    
  
  desugar-nabl:
    DeclHasType(t, ty) -> DeclHasType(t, ty, Wld())    
    
rules // scopes
  
  desugar-nabl:
    SingleScope(scope, term) -> Scope([scope], term)
    
  desugar-nabl:
    InScope(scope) -> InScopes([scope])
  
  desugar-nabl:
    ImplicitScope() -> InScopes([Var("implicit")])
  
