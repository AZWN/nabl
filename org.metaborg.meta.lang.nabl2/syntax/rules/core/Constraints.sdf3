module rules/core/Constraints

imports 

  terms/Terms 
  terms/Vars
  common/Identifiers  
  rules/core/Messages
  rules/core/Facts
  rules/core/Scopes
 
context-free syntax

  Constraint         = BaseConstraint
  Constraint.Failure = <<BaseConstraint> else <Message>>

  // pseudo-constraint
  Constraint.Declares = <<Binder> declares <Var>> 

context-free syntax

  BaseConstraint.Match    = [[Pattern] == [Pattern]]
  
  BaseConstraint.Resolves = <<Term> resolves to <BinderRef> through <Var>> 
  BaseConstraint.Distinct = <<Names> are distinct>
  BaseConstraint.Subset = <<Names> are a subset of <Names>>
  BaseConstraint.Disjoint = <<Names> are disjoint from <Names>>

  Names.Declarations = <<NamespaceMatch> declarations in <ScopeRef>>
  Names.References   = <<NamespaceMatch> references in <ScopeRef>>
  Names.Visibles     = <<NamespaceMatch> visibles in <ScopeRef>>
  Names.Reachables   = <<NamespaceMatch> reachables in <ScopeRef>>
  
  NamespaceMatch     = Namespace
  NamespaceMatch.Wld = <_>
  
  BinderRef.BindV = <<Namespace> <Var>>
  
  BaseConstraint.HasScope = [[VarRef] is associated with scope [Var]]

  BaseConstraint.HasType  = <<VarRef> : <Pattern>> 
  BaseConstraint.SubType  = [[Pattern] <: [Pattern]] 
  BaseConstraint.LubType  = [[Var] == lub ([Pattern], [Pattern])] {prefer} 
 
  BaseConstraint.MakeSub    = [[Var] == [Term] |-> [Term]]
  BaseConstraint.MakeSub    = <<Var> == [<Term>/<Term>]>
  BaseConstraint.ExtractSub = [[Var] == extract ([Term])] {prefer}
  BaseConstraint.ApplySub   = [[Var] == apply ([Term], [Term])] {prefer}
  
lexical syntax

  Keyword = "where"
