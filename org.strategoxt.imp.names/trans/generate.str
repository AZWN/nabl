module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameDefinitionLanguage
  lib/editor-common.generated

rules
    
	generate-name-analysis:
		(selected, position, ast@Naming(name, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-ppable-str; to-analysis> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

    to-ppable-str = alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)
	
overlays
	
	TERM(o, args) 		= NoAnnoList(Op(o, args))
	TERM(o)       		= NoAnnoList(Op(o, []))
	TUPLE(args)  	    = NoAnnoList(Tuple(args))
	LIST(elems)   		= NoAnnoList(List(elems))
	LIST(elems, tail)   = NoAnnoList(ListTail(elems, tail))
	CALL(c)       		= CallNoArgs(SVar(c))
	CALL(c, args)    	= CallT(SVar(c), [], args)

	RULE(n, lhs, rhs, clauses) 		 = RDefNoArgs(n, Rule(lhs, rhs, clauses))
	RULE(n, args, lhs, rhs, clauses) = RDefT(n, [], args, Rule(lhs, rhs, clauses))
	
overlays
	
	PATH        = DefaultVarDec("path__")	
	PATHS       = DefaultVarDec("paths__")	
	PATHS'      = DefaultVarDec("paths'__")	
	SUBSEQUENT  = DefaultVarDec("subsequent__")
	TARGET      = CALL("target__")
	LOOKUP_PATH = CALL("lookup-index-path")
	
	DEF_DATA(uri, kind, data) = TERM("DefData", [uri, TERM(kind), data])
	IMPORT(uri1, uri2)        = DEF_DATA(uri1, "Import", uri2)
	TIMPORT(uri1, uri2)       = DEF_DATA(uri1, "TImport", uri2)
	
overlays
	
	REGULAR(ns, n)              = TERM("Regular", [ns, n])
	REGULAR(ns, n, t)           = TERM("Regular", [ns, n, t])
	CHILD(ns, n, pns, p)        = TERM("Child", [ns, n, pns, p])
	CHILD(ns, n, pns, p, t)     = TERM("Child", [ns, n, pns, p, t])
	
	ANON                        = TERM("Anon", [App(CALL("newname"), NoAnnoList(Str("anon")))])
	LOOKUP_PATH(nsv, v, path)   = WhereClause(Assign(v, LIST(path, App(LOOKUP_PATH(), TUPLE([nsv, PATHS()])))))	
    LOOKUP_PATH'(nsv, v, path)  = WhereClause(Assign(v, LIST(path, App(LOOKUP_PATH(), TUPLE([nsv, PATHS'()])))))	
    ANNOTATE_DEF(v)             = CALL("nam-annotate-def", [v])
    ANNOTATE_USE(nss)           = CALL("nam-annotate-use", [PATHS'(), LIST(nss)])
    ANNOTATE_SCOPE(v)           = CALL("nam-annotate-scope", [v])
	ANNOTATE_IMPORT(v)          = CALL("nam-annotate-use", [TERM("Unresolved", [v])])

    DEF_KEY_RULE(t, ks)         = RULE("nam-get-definition-keys", t, LIST(ks), [])
    USE_KEY_RULE(t, ks)         = RULE("nam-get-use-keys", t, LIST(ks), [])
    DEF_RULE(t, t', ds, is, cs) = RULE("nam-get-definitions", [PATHS(), PATHS'(), SUBSEQUENT()], t, TUPLE([RootApp(t'), LIST(ds), LIST(is)]), cs) 
	USE_RULE(t, t')             = RULE("nam-annotate-uses", [PATHS()], t, RootApp(t'), [])
	
overlays
	
	GEN_IMPORTS = 
		Imports(
			[ Import("lib/analysis-library")
			, Import("lib/analysis-library-internal")
			, Import("lib/index-library") 
			]
		)
			
	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	
	ADJUST_LOOKUP(term, name, adjusts, clauses) = 
		RDefT(
			  "nam-resolve"
			, [DefaultVarDec("target__")]
			, []
			, Rule(
			  	  term
			  	, LIST(adjusts)
				, [WhereClause(App(TARGET(), name))|clauses]
				)
  		)
    
rules
	
	to-stratego-term:
		cons#(args) -> TERM(cons, args)
    
    nonempty = where(Hd)
rules
	
	to-analysis:
		Naming(name, import*, rule-sec*) -> 
		Module(
			  name
			, [ GEN_IMPORTS()
			  , Imports(import*)
			  | <mapconcat(to-rules)> rule-sec*
			  ]
			)
			
	to-opdecl: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
	
	to-rules:
		ND-Namespaces(namespace*) -> [Signature([Constructors(<map(to-opdecl)> namespace*)])]
	
	to-rules:
		ND-Rules(rule*) -> <filter(to-rules)> rule*
		
	to-rules:
		ND-Rule(term, part*) -> Rules(<nonempty> [definition-rule*, scope-rule*, type-rule*])
		with
			definition-rule* := <to-definition-rules(|term)> part* ;
			scope-rule*      := <to-scope-rules(|term)> part* ;
			type-rule*       := <filter(to-type-rules(|term))> part* 

rules
			
	to-definition-rules(|term):
		part* -> result
		with
			replaces := <new-iset> ;
			(dkey*, def*, imp*, clause*) := <filter(to-definition-parts(|replaces)); unzip4> part*;
			(ukey*, rule*)               := <filter(to-reference-parts(|term, replaces)); unzip> part*;
			if <nonempty> dkey* then
				dkey-rule* := [DEF_KEY_RULE(term, dkey*)]
			else
		    	dkey-rule* := []
		    end;
		    if <nonempty> ukey* then
				ukey-rule* := [USE_KEY_RULE(term, ukey*), rule*]
			else
		    	ukey-rule* := rule*
		    end;
		    if replace* := <iset-elements; nonempty> replaces then
		    	term'  := <alltd(replace(|replace*) <+ introduce-id)> term;
				result := [DEF_RULE(term, term', def*, imp*, clause*), dkey-rule*, ukey-rule*]
			else
				result := [dkey-rule*, ukey-rule*]
			end
				
	to-definition-parts(|replaces):
		ND-Def(_, ns, name, _, def-scope, _, _) -> ([name], [TERM("Def", [v])], [], [clause])
		with
			nsv := <namespace-to-term> ns;
			v   := Var(<newname> "uri");
			<iset-add(|<to-name-replacement(|v)> name)> replaces;
			switch !def-scope
			case ?None(): 
				anon  := []
			case ?DefScope(scope*):
				anon  := [ANON()];
				<iset-addlist(|<map(to-scope-replacement(|[v]))> scope*)> replaces
			case ?OrderedScope():
				anon  := [SUBSEQUENT()]
			end;
			clause := LOOKUP_PATH(nsv, v, [nsv, name|anon])

	to-definition-parts(|replaces):
		ND-Import(ns*, ND-Ref(ns, name, _, _, _), def-scope) -> ([], [], term*, [clause|clause*])
		with
			v*     := <map(!Var(<newname> "uri"))> ns*;
			nsv    := <namespace-to-term> ns;
			v      := Var(<newname> "import");
			clause := WhereClause(Assign(v, App(ANNOTATE_USE([nsv]), name)));
			<iset-add(|(name, Build(v)))> replaces;
			switch !def-scope
			case ?None(): 
				anon := []
			case ?DefScope(scope*):
				anon := [ANON()];
				<iset-addlist(|<map(to-scope-replacement(|v*))> scope*)> replaces
			case ?OrderedScope():
				anon := [SUBSEQUENT()]
			end;
			(term*, clause*) := <zip(import-to-data(|nsv, v, anon)); unzip> (ns*, v*)
	
	import-to-data(|nsv, v, anon):
		(Transitive(ns), v') -> (TIMPORT(v', v), LOOKUP_PATH'(nsv', v', [nsv'|anon]))
		where
			nsv' := <namespace-to-term> ns
			
	import-to-data(|nsv, v, anon):
		(NonTransitive(ns), v') -> (IMPORT(v', v), LOOKUP_PATH'(nsv', v', [nsv'|anon]))
		where
			nsv' := <namespace-to-term> ns
		
	unzip4: [] -> ([], [], [], [])
	unzip4: [(h1*, h2*, h3*, h4*)|t] -> ([h1*, t1*], [h2*, t2*], [h3*, t3*], [h4*, t4*]) where (t1*, t2*, t3*, t4*) := <unzip4> t
	
	to-name-replacement(|v):
		name -> (name, ANNOTATE_DEF(v))
	to-scope-replacement(|v):
		scope -> (scope, ANNOTATE_SCOPE(LIST(v)))

rules
      
	to-reference-parts(|term, replaces):
		ND-Refs(ref*) -> (name, ADJUST_LOOKUP(term, name, resolution*, []))
  	    with
  	    	([name|_], ns*, resolution*) := <map(to-reference-part); unzip3> ref*;
  	    	<iset-add(|(name, ANNOTATE_USE(ns*)))> replaces
  	
  	to-reference-parts(|term, replaces):
		ND-Import(_, ref, _) -> (name, ADJUST_LOOKUP(term, name, [resolution], []))
		where
			(name, ns, resolution) := <to-reference-part> ref
      	
  	to-reference-part:
		ND-Ref(ns, name, None(), None(), _) -> (name, nst, REGULAR(nst, name))
		with
			nst := <namespace-to-term> ns

	to-reference-part:
		ND-Ref(ns, name, TypeBinding(t), None(), _) -> (name, nst, REGULAR(nst, name, t))
		with
			nst := <namespace-to-term> ns

	to-reference-part:
		ND-Ref(ns, name, None(), RefScope(pns, parent), _) -> (name, nst, CHILD(nst, name, pnst, parent))
		with
			nst  := <namespace-to-term> ns;
			pnst := <namespace-to-term> pns
			
	to-reference-part:
		ND-Ref(ns, name, TypeBinding(t), RefScope(pns, parent), _) -> (name, nst, CHILD(nst, name, pnst, parent, t))
		with
			nst  := <namespace-to-term> ns;
			pnst := <namespace-to-term> pns
			
	unzip3: [] -> ([], [], [])
	unzip3: [(h1, h2, h3)|t] -> ([h1|t1], [h2|t2], [h3|t3]) where (t1, t2, t3) := <unzip3> t
	
rules
		
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
		        
rules
	
	to-scope-rules(|term):
		part* -> result
		with
			if ordered* := <filter(ordered-scope); concat; nonempty> part* then
				ordered := [RULE("nam-ordered-def", term, LIST(ordered*), [])]
			else
				ordered := []
			end;
			var := Var(<newname> "anon");
			if scope* := <filter(to-scope(|var)) ; concat; nonempty> part* then
				result := [RULE("nam-get-scope-types", term, LIST(scope*), [WhereClause(Assign(var, ANON()))])|ordered]
			else
				result := ordered 
			end
				
	ordered-scope:
		ND-Def(_, ns, _, _, OrderedScope(), _, _) -> [<namespace-to-term> ns]
	
	ordered-scope:
		ND-Import(ns*, _, OrderedScope()) -> <map(inamespace-to-term)> ns*
		
	to-scope(|var): 
		ND-Def(unique, ns, name, _, _, scope*, _) -> <map(scope-to-term(|anon, <namespace-to-term> ns, name))> scope*
		with
			if Unique() := unique then
				anon := var
			else
				anon := TUPLE([])
			end
			
	to-scope(|var):
		ND-Scope(scope*) -> <map(scope-to-term)> scope*
		
	scope-to-term:
		scope -> TUPLE([t, ANON(), t, TUPLE([])])
		with 
			t := <namespace-to-term> scope
			
	scope-to-term(|unique, ns, name):
		scope -> TUPLE([ns, name, <namespace-to-term> scope, unique])
			
	namespace-to-term:
		NsRef(namespace) -> TERM(namespace)

	inamespace-to-term = 
		(?Transitive(<id>) + ?NonTransitive(<id>));
		namespace-to-term
		
rules
		
	to-type-rules(|term):
		ND-Def(_, ns, name, TypeBinding(type), _, _, clause*) -> RULE("nam-get-type", term, TUPLE([name, type]), clause'*)
		with
			clause'* := <filter(to-type-clauses)> clause*
		
rules
					
	to-type-clauses: 
		Where(term, TypeCheck(type)) -> WhereClause(Assign(type, App(CALL("type-of"), term)))

	to-resolve-clauses:
		Where(term, ReferenceCheck(NsRef(ns), name, None(), None())) -> WhereClause(Assign(TERM("Def", [LIST([TERM(ns)], name)]), App(Seq(CALL("index-find-key"), CALL("index-lookup")), term)))

