module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameDefinitionLanguage
  lib/editor-common.generated
  lib/compilation-library.generated

rules // Incremental code generation of project using compilation library.
      
	generate-name-analysis:
		(selected, position, ast@Naming(name, _, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-analysis> ast ;
			result     := <pp-stratego-string> str-module

overlays
	
	ANALYSIS_LIB = Import("lib/analysis-library.generated")
	INDEX_LIB    = Import("lib/index-library.generated")
	
	TYPE_OP_DECL = OpDecl("Type", ConstType(SortNoArgs("DefDataKind")))
	
	ADJUST_DATA(term, kind, data, clauses) = 
		RDefT(
			  "adjust-index-def-data"
			, [DefaultVarDec("store")]
			, [DefaultVarDec("namespace"), DefaultVarDec("path")]
			, Rule(
			  	  term
			  	, App(
					  CallNoArgs(SVar("store"))
					, NoAnnoList(Op("DefData", [Var("path"), NoAnnoList(Op(kind, [])), data]))
					)
				, clauses
				)
      		)
rules
	
	to-analysis:
		Naming(name, import*, namespace*, rule*) -> Module(name, [imports, sig | <filter(to-rules)> rule*])
		where
			imports := Imports([ INDEX_LIB, ANALYSIS_LIB | import*]) ;
			sig     := Signature([Constructors([TYPE_OP_DECL|<map(to-opdecl)> namespace*])])
			
	to-opdecl:
		Namespace(ns) -> OpDecl(ns, ConstType(SortNoArgs("Namespace")))
		
	to-rules:
		ND-Rule(term, part*, cond*) -> Rules(<flatten-list ; not(?[])> [definition-rule*, annotate-rule*, type-rule*])
		where
			clause*          := <filter(to-clauses)> cond* ; 
			definition-rule* := <filter(to-definition-rules(|term, clause*))> part* ;
			annotate-rule*   := <to-annotate-rules(|term, clause*) <+ ![]> part* ;
			type-rule*       := <filter(to-type-rules(|term, clause*))> part*
	
	to-clauses:
		Where(term, TypeCheck(type)) -> WhereClause(Assign(type, App(CallT(SVar("type-of"), [], []), term)))
		
	to-definition-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, _, None()) ->
		[ RDefNoArgs(
			  "nam-get-definition-key"
			, Rule(term, name, clause*)
			)
		, RDefNoArgs(
			  "nam-get-definition"
			, Rule(
				term
				, App(
					CallT(SVar("nam-get-def"), [], [NoAnnoList(Op(namespace, []))])
					, name
					)
				, clause*
				)
			)
		]

	to-annotate-rules(|term, clause*):
		part* -> result
		where
			replacement* := <filter(to-annotate-replacement)> part* ;
			if <?[]> replacement* then
				result := [] 
			else
				result := [SDefT("nam-annotate-names", [], [DefaultVarDec("path")], <alltd(replace(|replacement*) <+ introduce-id)> term)]
			end
		
	to-annotate-replacement:
		ND-Def(_, name, _, None())-> (name, CallT(SVar("nam-annotate-def"), [], [Var("path")]))
			
	to-annotate-replacement:
		ND-Ref(NsRef(namespace), name, _, None()) -> (name, CallT(SVar("nam-annotate-use"), [], [NoAnnoList(Op(namespace, []))]))
			
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()  -> Id()
	introduce-id: Var(_) -> Id()
	
	to-type-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, TypeBinding(type), _) -> ADJUST_DATA(term, "Type", type, clause*)
		

		
	