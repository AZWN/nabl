module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameDefinitionLanguage
  lib/editor-common.generated

rules
      
	generate-name-analysis:
		(selected, position, ast@Naming(name, _, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-analysis> ast ;
			result     := <pp-stratego-string> str-module

overlays
	
	TERM(o, args) = NoAnnoList(Op(o, args))
	TERM(o)       = NoAnnoList(Op(o, []))
	TUPLE(args)   = NoAnnoList(Tuple(args))
	LIST(elems)   = NoAnnoList(List(elems))
	CALL(c)       = CallNoArgs(SVar(c))
	CALL(c, t)    = CallT(SVar(c), [], [t])

	RULE(n, lhs, rhs, clauses) = RDefNoArgs(n, Rule(lhs, rhs, clauses))

	ANON()        = TERM("Anon")
			
overlays
	
	GEN_IMPORTS = 
		Imports(
			[ Import("lib/analysis-library")
			, Import("lib/analysis-library-internal")
			, Import("lib/index-library") 
			]
		)
	GEN_CONSTRUCTORS = Constructors([CONS_DECL("Type", "DefDataKind")])
		
	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	
	ADJUST_DATA(term, kind, data, clauses) = 
		RDefT(
			  "adjust-index-def-data"
			, [DefaultVarDec("store")]
			, [DefaultVarDec("namespace"), DefaultVarDec("path")]
			, Rule(
			  	  term
			  	, App(CALL("store"), TERM("DefData", [Var("path"), TERM(kind), data]))
				, clauses
				)
      		)

rules
	
	to-analysis:
		Naming(name, import*, namespace*, rule*) -> 
		Module(
			  name
			, [ GEN_IMPORTS()
			  , Imports(import*)
			  , Signature([GEN_CONSTRUCTORS(), Constructors(<map(to-opdecl)> namespace*)])
			  | <filter(to-rules)> rule*
			  ]
			)
			
	to-opdecl:
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
		
	to-rules:
		ND-Rule(term, part*, cond*) -> Rules(<not(?[])> [scope-rule*, definition-rule*, annotate-rule*, type-rule*])
		where
			clause1*         := <filter(to-clauses)> part* ;
			clause2*         := <filter(to-clauses)> cond* ; 
			clause*          := <conc> (clause1*, clause2*) ;
			scope-rule*      := <to-scope-rules(|term, clause*)> part* ;
			definition-rule* := <filter(to-definition-parts) ; unzip ; to-definition-rules(|term, clause*)> part* ;
			annotate-rule*   := <to-annotate-rules(|term, clause*)> part* ;
			type-rule*       := <filter(to-type-rules(|term, clause*)) ; concat> part*

rules
				
	to-clauses:
		ND-Ref(_, name, TypeBinding(type), _) -> 
		WhereClause(
			Assign(
				  NoAnnoList(List([type]))
				, App(Seq(CALL("index-lookup"), CALL("index-get-data-all", TERM("Type"))), name)
				)
			)
		
	to-clauses:
		Where(term, TypeCheck(type)) -> WhereClause(Assign(type, App(CALL("type-of"), term)))

rules
	
	to-scope-rules(|term, clause*):
		part* -> result
			where
			scope* := <filter(to-scope)> part* ;
			if <?[]> scope* then
				result := [] 
			else
				result := [RULE("nam-get-scope-types", term, List(scope*), clause*)]
			end
	
	to-scope:
		ND-Scope(NsRef(namespace)) -> TERM(namespace)
			
rules
			
	to-definition-parts:
		ND-Def(NsRef(namespace), name, _, None(), _) -> (name, TUPLE([TERM(namespace), name]))
	
	to-definition-rules(|term, clause*):
		(key-part*, def-part*) ->
		[ RULE("nam-get-definition-keys", term, LIST(<make-set> key-part*), clause*)
		, RULE("nam-get-definitions",     term, LIST(<make-set> def-part*), clause*) ]
		where
			<Hd> key-part* ; <Hd> def-part*

	to-definition-rules(|term, clause*):
		([], []) -> []
rules
	
	to-annotate-rules(|term, clause*):
		part* -> result
		where
			replacement* := <filter(to-annotate-replacement)> part* ;
			if <?[]> replacement* then
				result := [] 
			else
				result := [SDefNoArgs("nam-annotate-names", <alltd(replace(|replacement*) <+ introduce-id)> term)]
			end
		
	to-annotate-replacement:
		ND-Def(NsRef(namespace), name, _, None(), _)-> (name, CALL("nam-annotate-def", TERM(namespace)))
			
	to-annotate-replacement:
		ND-Ref(NsRef(namespace), name, _, None()) -> (name, CALL("nam-annotate-use", TERM(namespace)))
			
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()  -> Id()
	introduce-id: Var(_) -> Id()

rules
		
	to-type-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, TypeBinding(type), _, _) -> 
		[ ADJUST_DATA(term, "Type", type, clause*)
		, RULE("type-of", term, type, clause*) ]
		
	to-type-rules(|term, clause*):
		ND-Type(type) -> [RULE("type-of", term, type, clause*)]
		