module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameDefinitionLanguage
  lib/editor-common.generated

rules
      
	generate-name-analysis:
		(selected, position, ast@Naming(name, _, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-analysis> ast ;
			result     := <pp-stratego-string> str-module

overlays
	
	TERM(o, args) 		= NoAnnoList(Op(o, args))
	TERM(o)       		= NoAnnoList(Op(o, []))
	TUPLE(args)  		= NoAnnoList(Tuple(args))
	LIST(elems)   		= NoAnnoList(List(elems))
	LIST(elems, tail)   = NoAnnoList(ListTail(elems, tail))
	CALL(c)       		= CallNoArgs(SVar(c))
	CALL(c, args)    	= CallT(SVar(c), [], args)

	RULE(n, lhs, rhs, clauses) 		 = RDefNoArgs(n, Rule(lhs, rhs, clauses))
	RULE(n, args, lhs, rhs, clauses) = RDefT(n, [], args, Rule(lhs, rhs, clauses))

	ANON          = TERM("Anon", [RootApp(CALL("new"))])
			
overlays
	
	GEN_IMPORTS = 
		Imports(
			[ Import("lib/analysis-library")
			, Import("lib/analysis-library-internal")
			, Import("lib/index-library") 
			]
		)
	GEN_CONSTRUCTORS = Constructors([CONS_DECL("Type", "DefDataKind")])
		
	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	
	ADJUST_DATA(term, kind, data, clauses) = 
		RDefT(
			  "adjust-index-def-data"
			, [DefaultVarDec("store__")]
			, [DefaultVarDec("namespace__"), DefaultVarDec("path__")]
			, Rule(
			  	  term
			  	, App(CALL("store__"), TERM("DefData", [Var("path__"), TERM(kind), data]))
				, clauses
				)
      		)

	ADJUST_LOOKUP(term, paths, clauses) = 
		RDefT(
			  "adjust-index-lookup"
			, [DefaultVarDec("target__")]
			, [DefaultVarDec("namespace__"), DefaultVarDec("path__"), DefaultVarDec("prefix__")]
			, Rule(
			  	  term
			  	, LIST(paths)
				, clauses
				)
      		)

overlays 
	
    ANNOTATE_DEF             = CALL("nam-annotate-def", [Var("path__")])
    ANNOTATE_USE(ns)         = CALL("nam-annotate-use", [TERM(ns)])
    ANNOTATE_USE(ns, ns2, n) = CALL("nam-annotate-use", [TERM(ns), TERM(ns2), n])
    ANNOTATE_SCOPE           = CALL("nam-annotate-scope", [Var("path__")])
    LOOKUP_TYPE              = ""
    	
rules
	
	to-analysis:
		Naming(name, import*, namespace*, rule*) -> 
		Module(
			  name
			, [ GEN_IMPORTS()
			  , Imports(import*)
			  , Signature([GEN_CONSTRUCTORS(), Constructors(<map(to-opdecl)> namespace*)])
			  | <filter(to-rules)> rule*
			  ]
			)
			
	to-opdecl: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
		
	to-rules:
		ND-Rule(term, part*, cond*) -> Rules(<not(?[])> [scope-rule*, definition-rule*, annotate-rule*, adjust-rule*, type-rule*, check-rule*])
		where
			clause1*         := <filter(to-clauses)> part* ;
			clause2*         := <filter(to-clauses)> cond* ; 
			clause*          := <conc> (clause1*, clause2*) ;
			scope-rule*      := <to-scope-rules(|term, clause*)> part* ;
			definition-rule* := <filter(to-definition-parts) ; unzip ; to-definition-rules(|term, clause*)> part* ;
			annotate-rule*   := <to-annotate-rules(|term, clause*)> part* ;
			adjust-rule*     := <to-adjust-rules(|term, clause*)> part* ;
			type-rule*       := <filter(to-type-rules(|term, clause*)) ; concat> part* ;
			check-rule*      := <filter(to-check-rules(|term, clause*))> part*

rules
				
	to-clauses: //might not be the right solution, should be a filter on definition candidates
		ND-Ref(_, name, TypeBinding(type), _) -> 
		WhereClause(
			Assign(
				  NoAnnoList(List([type]))
				, App(Seq(CALL("index-lookup"), CALL("index-get-data-all", [TERM("Type")])), name)
				)
			)
		
	to-clauses: 
		Where(term, TypeCheck(type)) -> WhereClause(Assign(type, App(CALL("type-of"), term)))

	to-clauses:
		Where(term, ReferenceCheck(NsRef(ns), name, None(), None())) -> WhereClause(Assign(TERM("Def", [LIST([TERM(ns)], name)]), App(Seq(CALL("index-find-key"), CALL("index-lookup")), term)))

rules
	
	to-scope-rules(|term, clause*):
		part* -> result
			where
			scope* := <filter(to-scope)> part* ;
			if <?[]> scope* then
				result := [] 
			else
				result := [RULE("nam-get-scope-types", term, List(scope*), clause*)]
			end
	
	to-scope:
		ND-Scope(NsRef(namespace)) -> TERM(namespace)
			
rules
			
	to-definition-parts:
		ND-Def(NsRef(namespace), name, _, None(), _) -> (name, TUPLE([TERM(namespace), LIST([name])]))
	
	to-definition-parts:
		ND-Def(NsRef(namespace), name, _, DefScope(_), _) -> (name, TUPLE([TERM(namespace), LIST([name, ANON()])]))
	
	to-definition-rules(|term, clause*):
		(key-part*, def-part*) ->
		[ RULE("nam-get-definition-keys", term, LIST(<make-set> key-part*), clause*)
		, RULE("nam-get-definitions",     term, LIST(<make-set> def-part*), clause*) ]
		where
			<Hd> key-part* ; <Hd> def-part*

	to-definition-rules(|term, clause*):
		([], []) -> []
rules
	
	to-annotate-rules(|term, clause*):
		part* -> result
		where
			replacement1* := <filter(to-name-replacement)> part* ;
			if <?[]> replacement1* then
				rule1 := [] 
			else
				rule1 := [RULE("nam-annotate-names", [DefaultVarDec("path__")], term, RootApp(<alltd(replace(|replacement1*) <+ introduce-id)> term), clause*)]
			end ;
			replacement2* := <filter(to-scope-replacement) ; concat> part* ;
			if <?[]> replacement2* then
				result := rule1 
			else
				result := [RULE("nam-annotate-scopes", [DefaultVarDec("path__")], term, RootApp(<alltd(replace(|replacement2*) <+ introduce-id)> term), clause*)|rule1]
			end
			
	to-scope-replacement:
		ND-Def(NsRef(namespace), name, _, DefScope(scope*), _) -> <map(!(<id>, ANNOTATE_SCOPE()))> scope*
		
	to-name-replacement:
		ND-Def(NsRef(namespace), name, _, _, _)-> (name, ANNOTATE_DEF())
			
	to-name-replacement:
		ND-Ref(NsRef(namespace), name, _, None()) -> (name, ANNOTATE_USE(namespace))
	
	to-name-replacement:
		ND-Ref(NsRef(ns), name, _, RefScope(NsRef(ns2), name2)) -> (name, ANNOTATE_USE(ns, ns2, name2))
			
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()  -> Id()
	introduce-id: Var(_) -> Id()

rules
	
	to-adjust-rules(|term, clause*):
		part* -> result
		where
			paths := <filter(to-adjust-path)> part* ;
			if <?[_, _|_]> paths then
				name := <fetch-elem(?ND-Ref(_, <id>, _, _))> part* ;
				result      := [ADJUST_LOOKUP(term, paths, [WhereClause(App(CALL("target__"), name))|clause*])]
			else
				result := []
			end
	
	to-adjust-path:
		ND-Ref(NsRef(namespace), name, _, None()) -> LIST([TERM(namespace)], Var("path__"))	

		
rules
		
	to-type-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, TypeBinding(type), _, _) -> 
		[ ADJUST_DATA(term, "Type", type, clause*)
		, RULE("type-of", term, type, clause*) ]
		
	to-type-rules(|term, clause*):
		ND-Type(type) -> [RULE("type-of", term, type, clause*)]
		
rules
	
	to-check-rules(|term, clause*):
		ND-Def(_, _, _, _, Annos(annos)) -> RULE("nam-unique", term, RootApp(Id()), clause*)
		where
			<not(fetch-elem(?NonUnique()))> annos 
		