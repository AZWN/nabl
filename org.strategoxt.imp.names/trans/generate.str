module generate

imports
	libstrc
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/NameDefinitionLanguage
  lib/editor-common.generated
  lib/compilation-library.generated

rules // Incremental code generation of project using compilation library.
      
	generate-name-analysis:
		(selected, position, ast@Naming(name, _, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <to-analysis> ast ;
			result     := <pp-stratego-string> str-module

overlays
	
	ANALYSIS_LIB = Import("lib/analysis-library.generated")
	INDEX_LIB    = Import("lib/index-library.generated")
	
	TYPE_OP_DECL = OpDecl("Type", ConstType(SortNoArgs("DefDataKind")))
	
	ADJUST_DATA(term, kind, data, clauses) = 
		RDefT(
			  "adjust-index-def-data"
			, [DefaultVarDec("store")]
			, [DefaultVarDec("namespace"), DefaultVarDec("path")]
			, Rule(
			  	  term
			  	, App(
					  CallNoArgs(SVar("store"))
					, NoAnnoList(Op("DefData", [Var("path"), NoAnnoList(Op(kind, [])), data]))
					)
				, clauses
				)
      		)
rules
	
	to-analysis:
		Naming(name, import*, namespace*, rule*) -> Module(name, [imports, sig | <filter(to-rules)> rule*])
		where
			imports := Imports([ INDEX_LIB, ANALYSIS_LIB | import*]) ;
			sig     := Signature([Constructors([TYPE_OP_DECL|<map(to-opdecl)> namespace*])])
			
	to-opdecl:
		Namespace(ns) -> OpDecl(ns, ConstType(SortNoArgs("Namespace")))
		
	to-rules:
		ND-Rule(term, part*, cond*) -> Rules(<flatten-list ; not(?[])> [scope-rule*, definition-rule*, annotate-rule*, type-rule*])
		where
			clause1*         := <filter(to-clauses)> part* ;
			clause2*         := <filter(to-clauses)> cond* ; 
			clause*          := <conc> (clause1*, clause2*) ;
			scope-rule*      := <to-scope-rules(|term, clause*)> part* ;
			definition-rule* := <filter(to-definition-rules(|term, clause*))> part* ;
			annotate-rule*   := <to-annotate-rules(|term, clause*)> part* ;
			type-rule*       := <filter(to-type-rules(|term, clause*))> part*

rules
				
	to-clauses:
		ND-Ref(_, name, TypeBinding(type), _) -> 
		WhereClause(
			Assign(
				  NoAnnoList(List([type]))
				, App(
				  	  Seq(
				  	  	  CallNoArgs(SVar("index-lookup"))
				  		, CallT(SVar("index-get-data-all"), [], [NoAnnoList(Op("Type", []))])
				  		)
				  	, name)
				)
			)
		
	to-clauses:
		Where(term, TypeCheck(type)) -> WhereClause(Assign(type, App(CallT(SVar("type-of"), [], []), term)))

rules
	
	to-scope-rules(|term, clause*):
		part* -> result
			where
			scope* := <filter(to-scope)> part* ;
			if <?[]> scope* then
				result := [] 
			else
				result := [RDefNoArgs("nam-get-scope-types", Rule(term, List(scope*), clause*))]
			end
	
	to-scope:
		ND-Scope(_, NsRef(namespace), None()) -> NoAnnoList(Op(namespace, []))
			
rules
			
	to-definition-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, _, None()) ->
		[ RDefNoArgs(
			  "nam-get-definition-key"
			, Rule(term, name, clause*)
			)
		, RDefNoArgs(
			  "nam-get-definition"
			, Rule(
				term
				, App(
					CallT(SVar("nam-get-def"), [], [NoAnnoList(Op(namespace, []))])
					, name
					)
				, clause*
				)
			)
		]

rules
	
	to-annotate-rules(|term, clause*):
		part* -> result
		where
			replacement* := <filter(to-annotate-replacement)> part* ;
			if <?[]> replacement* then
				result := [] 
			else
				result := [SDefT("nam-annotate-names", [], [DefaultVarDec("path")], <alltd(replace(|replacement*) <+ introduce-id)> term)]
			end
		
	to-annotate-replacement:
		ND-Def(_, name, _, None())-> (name, CallT(SVar("nam-annotate-def"), [], [Var("path")]))
			
	to-annotate-replacement:
		ND-Ref(NsRef(namespace), name, _, None()) -> (name, CallT(SVar("nam-annotate-use"), [], [NoAnnoList(Op(namespace, []))]))
			
	replace(|replacement*): t1 -> t2 where <fetch-elem(?(t1, t2))> replacement*
	
	introduce-id: Wld()  -> Id()
	introduce-id: Var(_) -> Id()

rules
		
	to-type-rules(|term, clause*):
		ND-Def(NsRef(namespace), name, TypeBinding(type), _) -> 
		[ ADJUST_DATA(term, "Type", type, clause*)
		, RDefNoArgs("type-of", Rule(term, type, clause*)) ]
		
	to-type-rules(|term, clause*):
		ND-Type(type) -> RDefNoArgs("type-of", Rule(term, type, clause*))
	
		
	