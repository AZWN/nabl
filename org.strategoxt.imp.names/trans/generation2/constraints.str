module generation2/constraints

imports 
  
  libstrc
  include/NameBindingLanguage
  generation2/util
  generation2/main
  
rules
  
  cdebug(s) = debug(s)
  
  constraints-to-str(|repl*, b*, i) =  constraints-to-str(|repl*, b*, 0, i)
  constraints-to-str(|repl*, b*, i, j):
  	[] -> (repl*, b*, [], [])
  
  constraints-to-str(|repl*, b*, i, j):
  	[c|cs] -> (r2*, b2*, [rule1*, rule2*], [task1*, task2*])
  	where
    	(r1*, b1*, rule1*, task1*) := <constraint-to-str(|repl*, b*, i, j)> c;
      (r2*, b2*, rule2*, task2*) := <constraints-to-str(|r1*, b1*, i, <inc> j)> cs
  		
  constraint-to-str(|repl*, bound*, i, j):  
    PropertyConstraint(term, kind, prop) -> ([match-repl*, repl*], <union> (bound*, prop-bound*), match-rule*, [task, match-assign*])
    where
      <map(cdebug(!"repl: "))> repl*
    ; <map(cdebug(!"bound: "))>bound*
    ; <cdebug(!"term: ")> term
    ; <cdebug(!"kind: ")> kind
    ; <cdebug(!"prop: ")> prop
    where
      // create new task for property calculation
      result      := <extend-index(|i); result-var> j;
      task        := PROP_TASK(result, <nabl-to-str> kind, <replace-all(|repl*)> term);
      prop-bound* := <bound-vars> prop;
      prev-bound* := <isect> (prop-bound*, bound*);
      <cdebug(!"task: ")> task;
      <map(cdebug(!"prop-bound: "))> prop-bound*;
      <map(cdebug(!"prev-bound: "))> prev-bound*;
      if 
        Var(_) := prop;
        []     := prev-bound* 
      then // single unbound variable is replaced with result
        cdebug(!"SINGLE ")
      ; match-repl*   := [(prop, result)]
      ; match-assign* := []
      ; match-rule*   := []
      else
        cdebug(!"MATCH ")
      ; k := $[[i]-[j]]
      ; match-repl*   := <map-with-index(match-replace(|k))> prop-bound*
      ; match-assign* := <map-with-index(match-task(|k, <replace-all(|repl*)> result, <replace-all(|repl*)> prev-bound*))> match-repl*
      ; match-rule*   := <map-with-index(match-rule(|k, prop, prev-bound*))> prop-bound*
      end
      ; <map(cdebug(!"m-repl: "))> match-repl*
      
  var-to-match-task: (i, Var(v)) -> <id>
  
  match-replace(|i)           : (j, t)      -> (t, <extend-index(|i); result-var> j)
  match-task(|i, term, bound*): (j, (_, r)) -> MATCH_TASK(r, <extend-index(|i); match-name> j, bound*, term)
  match-rule(|i, term, bound*): (j, t)      -> MATCH_RULE(<extend-index(|i); match-name> j, term, bound*, t)
    
  result-var: i-> Var($[r[i]__])
  match-name: i -> $["match[i]"]
  
  extend-index(|i): j -> $[[i]-[j]]

  nabl-match: ("m", Var(x), [y,z]) -> x
  
overlays
    
  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([NoAnnoList(Str(n)), lhs, LIST(bnd)]), rhs))

  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [NoAnnoList(Str(n)), LIST(b), t]))
  
  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
  
  NEW_TASK(t) =
  App(
    CallT(SVar("new-task"), [], [Var("tasks__")])
  , t
  )