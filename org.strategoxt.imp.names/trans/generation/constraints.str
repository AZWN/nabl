module generation/constraints

imports 
  
  libstrc
  include/NameBindingLanguage
  generation/util
  generation/main
  
rules
  
  constraints-to-str(|replace*, bound*, rule*, n) = 
    map-with-index(to-ppable-str; constraint-to-str(|replace*, bound*, rule*, n));
    concat <+ []
  
  constraint-to-str(|replace*, bound*, rule*, i):  
    (j, Constraint(t1, PropertyCond(p, t2))) -> [PROP_TASK(r, <nabl-to-str> p, <alltd(replace(|replace*))> t1), match*]
    where
      // create new task for property calculation
      n := <addi> (i, j);
      r := Var($[pr[n]]);
      if 
        Var(v) := t2;
        <not(iset-contains(|t2))> bound* 
     then // single unbound variable is replaced with result
        <hashtable-put(|Var(v), r)> replace*;
        <iset-add(|Var(v))> bound*;
        match* := []
      else
      	var*   := <collect-all(?Var(_))> t2;
      	bvar*  := <isect> (var*, <iset-elements> bound*);
      	match* := <map-with-index(match-to-str(|replace*, bound*, rule*, t2, r, bvar*, n))> var*
      end
  
   match-to-str(|replace*, bound*, rule*, term, res, bvar*, i):
  	(j, Var(v)) -> MATCH_TASK(r, mn, bvar'*, res)
    where
    	mn     := NoAnnoList(Str(<newname; double-quote> "match"));
    	r      := Var($[mr[i]_[j]]);
    	bvar'* := <alltd(replace(|replace*))> bvar*;
    	<hashtable-put(|Var(v), r)> replace*;
    	<iset-add(|Var(v))> bound*;
    	<iset-add(|MATCH_RULE(mn, term, bvar*, Var(v)))> rule*
      
overlays
    
  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))

  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
  
  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
  
  NEW_TASK(t) =
  App(
    CallT(SVar("new-task"), [], [App(CallNoArgs(SVar("task-in-context")), Var("context"))])
  , t
  )