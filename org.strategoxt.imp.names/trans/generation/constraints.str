module generation/constraints

imports 
  
  libstrc
  include/NameBindingLanguage
  generation/util
  generation/main
  
rules
  
  constraints-to-str: 
    ([], (bnd*, rep*, n, str)) -> (bnd*, rep*, n, str, [])
  
  constraints-to-str: 
    ([c | cs ], (bnd*, rep*, n, prev)) -> (bnd3*, rep3*, n3, Seq(prev, cont), [r1*, r2*])
    where
      (bnd2*, rep2*, n2, curr, r1*) := <constraint-to-str(|bnd*, rep*, n)> c;
      (bnd3*, rep3*, n3, cont, r2*) := <constraints-to-str> (cs, (bnd2*, rep2*, n2, curr))    

  constraint-to-str(|bnd*, rep*, n):  
    Constraint(t1, PropertyCond(p, t2)) -> result
    where
      // create new task for property calculation
      r  := Var($[r[n]]);
      p' := <nabl-to-str> p;
      t3 := <alltd(replace(|rep*))> t1;
      pt := PROP_TASK(r, p', t3);
      if 
        Var(v) := t2;
        <not(elem)> (v, bnd*) 
     then // single unbound variable is replaced with result
        result := ( [v, bnd*]
                  , [(Var(v), r), (VarRef(v), r), rep*]
                  , <inc> n
                  , pt
                  , []
                  )
      else
      	var*   := <collect-all(?Var(<id>))> t2;
      	bvar*  := <isect; map(!Var(<id>))> (var*, bnd*);
      	result := <matches-to-str(|t2, r, bvar*)> (var*, bnd*, rep*, <inc> n, pt)
      end
  
  matches-to-str(|term, res, bvar*):
  	([], bnd*, rep*, n, pt) -> (bnd*, rep*, n, pt, [])
 
  matches-to-str(|term, res, bvar*):
  	([v|vs], bnd*, rep*, n, prev) -> (bnd3*, rep3*, n3, Seq(prev, cont), [mr, r*])
    where
    	mn    := NoAnnoList(Str(<newname; double-quote> "match"));
    	r     := Var($[r[n]]);
    	bvar2*:= <alltd(replace(|rep*))> bvar*;
    	mt    := MATCH_TASK(r, mn, bvar2*, res);
    	mr    := MATCH_RULE(mn, term, bvar*, Var(v));
    	bnd2* := [v, bnd*];
    	rep2* := [(Var(v), r), (VarRef(v), r), rep*];
    	n2    := <inc> n;
    	(bnd3*, rep3*, n3, cont, r*) := <matches-to-str(|term, res, bvar*)> (vs, bnd2*, rep2*, n2, mt)
      
overlays
    
  MATCH_RULE(n, lhs, bnd, rhs) = RDefNoArgs("nabl-match", RuleNoCond(TUPLE([n, lhs, LIST(bnd)]), rhs))

  PROP_TASK(v, p, t)     = NEW_TASK(v, TERM("PropCalc", [p, t]))
  MATCH_TASK(v, n, b, t) = NEW_TASK(v, TERM("Match", [n, LIST(b), t]))
  
  NEW_TASK(v, t) = Where(Assign(v, NEW_TASK(t)))
  
  NEW_TASK(t) =
  App(
    CallT(SVar("new-task"), [], [App(CallNoArgs(SVar("task-in-context")), Var("context"))])
  , t
  )