module generation/def-sites

imports
  
  libstrc
  include/NameBindingLanguage
  
  generation/util
  generation/main
  generation/constraints
  
rules // definitions, scopes, properties
  def-to-str(|replace*, bound*, rule*, task*, pattern, scopes):
    DefClause(k, u, ns, t, ps, ds, constr*) -> <id>
    where  
      // replace name with callback to handle definition site
      t' := <to-ppable-str> t;
      r  := ( t', DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes) )
    where 
      // when we have external scopes in a "defines ... in ..." clause, 
      // replace these external scopes with callbacks
      r* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
      // callback to determine external scope 
      sc := SCOPE_CALL(<nabl-to-str> ns);
      // apply all replacements and generate a rule handling this definition site
      <iset-add(|DEF_RULE(Match(pattern), Seq(sc, <replace-all(|[r, r*])> pattern)))> rule* <+
      // otherwise replace only the name and
      // generate a rule handling this defintion site
      <iset-add(|DEF_RULE(Match(pattern), <replace-all(|[r])> pattern))> rule*
    where
    	<iset-add(|NAME_RULE(pattern, t'))> rule*
    where try(
      // when this definition site defines properties,
      // construct sequence of property calculatations
      // and a callback
      task'* := <constraints-to-str(|replace*, bound*, rule*, task*)> constr*;
      pcall  := <alltd(replace(|replace*))> PROP_CALL(<nonempty; map(prop-to-str)> ps);
      pcall' := <replace-all(|[(t', pcall)])> pattern;
      // generate a rule handling properties at this definition site
      pbody  := <foldr(!pcall', to-seq)> task'* ;
      <iset-add(|PROP_RULE(Seq(Match(pattern), pbody)))> rule* 
    )
    
  def-scope-to-str:
    Context(x) -> (<to-ppable-str> x, SCOPE_CALL())      

  prop-to-str:
    PropertyTerm(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)     

  nabl-to-str: Current() -> TERM("Current")
  nabl-to-str: 
    DefScopes(ds) -> LIST([sc1*, sc2*])
    where
      if <fetch-elem(?Context(_))> ds then
        sc1* := [SCOPE()]
      else
        sc1* := []
      end;
      if <fetch-elem(?Subsequent())> ds then
        sc2* := [TERM("Subsequent")]
      else
        sc2* := []
      end
    
  nabl-to-str: NonUnique() -> TERM("NonUnique")
  nabl-to-str: Unique()    -> TERM("Unique")
  
overlays
  
  DEF_RULE(match, call) =
  SDefT(
    "nabl-def-site"
  , [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
  , [ DefaultVarDec("lang")
    , DefaultVarDec("partition")
    , DefaultVarDec("uniques")
    , DefaultVarDec("elems")
    , DefaultVarDec("uris")
    , DefaultVarDec("states")]
  , Seq(match, call)
  )
  
  NAME_RULE(lhs, rhs) = RDefNoArgs("nabl-get-name", RuleNoCond(lhs, rhs))
	
  DEF_CALL(ns, u, ds, s) = 
  CallT(
    SVar("nabl-def")
  , [CALL("child-uris"), CALL("sibl-uris")]
  , [ Var("lang")
    , Var("partition")
    , Var("uniques")
    , Var("elems")
    , Var("uris")
    , ns, u, ds, LIST(s)]
  )

  SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
  SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-construct-def-scope"), [], [Var("lang"), Var("partition"), Var("uniques")]), ns)))
    
  PROP_RULE(body) =
  SDefT(
    "nabl-prop-site"
  , []
  , [ DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("states")]
  , body
  )
  
  PROP_CALL(ps) = 
  CallT(
    SVar("nabl-props")
  , []
  , [ Var("elems"), LIST(ps)]
  )
  
  PROPERTY(p, v) = TERM("Prop", [p, v])

