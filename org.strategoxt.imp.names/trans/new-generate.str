module new-generate

imports 
	
	libstrc
  include/NameBindingLanguage

rules
	
	generate-name-analysis:
		(selected, position, ast@Module(name, _, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <nabl-to-str; to-ppable-str> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

  to-ppable-str = alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)

rules // modules
	
	nabl-to-str:
		Module(name, _, sections) -> Module(name, <filter(nabl-to-str)> sections)
		
rules // namespaces 
			
	nabl-to-str:
		Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
		
	nabl-to-str: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
	
	nabl-to-str: NamespaceRef(ns) -> TERM(ns)

rules // properties
				
	nabl-to-str:
		Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
	
	nabl-to-str: // generate constructors for properties
		Property(prop, _, _) -> CONS_DECL(prop, "Property")	

	nabl-to-str: PropertyRef(p) -> TERM(p)
	nabl-to-str: TypeProp()     -> TERM("Type")

rules // imports
		
	nabl-to-str = Imports(id)
		
rules // binding rules

	nabl-to-str:
		BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
			
rules // definitions, scopes, properties
		
	// TODO: support multiple definition sites
	nabl-to-str: 
		BindingRule(pattern, parts) -> [defscope*, use*]
		where
			scopes := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
		where
			defscope* := <fetch-elem(def-to-str(|pattern, scopes))> parts <+
			defscope* := [SCOPE_RULE(pattern, <nonempty> scopes)] <+
			defscope* := []
		where
			use* := <filter(use-to-str(|pattern))> parts
			
	// TODO: support conditions 
	def-to-str(|pattern, scopes):
		DefSite(u, NameBinding(ns, t), ps, ds, []) -> [dr, pr*]
		where
			replace := ( <to-ppable-str> t 
			           , DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes)
			           )
		where
			replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
			sc       := SCOPE_CALL(<nabl-to-str> ns);
			dr       := DEF_RULE(pattern, sc, <replace-all(|[replace, replace*])> pattern) <+
			dr       := DEF_RULE(pattern, <replace-all(|[replace])> pattern)
		where
			preplace := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
			pr*      := [PROP_RULE(pattern, <replace-all(|[preplace])> pattern)] <+
			pr*      := []

	use-to-str(|pattern):
		UseSite(refs) -> <refs-to-str(|pattern)> refs
	
	
	use-to-str(|pattern):
		Import(_, [], ref, _) -> <refs-to-str(|pattern)> [ref]
			
	// TODO: support properties
	// TODO: support conditions
	refs-to-str(|pattern):	
		refs -> USE_RULE(pattern, <replace-all(|[replace])> pattern)
		where
			Hd => Reference(NameBinding(_, t), _, _, _);
			replace := (<to-ppable-str> t, USE_CALL(<filter(ref-to-str); nonempty> refs))
		 		
	ref-to-str: 
		Reference(NameBinding(ns, _), [], All(), []) -> CANDIDATE(<nabl-to-str> ns)
	
	ref-to-str: 
		Reference(NameBinding(ns, _), [], RefScope(NameBinding(ns', t), _, _), []) -> CANDIDATE(<nabl-to-str> ns, <nabl-to-str> ns', <to-ppable-str> t)
	
	
	nabl-to-str: Current() -> TERM("Current")
	nabl-to-str: 
		DefScopes(ds)	-> LIST([sc1*, sc2*])
		where
			if <fetch-elem(?DefScope(_))> ds then
				sc1* := [SCOPE()]
			else
				sc1* := []
			end;
			if <fetch-elem(?Subsequent())> ds then
				sc2* := [TERM("Subsequent")]
			else
				sc2* := []
			end
	 	
	nabl-to-str: NonUnique() -> TERM("NonUnique")
	nabl-to-str: Unique()    -> TERM("Unique")
	
	prop-to-str:
		PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)			
	
	def-scope-to-str:
		DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())			
			
overlays

	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	TERM(o, args) 	= NoAnnoList(Op(o, args))
	TERM(o) 	      = TERM(o, [])
	TUPLE(elems)    = NoAnnoList(Tuple(elems))
	LIST(elems)   	= NoAnnoList(List(elems))
	CALL(s)         = CallNoArgs(SVar(s))
	
	DEF_RULE(pattern, sc, call) =
	SDefT(
  	"nabl-def-site"
	, [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
	, Seq(Match(pattern), Seq(sc, call))
  )
  	
  DEF_RULE(pattern, call) =
	SDefT(
  	"nabl-def-site"
	, [DefaultVarDec("child-uris"), DefaultVarDec("sibl-uris")]
  , [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
	, Seq(Match(pattern), call)
	)
  	
	DEF_CALL(ns, u, ds, s) = 
	CallT(
	  SVar("nabl-def")
  , [CALL("child-uris"), CALL("sibl-uris")]
  , [ Var("context"), Var("uris"), ns, u, ds, LIST(s)]
	)

	SCOPE_RULE(pattern, scopes) =
	SDefT(
	  "nabl-anonymous-scope-site"
	, [DefaultVarDec("child-uris")]
	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("states")]
	, Seq(
	  	Match(pattern)
	  , CallT(
				SVar("nabl-anonymous-scope")
  		, [CALL("child-uris")]
  		, [ Var("context"), Var("uris"), LIST(scopes) ]
		  )
    )
	)
  	
	SCOPE() = Var("scope")
	
	SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallT(SVar("nabl-def-scope"), [], [Var("context")]), ns)))
		
	PROP_RULE(pattern, call) =
	SDefT(
  	"nabl-prop-site"
	, []
	, [DefaultVarDec("context"), DefaultVarDec("states")]
	, Seq(Match(pattern), call)
  )
  
  PROP_CALL(ps) = 
	CallT(
		SVar("nabl-props")
  , []
  , [ Var("context"), LIST(ps)]
	)
	
	PROPERTY(p, v) = TERM("Prop", [p, v])

	USE_RULE(pattern, call) =
	SDefT(
	  "nabl-use-site"
	, []
	, [DefaultVarDec("context"), DefaultVarDec("uris"), DefaultVarDec("deps"), DefaultVarDec("states")]
	, Seq(Match(pattern), call)
  )
  
  USE_CALL(candidates) =
  CallT(
  	SVar("nabl-use")
  , []
  , [ Var("context"), Var("uris"), Var("deps"), LIST(candidates)]	
  )
  
  CANDIDATE(ns) =
  TERM("UseCandidate", [ns, LIST([]), TERM("Current"), TERM("All")])

	CANDIDATE(ns1, ns2, n) =
  TERM("UseCandidate", [ns1, LIST([]), TERM("Current"), TERM("Context", [n, ns2, LIST([]), TERM("All")])])

rules // helper
	
	nonempty = where(Hd)

	replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
	
	replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
