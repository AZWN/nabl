module new-generate

imports 
	
	libstrc
  include/NameBindingLanguage

rules
	
	generate-name-analysis:
		(selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <nabl-to-str; to-ppable-str> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

  to-ppable-str = meta-explode(fail); alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)

rules // modules
	
	nabl-to-str:
		Module(name, sections) -> Module(name, <filter(nabl-to-str)> sections)
		
rules // namespaces 
			
	nabl-to-str:
		Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
		
	nabl-to-str: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
	
	nabl-to-str: NamespaceRef(ns) -> TERM(ns, [])

rules // properties
				
	nabl-to-str:
		Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
	
	nabl-to-str: // generate constructors for properties
		Property(prop, _, _) -> CONS_DECL(prop, "Property")	

	nabl-to-str: PropertyRef(p) -> TERM(p, [])
	nabl-to-str: TypeProp()     -> TERM("Type", [])

rules // imports
		
	nabl-to-str = Imports(id)
		
rules // binding rules

	//TODO: replace filter by map	
	nabl-to-str:
		BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
			
rules // definition sites
		
	// TODO: support multiple definition sites
	// TODO: support anonymous scopes
	nabl-to-str: 
		BindingRule(pattern, parts) -> dr*
		where
			scopes := <filter(\Scopes(scs)-> <map(nabl-to-str)> scs\); concat> parts;
			dr*    := <fetch-elem(def-to-str(|pattern, scopes))> parts
			
	// TODO: support conditions 
	// TODO: support def scopes
	def-to-str(|pattern, scopes):
		DefSite(u, NameBinding(ns, t), ps, ds, []) -> [dr*, pr*]
		where
			ds':= <?DefScopes(<id>); not(?[Subsequent()])> ds 
				< ( ds'' := LIST([SCOPE()|<nabl-to-str> ds])
			  ; replace* := <filter(def-scope-to-str)> ds'
				; sc       := SCOPE_CALL(<nabl-to-str> ns) )
				+ (ds'', replace*, sc) := (<nabl-to-str> ds, [], Id()) 
		where
			replace2* := [(<to-ppable-str> t, DEF_CALL(<nabl-to-str> ns, u, ds'', scopes)), replace*];
			call := <replace-all(|replace2*)> pattern;
			dr* := [DEF_RULE(pattern, sc, call)] <+
			dr* := []
		where
			pcall := <replace-all(|[(<to-ppable-str> t, PROP_CALL(<map(prop-to-str)> ps))])> pattern;
			pr*   := [PROP_RULE(pattern, pcall)] <+
			pr*   := []

	nabl-to-str: Current()			-> ToMetaExpr(Current())
	nabl-to-str: DefScopes(ds*)	-> <filter(nabl-to-str)> ds* 
	nabl-to-str: Subsequent() 	-> ToMetaExpr(Subsequent())
	
	prop-to-str:
		PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)			
	
	def-scope-to-str:
		DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())			
		
signature constructors
	
	ToMetaExpr  : Term -> Term
	FromMetaExpr: Term -> Term
overlays

	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	TERM(o, args) 	= NoAnnoList(Op(o, args))
	TUPLE(elems)    = NoAnnoList(Tuple(elems))
	LIST(elems)   	= NoAnnoList(List(elems))
	
	DEF_RULE(pattern, sc, call) =
	SDefT(
  	"nabl-def-site"
		, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
		, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths")]
		, Seq(Match(pattern), Seq(sc, call))
  )
  		
	DEF_CALL(ns, u, ds, s) = 
	CallT(
		SVar("nabl-def")
    , [CallNoArgs(SVar("cpaths")), CallNoArgs(SVar("spaths"))]
    , [ Var("lang"), Var("elems"), Var("tasks"), Var("paths")
      , ns, ToMetaExpr(u), ds, LIST(s)
  		]
	)

	SCOPE() = Var("scope")
	
	SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CallNoArgs(SVar("nabl-def-scope")), LIST([ns]))))
		
	PROP_RULE(pattern, call) =
	SDefT(
  	"nabl-prop-site"
		, []
		, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks")]
		, Seq(Match(pattern), call)
  )
  
  PROP_CALL(ps) = 
	CallT(
		SVar("nabl-props")
    , []
    , [ Var("lang"), Var("elems"), Var("tasks"), LIST(ps)]
	)
	
	PROPERTY(p, v) = TERM("Prop", [p, v])

rules // helper
	
	nonempty = where(Hd)

	replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
	
	replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
