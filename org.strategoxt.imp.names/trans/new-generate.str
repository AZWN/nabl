module new-generate

imports 
	
	libstrc
  include/NameBindingLanguage

rules
	
	generate-name-analysis:
		(selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <nabl-to-str; to-ppable-str> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

  to-ppable-str = meta-explode(fail); alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)

rules // modules
	
	nabl-to-str:
		Module(name, sections) -> Module(name, <filter(nabl-to-str)> sections)
		
rules // namespaces 
			
	nabl-to-str:
		Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
		
	nabl-to-str: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
	
	nabl-to-str: NamespaceRef(ns) -> TERM(ns)

rules // properties
				
	nabl-to-str:
		Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
	
	nabl-to-str: // generate constructors for properties
		Property(prop, _, _) -> CONS_DECL(prop, "Property")	

	nabl-to-str: PropertyRef(p) -> TERM(p)
	nabl-to-str: TypeProp()     -> TERM("Type")

rules // imports
		
	nabl-to-str = Imports(id)
		
rules // binding rules

	nabl-to-str:
		BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
			
rules // definition sites
		
	// TODO: support multiple definition sites
	// TODO: support anonymous scopes
	nabl-to-str: 
		BindingRule(pattern, parts) -> <fetch-elem(def-to-str(|pattern, scopes))> parts
		where
			scopes := <mapconcat(scopes-to-str)> parts
			
	scopes-to-str =
		  ?Scopes(<id>) 
		< map(nabl-to-str)
		+ ![]
		
	// TODO: support conditions 
	def-to-str(|pattern, scopes):
		DefSite(u, NameBinding(ns, t), ps, ds, []) -> [dr, pr*]
		where
			replace := ( <to-ppable-str> t 
			           , DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes)
			           )
		where
			replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
			sc       := SCOPE_CALL(<nabl-to-str> ns);
			dr       := DEF_RULE(pattern, sc, <replace-all(|[replace, replace*])> pattern) <+
			dr       := DEF_RULE(pattern, <replace-all(|[replace])> pattern)
		where
			preplace := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
			pr*      := [PROP_RULE(pattern, <replace-all(|[preplace])> pattern)] <+
			pr*      := []

	nabl-to-str: Current()									-> ToMetaExpr(Current())
	nabl-to-str: DefScopes([Subsequent()])	-> LIST([ToMetaExpr(Subsequent())])
	nabl-to-str: DefScopes(ds@[_, _|_])			-> LIST([SCOPE()|<filter(!ToMetaExpr(<?Subsequent()>))> ds]) 
	
	nabl-to-str: NonUnique() -> TERM("NonUnique")
	nabl-to-str: Unique()    -> RootApp(CALL("nabl-unique-qualifier"))
	
	prop-to-str:
		PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)			
	
	def-scope-to-str:
		DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())			
		
signature constructors
	
	ToMetaExpr  : Term -> Term
	
overlays

	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	TERM(o, args) 	= NoAnnoList(Op(o, args))
	TERM(o) 	      = TERM(o, [])
	TUPLE(elems)    = NoAnnoList(Tuple(elems))
	LIST(elems)   	= NoAnnoList(List(elems))
	CALL(s)         = CallNoArgs(SVar(s))
	
	DEF_RULE(pattern, sc, call) =
	SDefT(
  	"nabl-def-site"
		, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
		, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths")]
		, Seq(Match(pattern), Seq(sc, call))
  )
  	
  DEF_RULE(pattern, call) =
	SDefT(
  	"nabl-def-site"
		, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
		, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths")]
		, Seq(Match(pattern), call)
  )
  	
	DEF_CALL(ns, u, ds, s) = 
	CallT(
		SVar("nabl-def")
    , [CALL("cpaths"), CALL("spaths")]
    , [ Var("lang"), Var("elems"), Var("tasks"), Var("paths")
      , ns, u, ds, LIST(s)
  		]
	)

	SCOPE() = Var("scope")
	
	SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CALL("nabl-def-scope"), LIST([ns]))))
		
	PROP_RULE(pattern, call) =
	SDefT(
  	"nabl-prop-site"
		, []
		, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks")]
		, Seq(Match(pattern), call)
  )
  
  PROP_CALL(ps) = 
	CallT(
		SVar("nabl-props")
    , []
    , [ Var("lang"), Var("elems"), Var("tasks"), LIST(ps)]
	)
	
	PROPERTY(p, v) = TERM("Prop", [p, v])

rules // helper
	
	nonempty = where(Hd)

	replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
	
	replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
