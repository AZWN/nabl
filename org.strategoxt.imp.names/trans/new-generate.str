module new-generate

imports 
	
	libstrc
  include/NameBindingLanguage

rules
	
	generate-name-analysis:
		(selected, position, ast@Module(name, _), path, project-path) -> (filename, result)
		with
			filename   := <guarantee-extension(|"str")> path ;
			str-module := <nabl-to-str; to-ppable-str> ast ;
			// use next line to debug which AST node cannot be handled by the pretty-printer
			<bottomup(try(not(is-string) ; not(is-list) ; not(pp-stratego-string) ; debug(!"cannot pp ")))> str-module ;
			result     := <pp-stratego-string> str-module

  to-ppable-str = alltd(to-ppable-str-local)
    
	to-ppable-str-local: ListVar(x)    -> Var(x)
	to-ppable-str-local: VarRef(x)     -> Var(x)
	to-ppable-str-local: ListVarRef(x) -> Var(x)

rules // modules
	
	nabl-to-str:
		Module(name, sections) -> Module(name, <filter(nabl-to-str)> sections)
		
rules // namespaces 
			
	nabl-to-str:
		Namespaces(namespaces) -> Signature([Constructors(<map(nabl-to-str)> namespaces)])
		
	nabl-to-str: // generates constructors for namespaces
		Namespace(ns) -> CONS_DECL(ns, "Namespace")
	
	nabl-to-str: NamespaceRef(ns) -> TERM(ns)

rules // properties
				
	nabl-to-str:
		Properties(props) -> Signature([Constructors(<map(nabl-to-str)> props)])
	
	nabl-to-str: // generate constructors for properties
		Property(prop, _, _) -> CONS_DECL(prop, "Property")	

	nabl-to-str: PropertyRef(p) -> TERM(p)
	nabl-to-str: TypeProp()     -> TERM("Type")

rules // imports
		
	nabl-to-str = Imports(id)
		
rules // binding rules

	nabl-to-str:
		BindingRules(rs) -> Rules(<filter(nabl-to-str); concat; nonempty> rs)
			
rules // definitions, scopes, properties
		
	// TODO: support multiple definition sites
	nabl-to-str: 
		BindingRule(pattern, parts) -> result
		where
			scopes := <filter(?Scopes(<id>)); concat; map(nabl-to-str)> parts
		where
			result := <fetch-elem(def-to-str(|pattern, scopes))> parts <+
			result := [SCOPE_RULE(pattern, <nonempty> scopes)]

	// TODO: support conditions 
	def-to-str(|pattern, scopes):
		DefSite(u, NameBinding(ns, t), ps, ds, []) -> [dr, pr*]
		where
			replace := ( <to-ppable-str> t 
			           , DEF_CALL(<nabl-to-str> ns, <nabl-to-str> u, <nabl-to-str> ds, scopes)
			           )
		where
			replace* := <?DefScopes(<filter(def-scope-to-str)>); nonempty> ds;
			sc       := SCOPE_CALL(<nabl-to-str> ns);
			dr       := DEF_RULE(pattern, sc, <replace-all(|[replace, replace*])> pattern) <+
			dr       := DEF_RULE(pattern, <replace-all(|[replace])> pattern)
		where
			preplace := (<to-ppable-str> t, PROP_CALL(<nonempty; map(prop-to-str)> ps));
			pr*      := [PROP_RULE(pattern, <replace-all(|[preplace])> pattern)] <+
			pr*      := []

	nabl-to-str: Current() -> TERM("Current")
	nabl-to-str: 
		DefScopes(ds)	-> LIST([sc1*, sc2*])
		where
			if <fetch-elem(?DefScope(_))> ds then
				sc1* := [SCOPE()]
			else
				sc1* := []
			end;
			if <fetch-elem(?Subsequent())> ds then
				sc2* := [TERM("Subsequent")]
			else
				sc2* := []
			end
	 	
	nabl-to-str: NonUnique() -> TERM("NonUnique")
	nabl-to-str: Unique()    -> RootApp(CALL("nabl-unique-qualifier"))
	
	prop-to-str:
		PropertyBinding(p, t) -> PROPERTY(<nabl-to-str> p, <to-ppable-str> t)			
	
	def-scope-to-str:
		DefScope(x) -> (<to-ppable-str> x, SCOPE_CALL())			
			
overlays

	CONS_DECL(c, t) = OpDecl(c, ConstType(SortNoArgs(t)))
	TERM(o, args) 	= NoAnnoList(Op(o, args))
	TERM(o) 	      = TERM(o, [])
	TUPLE(elems)    = NoAnnoList(Tuple(elems))
	LIST(elems)   	= NoAnnoList(List(elems))
	CALL(s)         = CallNoArgs(SVar(s))
	
	DEF_RULE(pattern, sc, call) =
	SDefT(
  	"nabl-def-site"
	, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths"), DefaultVarDec("states")]
	, Seq(Match(pattern), Seq(sc, call))
  )
  	
  DEF_RULE(pattern, call) =
	SDefT(
  	"nabl-def-site"
	, [DefaultVarDec("cpaths"), DefaultVarDec("spaths")]
	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("paths"), DefaultVarDec("states")]
	, Seq(Match(pattern), call)
	)
  	
	DEF_CALL(ns, u, ds, s) = 
	CallT(
	  SVar("nabl-def")
  , [CALL("cpaths"), CALL("spaths")]
  , [ Var("lang"), Var("elems"), Var("tasks"), Var("paths"), ns, u, ds, LIST(s)]
	)

	SCOPE_RULE(pattern, scopes) =
	SDefT(
	  "nabl-anonymous-scope-site"
	, [DefaultVarDec("cpaths")]
	, [DefaultVarDec("lang"), DefaultVarDec("paths"), DefaultVarDec("states")]
	, Seq(
	  	Match(pattern)
	  , CallT(
				SVar("nabl-anonymous-scope")
  		, [CALL("cpaths")]
  		, [ Var("lang"), Var("paths"), LIST(scopes) ]
		  )
    )
	)
  	
	SCOPE() = Var("scope")
	
	SCOPE_CALL()   = CallT(SVar("nabl-def-scope"), [], [SCOPE()])
	SCOPE_CALL(ns) = Where(Assign(SCOPE(), App(CALL("nabl-def-scope"), ns)))
		
	PROP_RULE(pattern, call) =
	SDefT(
  	"nabl-prop-site"
	, []
	, [DefaultVarDec("lang"), DefaultVarDec("elems"), DefaultVarDec("tasks"), DefaultVarDec("states")]
	, Seq(Match(pattern), call)
  )
  
  PROP_CALL(ps) = 
	CallT(
		SVar("nabl-props")
  , []
  , [ Var("lang"), Var("elems"), Var("tasks"), LIST(ps)]
	)
	
	PROPERTY(p, v) = TERM("Prop", [p, v])

rules // helper
	
	nonempty = where(Hd)

	replace-all(|rs) = alltd(replace(|rs) <+ introduce-id)
	
	replace(|rs): t1 -> t2 where <fetch-elem(?(t1, t2))> rs
	
	introduce-id: Wld()      -> Id()
	introduce-id: Var(_)     -> Id()
	introduce-id: ListVar(_) -> Id()
