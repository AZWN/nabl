module NameBindingLanguage

imports
  
	stratego/NDL-Layout
	stratego/NDL-Identifiers
	stratego/NDL-Vars
	stratego/NDL-Signatures
	stratego/NDL-Terms[Var]
	stratego/NDL-Terms[VarRef]
		
exports 
  
	context-free start-symbols

		Start

	context-free syntax
  	
		Term[[Var]]			-> BTerm %% term binding variables
		Term[[VarRef]]	-> RTerm %% term referencing variables
  	
	context-free syntax
		
		"module" ModName ModSection*												-> Start 					{"Module"}
		
		
	context-free syntax %% imports
				
		"imports" ImportModName* 														-> ModSection {"Imports"}
    ModName																							-> ImportModName	{"Import"}

  syntax

		<ModName-CF> "/" "-" 																-> <ImportModName-CF> {"ImportWildcard"}
    

	context-free syntax %% sections
		
		%% Namespaces
		"namespaces" Namespace*															-> ModSection			{"Namespaces"}
		NamespaceId																					-> Namespace			{"Namespace"}
		NamespaceId																					-> NamespaceRef		{"NamespaceRef"}
		NamespaceRef																				-> INamespaceRef
		"imported" NamespaceId															-> INamespaceRef	{"ImportedNsRef"}
		
		%% Properties
		"properties" PropertyDef*														-> ModSection			{"Properties"}
		PropertyId "of" {NamespaceRef ","}+ ":" Sort				-> PropertyDef		{"Property"}
		PropertyId																					-> PropertyRef		{"PropertyRef"}
		
		"type"																							-> PropertyRef 		{"TypeProp"}

		"binding" "rules" NamingRule*												-> ModSection			{"BindingRules"}

		BTerm ":" NamingRulePart+														-> NamingRule			{"BindingRule"}
		
	context-free syntax %% definition sites	
		
		"defines" Unique Binding Property* DefScopes Constraint* -> NamingRulePart {"DefSite"}
		
																												-> Unique					{"Unique"}
		"unique"																						-> Unique					{"Unique"}
		"non-unique"																				-> Unique					{"NonUnique"}
		
		NamespaceRef RTerm																	-> Binding			  {"NameBinding"}
		INamespaceRef RTerm																	-> IBinding			  {"NameBinding"}
		NamespaceRef BTerm																	-> BBinding			  {"NameBinding"}
		"of" PropertyRef RTerm															-> Property				{"PropertyBinding"}
		"of" PropertyRef BTerm															-> BProperty			{"PropertyBinding"}
		
																												-> DefScopes			{"Current"}
		"in" "current" "scope"															-> DefScopes			{"Current"}
		"in" {DefScope ","}+															  -> DefScopes			{"DefScopes"}
		"subsequent" "scope"																-> DefScope		  	{"Subsequent"}
		RTerm																								-> DefScope				{"DefScope"}
		
	context-free syntax
		
		"scopes" {NamespaceRef ","}+												-> NamingRulePart {"Scopes"}			
		
	context-free syntax %% use sites

		{RefPart "otherwise"}+															-> NamingRulePart	{"UseSite"} 		
		"refers" "to" RefPartCore 													-> RefPart				{bracket}
		IBinding BProperty* RefScope Constraint*						-> RefPartCore		{"Reference"}
			
		%% TODO this should be RefPartCore, but without additional constraints
		"in" Binding																				-> RefScope			 	{"RefScope"}
		"in" "current" "scope"															-> RefScope				{"Current"}
		"in" "surrounding" NamespaceRef											-> RefScope				{"Surrounding"}
																												-> RefScope				{"All"}
	
	context-free syntax %% qualified names

		{QualifiedPart "otherwise"}+												-> NamingRulePart	{"QualifiedName"} 		
		"qualifies" Binding "in" Binding 										-> QualifiedPart	{bracket}
		
	context-free syntax %% imports
		
		"imports"{INamespaceRef ","}+ "from" RefPartCore IDefScopes	-> NamingRulePart {"ImportFromSite"}
		"imports"{INamespaceRef ","}+ "into" RefPartCore IDefScopes	-> NamingRulePart {"ImportToSite"}
		
																												-> IDefScopes			{"Current"}
		"into" "current" "scope"														-> IDefScopes			{"Current"}
		"into" {DefScope ","}+	 														-> IDefScopes			{"DefScopes"}
		
		%% Constraint
		"where" RTerm Condition															-> Constraint 		{"Constraint"}
		"has" PropertyRef BTerm															-> Condition			{"PropertyCond"}
		"is" "of" PropertyRef BTerm													-> Condition			{"PropertyCond"}
		"refers" "to" BBinding Property* RefScope						-> Condition			{"ReferenceCond"}
		  
	lexical syntax
	
		"namespaces"	-> ModName			{reject}
		"properties"	-> ModName			{reject}

		Id						-> NamespaceId
		"binding"			-> NamespaceId	{reject}
		"surrounding"	-> NamespaceId	{reject}
		"properties"	-> NamespaceId	{reject}

		Id						-> PropertyId	
		"type"				-> PropertyId 	{reject}
		
		
 